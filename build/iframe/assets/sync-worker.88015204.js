(function(){"use strict";class Bi{constructor(){if(this._handlers=new Map,!(typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope))throw"BaseWorker can only be used in workers, it cannot be used in the main thread."}setHandler(e,t){if(this._handlers.has(e))throw`A handler for requests of type ${e} is already set`;this._handlers.set(e,t)}async handleRequest(e){let t={request:e,data:{}};try{const s=this._handlers.get(e.type);if(!s)throw`No handler is registered for requests of type ${e.type}`;t=await s(e)}catch(s){t.error=s}return t}}class Li extends Bi{constructor(){if(super(),!(self instanceof SharedWorkerGlobalScope))throw"SharedWorker can only be used in a SharedWorker context";self.onconnect=t=>{const s=t.ports[0];s.onmessage=async i=>await this.onRequest(i,s)}}async onRequest(e,t){const s=e.data,i=await this.handleRequest(s);t.postMessage(i)}get name(){return self.name}}var yt=(n=>(n.StartSync="StartSync",n.AddPendingEvent="AddPendingEvent",n))(yt||{}),gt=(n=>(n.StatusChanged="StatusChanged",n.SyncChanges="SyncChanges",n))(gt||{});function as(){return qi()}function qi(){return Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString()}class L extends Error{get name(){return"AbortError"}}class ji{constructor(e){this._reject=null,this._handle=null,this._promise=new Promise((t,s)=>{this._reject=s,this._handle=setTimeout(()=>{this._reject=null,t()},e)})}elapsed(){return this._promise}abort(){this._reject&&(this._reject(new L),clearTimeout(this._handle),this._handle=null,this._reject=null)}dispose(){this.abort()}}class $i{constructor(e,t){this._handle=setInterval(t,e)}dispose(){this._handle&&(clearInterval(this._handle),this._handle=null)}}class Wi{constructor(){this._start=window.performance.now()}measure(){return window.performance.now()-this._start}}class Gi{createMeasure(){return new Wi}createTimeout(e){return new ji(e)}createInterval(e,t){return new $i(t,e)}now(){return Date.now()}}class cs extends Error{constructor(e,t){super(`${e}: ${t.message}`),this.cause=t}get name(){return"WrappedError"}}class ds extends Error{constructor(e,t,s,i){super(`${s?s.error:i} on ${e} ${t}`),this.errcode=s?s.errcode:null,this.retry_after_ms=s?s.retry_after_ms:0,this.statusCode=i}get name(){return"HomeServerError"}}class Y extends Error{constructor(e,t){super(e||"ConnectionError"),this.isTimeout=t}get name(){return"ConnectionError"}}class $e{constructor(){this._handlers=new Set}onSubscribeFirst(){}onUnsubscribeLast(){}subscribe(e){return this._handlers.add(e),this._handlers.size===1&&this.onSubscribeFirst(),()=>this.unsubscribe(e)}unsubscribe(e){e&&(this._handlers.delete(e),this._handlers.size===0&&this.onUnsubscribeLast())}unsubscribeAll(){this._handlers.size!==0&&(this._handlers.clear(),this.onUnsubscribeLast())}get hasSubscriptions(){return this._handlers.size!==0}}class fe extends $e{emit(e){for(const t of this._handlers)t(e)}waitFor(e){return e(this.get())?new Hi(Promise.resolve(this.get())):new Vi(this,e)}flatMap(e){return new zi(this,e)}}class Vi{constructor(e,t){this._promise=new Promise((s,i)=>{this._reject=i,this._subscription=e.subscribe(r=>{t(r)&&(this._reject=null,s(r),this.dispose())})})}get promise(){return this._promise}dispose(){this._subscription&&(this._subscription(),this._subscription=null),this._reject&&(this._reject(new L),this._reject=null)}}class Hi{constructor(e){this.promise=e}dispose(){}}class re extends fe{constructor(e){super(),this._value=e}get(){return this._value}set(e){e!==this._value&&(this._value=e,this.emit(this._value))}}class zi extends fe{constructor(e,t){super(),this.source=e,this.mapper=t}onUnsubscribeLast(){super.onUnsubscribeLast(),this.sourceSubscription=this.sourceSubscription(),this.targetSubscription&&(this.targetSubscription=this.targetSubscription())}onSubscribeFirst(){super.onSubscribeFirst(),this.sourceSubscription=this.source.subscribe(()=>{this.updateTargetSubscription(),this.emit(this.get())}),this.updateTargetSubscription()}updateTargetSubscription(){const e=this.source.get();if(e){const t=this.mapper(e);if(t){this.targetSubscription||(this.targetSubscription=t.subscribe(()=>this.emit(this.get())));return}}this.targetSubscription&&(this.targetSubscription=this.targetSubscription())}get(){const e=this.source.get();return e?this.mapper(e)?.get():void 0}}class We extends re{constructor(e,t,s=()=>{}){super(e),this.freeCallback=t,this.startCallback=s}onSubscribeFirst(){this.startCallback()}onUnsubscribeLast(){super.onUnsubscribeLast(),this.freeCallback()}}class ke extends $e{emitReset(){for(let e of this._handlers)e.onReset(this)}emitAdd(e,t){for(let s of this._handlers)s.onAdd(e,t,this)}emitUpdate(e,t,s){for(let i of this._handlers)i.onUpdate(e,t,s,this)}emitRemove(e,t){for(let s of this._handlers)s.onRemove(e,t,this)}emitMove(e,t,s){for(let i of this._handlers)i.onMove(e,t,s,this)}}/**
 * @license
 * Based off baseSortedIndex function in Lodash <https://lodash.com/>
 * Copyright JS Foundation and other contributors <https://js.foundation/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */function ne(n,e,t){let s=0,i=n.length;for(;s<i;){let r=s+i>>>1,o=t(e,n[r]);o>0?s=r+1:o<0?i=r:s=i=r}return i}class Qi extends ke{constructor(e=[]){super(),this._items=e}append(e){this._items.push(e),this.emitAdd(this._items.length-1,e)}remove(e){const[t]=this._items.splice(e,1);this.emitRemove(e,t)}insertMany(e,t){for(let s of t)this.insert(e,s),e+=1}insert(e,t){this._items.splice(e,0,t),this.emitAdd(e,t)}move(e,t){if(e<this._items.length&&t<this._items.length){const[s]=this._items.splice(e,1);this._items.splice(t,0,s),this.emitMove(e,t,s)}}update(e,t,s=null){e<this._items.length&&(this._items[e]=t,this.emitUpdate(e,t,s))}get array(){return this._items}at(e){if(this._items&&e>=0&&e<this._items.length)return this._items[e]}get length(){return this._items.length}[Symbol.iterator](){return this._items.values()}}function hs(n,e,t,s){const i=e.findIndex(n);if(i!==-1){const r=e[i],o=s(r);return o!==!1&&t.emitUpdate(i,r,o),!0}return!1}class ls extends ke{constructor(e){super(),this._items=[],this._comparator=e}setManyUnsorted(e){this.setManySorted(e)}setManySorted(e){for(let t of e)this.set(t)}findAndUpdate(e,t){return hs(e,this._items,this,t)}getAndUpdate(e,t,s=null){const i=this.indexOf(e);if(i!==-1){const r=this._items[i],o=t(r,e);this._items[i]=o,this.emitUpdate(i,o,s)}}update(e,t=null){const s=this.indexOf(e);s!==-1&&(this._items[s]=e,this.emitUpdate(s,e,t))}indexOf(e){const t=ne(this._items,e,this._comparator);return t<this._items.length&&this._comparator(this._items[t],e)===0?t:-1}_getNext(e){let t=ne(this._items,e,this._comparator);for(;t<this._items.length&&this._comparator(this._items[t],e)<=0;)t+=1;return this.get(t)}set(e,t=null){const s=ne(this._items,e,this._comparator);s>=this._items.length||this._comparator(this._items[s],e)!==0?(this._items.splice(s,0,e),this.emitAdd(s,e)):(this._items[s]=e,this.emitUpdate(s,e,t))}get(e){return this._items[e]}remove(e){const t=this._items[e];this._items.splice(e,1),this.emitRemove(e,t)}get array(){return this._items}get length(){return this._items.length}[Symbol.iterator](){return new Ji(this)}}class Ji{constructor(e){this._consumed=!1,this._sortedArray=e,this._current=null}next(){return this._consumed?{value:void 0,done:!0}:(this._current=this._current?this._sortedArray._getNext(this._current):this._sortedArray.get(0),this._current||(this._consumed=!0),{value:this._current,done:this._consumed})}}class Yi extends ke{constructor(e,t,s,i){super(),this._sourceUnsubscribe=null,this._mappedValues=null,this._sourceList=e,this._mapper=t,this._updater=s,this._removeCallback=i}findAndUpdate(e,t){return hs(e,this._mappedValues,this,t)}get length(){return this._mappedValues.length}[Symbol.iterator](){return this._mappedValues.values()}}function Xi(n,e,t){n._mappedValues.splice(e,0,t),n.emitAdd(e,t)}function Zi(n,e,t,s){const i=n._mappedValues[e];n._updater&&n._updater(i,s,t),n.emitUpdate(e,i,s)}function er(n,e){const t=n._mappedValues[e];n._mappedValues.splice(e,1),n._removeCallback&&n._removeCallback(t),n.emitRemove(e,t)}function tr(n,e,t){const s=n._mappedValues[e];n._mappedValues.splice(e,1),n._mappedValues.splice(t,0,s),n.emitMove(e,t,s)}function sr(n){n._mappedValues=[],n.emitReset()}class ir extends Yi{constructor(){super(...arguments),this._eventQueue=null,this._flushing=!1}onSubscribeFirst(){this._sourceUnsubscribe=this._sourceList.subscribe(this),this._eventQueue=[],this._mappedValues=[];let e=0;for(const t of this._sourceList)this._eventQueue.push(new us(e,t)),e+=1;this._flush()}async _flush(){if(!this._flushing){this._flushing=!0;try{for(;this._eventQueue.length;)await this._eventQueue.shift().run(this)}finally{this._flushing=!1}}}onReset(){this._eventQueue&&(this._eventQueue.push(new ar),this._flush())}onAdd(e,t){this._eventQueue&&(this._eventQueue.push(new us(e,t)),this._flush())}onUpdate(e,t,s){this._eventQueue&&(this._eventQueue.push(new rr(e,t,s)),this._flush())}onRemove(e){this._eventQueue&&(this._eventQueue.push(new nr(e)),this._flush())}onMove(e,t){this._eventQueue&&(this._eventQueue.push(new or(e,t)),this._flush())}onUnsubscribeLast(){this._sourceUnsubscribe(),this._eventQueue=null,this._mappedValues=null}}class us{constructor(e,t){this.index=e,this.value=t}async run(e){const t=await e._mapper(this.value);Xi(e,this.index,t)}}class rr{constructor(e,t,s){this.index=e,this.value=t,this.params=s}async run(e){Zi(e,this.index,this.value,this.params)}}class nr{constructor(e){this.index=e}async run(e){er(e,this.index)}}class or{constructor(e,t){this.fromIdx=e,this.toIdx=t}async run(e){tr(e,this.fromIdx,this.toIdx)}}class ar{async run(e){sr(e)}}class cr extends ke{constructor(...e){super(),this._sourceUnsubscribes=null,this._sourceLists=e}_offsetForSource(e){const t=this._sourceLists.indexOf(e);let s=0;for(let i=0;i<t;++i)s+=this._sourceLists[i].length;return s}onSubscribeFirst(){this._sourceUnsubscribes=this._sourceLists.map(e=>e.subscribe(this))}onUnsubscribeLast(){for(const e of this._sourceUnsubscribes)e()}onReset(){this.emitReset();let e=0;for(const t of this)this.emitAdd(e,t),e+=1}onAdd(e,t,s){this.emitAdd(this._offsetForSource(s)+e,t)}onUpdate(e,t,s,i){!this._sourceUnsubscribes||this.emitUpdate(this._offsetForSource(i)+e,t,s)}onRemove(e,t,s){this.emitRemove(this._offsetForSource(s)+e,t)}onMove(e,t,s,i){const r=this._offsetForSource(i);this.emitMove(r+e,r+t,s)}get length(){let e=0;for(let t=0;t<this._sourceLists.length;++t)e+=this._sourceLists[t].length;return e}[Symbol.iterator](){let e=0,t=this._sourceLists[0][Symbol.iterator]();return{next:()=>{let s=t.next();for(;s.done;){if(e+=1,e>=this._sourceLists.length)return s;t=this._sourceLists[e][Symbol.iterator](),s=t.next()}return s}}}}class dr extends ke{constructor(e,t){super(),this._sourceMap=e,this._comparator=(s,i)=>t(s.value,i.value),this._sortedPairs=null,this._mapSubscription=null}onAdd(e,t){const s={key:e,value:t},i=ne(this._sortedPairs,s,this._comparator);this._sortedPairs.splice(i,0,s),this.emitAdd(i,t)}onRemove(e,t){const s={key:e,value:t},i=ne(this._sortedPairs,s,this._comparator);this._sortedPairs.splice(i,1),this.emitRemove(i,t)}onUpdate(e,t,s){if(!this._sortedPairs)return;const i=this._sortedPairs.findIndex(a=>a.key===e);this._sortedPairs.splice(i,1);const r={key:e,value:t},o=ne(this._sortedPairs,r,this._comparator);this._sortedPairs.splice(o,0,r),i!==o&&this.emitMove(i,o,t),this.emitUpdate(o,t,s)}onReset(){this._sortedPairs=[],this.emitReset()}onSubscribeFirst(){this._mapSubscription=this._sourceMap.subscribe(this),this._sortedPairs=new Array(this._sourceMap.size);let e=0;for(let[t,s]of this._sourceMap)this._sortedPairs[e]={key:t,value:s},++e;this._sortedPairs.sort(this._comparator),super.onSubscribeFirst()}onUnsubscribeLast(){super.onUnsubscribeLast(),this._sortedPairs=null,this._mapSubscription=this._mapSubscription()}get(e){return this._sortedPairs[e].value}get length(){return this._sourceMap.size}[Symbol.iterator](){const e=this._sortedPairs.values();return{next(){const t=e.next();return t.value&&(t.value=t.value.value),t}}}}class Ge extends $e{constructor(){super()}emitReset(){for(let e of this._handlers)e.onReset()}emitAdd(e,t){for(let s of this._handlers)s.onAdd(e,t)}emitUpdate(e,t,s){for(let i of this._handlers)i.onUpdate(e,t,s)}emitRemove(e,t){for(let s of this._handlers)s.onRemove(e,t)}join(...e){return new ur([this].concat(e))}mapValues(e,t){return new _r(this,e,t)}sortValues(e){return new dr(this,e)}filterValues(e){return new hr(this,e)}observeSize(){return new fr(this)}}class hr extends Ge{constructor(e,t){super(),this._source=e,this._filter=t}setFilter(e){this._filter=e,this._subscription&&this._reapplyFilter()}_reapplyFilter(e=!1){if(this._filter){const t=this._included;this._included=this._included||new Map;for(const[s,i]of this._source){const r=this._filter(i,s);if(this._included.set(s,r),!e){const o=t?t.get(s):!0;this._emitForUpdate(o,r,s,i)}}}else{if(this._included&&!e)for(const[t,s]of this._source)this._included.get(t)||this.emitAdd(t,s);this._included=void 0}}onAdd(e,t){if(this._filter)if(this._included){const s=this._filter(t,e);if(this._included.set(e,s),!s)return}else throw new Error("Internal logic error: FilteredMap._included used before initialized");this.emitAdd(e,t)}onRemove(e,t){const s=!this._filter||this._included?.get(e);if(this._included)this._included.delete(e),s&&this.emitRemove(e,t);else throw new Error("Internal logic error: FilteredMap._included used before initialized")}onUpdate(e,t,s){if(!!this._included)if(this._filter){const i=this._included.get(e),r=this._filter(t,e);this._included.set(e,r),this._emitForUpdate(i,r,e,t,s)}else this.emitUpdate(e,t,s)}_emitForUpdate(e,t,s,i,r=null){e&&!t?this.emitRemove(s,i):!e&&t?this.emitAdd(s,i):e&&t&&this.emitUpdate(s,i,r)}onSubscribeFirst(){this._subscription=this._source.subscribe(this),this._reapplyFilter(!0),super.onSubscribeFirst()}onUnsubscribeLast(){super.onUnsubscribeLast(),this._included=void 0,this._subscription&&(this._subscription=this._subscription())}onReset(){this._reapplyFilter(),this.emitReset()}[Symbol.iterator](){return new lr(this._source,this._included)}get size(){let e=0;return this._included?.forEach(t=>{t&&(e+=1)}),e}get(e){const t=this._source.get(e);if(t&&this._filter(t,e))return t}}class lr{constructor(e,t){this._included=t,this._sourceIterator=e[Symbol.iterator]()}next(){for(;;){const e=this._sourceIterator.next();if(e.done)return e;const t=e.value[0];if(this._included?.get(t))return e}}}class ur extends Ge{constructor(e){super(),this._sources=e}onAdd(e,t,s){if(!this._isKeyAtSourceOccluded(e,t)){const i=this._getValueFromOccludedSources(e,t);i!==void 0&&this.emitRemove(t,i),this.emitAdd(t,s)}}onRemove(e,t,s){if(!this._isKeyAtSourceOccluded(e,t)){this.emitRemove(t,s);const i=this._getValueFromOccludedSources(e,t);i!==void 0&&this.emitAdd(t,i)}}onUpdate(e,t,s,i){!this._subscriptions||this._isKeyAtSourceOccluded(e,t)||this.emitUpdate(t,s,i)}onReset(){this.emitReset()}onSubscribeFirst(){this._subscriptions=this._sources.map(e=>new pr(e,this).subscribe()),super.onSubscribeFirst()}_isKeyAtSourceOccluded(e,t){const s=this._sources.indexOf(e);for(let i=0;i<s;i+=1)if(this._sources[i].get(t)!==void 0)return!0;return!1}_getValueFromOccludedSources(e,t){const s=this._sources.indexOf(e);for(let i=s+1;i<this._sources.length;i+=1){const o=this._sources[i].get(t);if(o!==void 0)return o}}onUnsubscribeLast(){if(super.onUnsubscribeLast(),this._subscriptions)for(const e of this._subscriptions)e.dispose()}[Symbol.iterator](){return new mr(this._sources)}get size(){return this._sources.reduce((e,t)=>e+t.size,0)}get(e){for(const t of this._sources){const s=t.get(e);if(s)return s}}}class mr{constructor(e){this._sourceIndex=-1,this._encounteredKeys=new Set,this._sources=e}next(){let e;for(;!e;){if(!this._currentIterator){if(this._sourceIndex+=1,this._sources.length<=this._sourceIndex)return{done:!0,value:null};this._currentIterator=this._sources[this._sourceIndex][Symbol.iterator]()}const t=this._currentIterator?.next();if(!t||t.done){this._currentIterator=void 0;continue}else{const s=t.value[0];this._encounteredKeys.has(s)||(this._encounteredKeys.add(s),e=t)}}return e}}class pr{constructor(e,t){this._source=e,this._joinedMap=t,this._subscription=void 0}subscribe(){return this._subscription=this._source.subscribe(this),this}dispose(){this._subscription&&(this._subscription=this._subscription())}onAdd(e,t){this._joinedMap.onAdd(this._source,e,t)}onRemove(e,t){this._joinedMap.onRemove(this._source,e,t)}onUpdate(e,t,s){this._joinedMap.onUpdate(this._source,e,t,s)}onReset(){this._joinedMap.onReset()}}class _r extends Ge{constructor(e,t,s){super(),this._source=e,this._mapper=t,this._updater=s,this._mappedValues=new Map}_emitSpontaneousUpdate(e,t){const s=this._mappedValues.get(e);s&&this.emitUpdate(e,s,t)}onAdd(e,t){const s=this._emitSpontaneousUpdate.bind(this,e),i=this._mapper(t,s);this._mappedValues.set(e,i),this.emitAdd(e,i)}onRemove(e){const t=this._mappedValues.get(e);this._mappedValues.delete(e)&&t&&this.emitRemove(e,t)}onUpdate(e,t,s){if(!this._mappedValues)return;const i=this._mappedValues.get(e);i!==void 0&&(this._updater?.(s,i,t),this.emitUpdate(e,i,s))}onSubscribeFirst(){this._subscription=this._source.subscribe(this);for(let[e,t]of this._source){const s=this._emitSpontaneousUpdate.bind(this,e),i=this._mapper(t,s);this._mappedValues.set(e,i)}super.onSubscribeFirst()}onUnsubscribeLast(){super.onUnsubscribeLast(),this._subscription&&(this._subscription=this._subscription()),this._mappedValues.clear()}onReset(){this._mappedValues.clear(),this.emitReset()}[Symbol.iterator](){return this._mappedValues.entries()}get size(){return this._mappedValues.size}get(e){return this._mappedValues.get(e)}}class oe extends Ge{constructor(e){super(),this._values=new Map(e)}update(e,t){const s=this._values.get(e);return s!==void 0?(this._values.set(e,s),this.emitUpdate(e,s,t),!0):!1}add(e,t){return this._values.has(e)?!1:(this._values.set(e,t),this.emitAdd(e,t),!0)}remove(e){const t=this._values.get(e);return t!==void 0?(this._values.delete(e),this.emitRemove(e,t),!0):!1}set(e,t){return this._values.has(e)?(this._values.set(e,t),this.update(e,void 0)):this.add(e,t)}reset(){this._values.clear(),this.emitReset()}get(e){return this._values.get(e)}get size(){return this._values.size}[Symbol.iterator](){return this._values.entries()}values(){return this._values.values()}keys(){return this._values.keys()}}class fr extends fe{constructor(e){super(),this.map=e}onSubscribeFirst(){this.subscription=this.map.subscribe({onAdd:(e,t)=>{this.emit(this.get())},onRemove:(e,t)=>{this.emit(this.get())},onUpdate:(e,t)=>{},onReset:()=>{this.emit(this.get())}})}onUnsubscribeLast(){this.subscription=this.subscription?.()}get(){return this.map.size}}function yr(n,e,t,s){const i=n(e);let r=!1;return i.elapsed().then(()=>{r=!0,t.abort()},()=>{}),s.then(o=>(i.abort(),o),o=>{throw i.abort(),o.name==="AbortError"&&r?new Y(`Request timed out after ${e}ms`,!0):o})}function ms(n,e=Math.random){return n.includes("?")?n=n+"&":n=n+"?",n+`_cacheBuster=${Math.ceil(e()*Number.MAX_SAFE_INTEGER)}`}function ps(n){const e=new FormData;for(const[t,s]of n)s.blob?.nativeBlob&&s.name?e.set(t,s.blob.nativeBlob,s.name):e.set(t,s);return e}class gr{constructor(e,t){this._promise=e,this._xhr=t}abort(){this._xhr.abort()}response(){return this._promise}}function vr(n,{method:e,headers:t,timeout:s,format:i,uploadProgress:r}){const o=new XMLHttpRequest;if(r&&o.upload.addEventListener("progress",a=>r(a.loaded)),o.open(e,n),i==="buffer"&&(o.responseType="arraybuffer"),t)for(const[a,c]of t.entries())try{o.setRequestHeader(a,c)}catch(d){console.info(`Could not set ${a} header: ${d.message}`)}return s&&(o.timeout=s),o}function wr(n,e,t){return new Promise((s,i)=>{n.addEventListener("load",()=>s(n)),n.addEventListener("abort",()=>i(new L)),n.addEventListener("error",()=>i(new Y(`Error ${e} ${t}`))),n.addEventListener("timeout",()=>i(new Y(`Timeout ${e} ${t}`,!0)))})}function br(n,e){let{cache:t,format:s,body:i,method:r}=e;t||(n=ms(n));const o=vr(n,e),a=wr(o,r,n).then(c=>{const{status:d}=c;let h=null;return s==="buffer"?h=c.response:c.getResponseHeader("Content-Type")==="application/json"&&(h=JSON.parse(c.responseText)),{status:d,body:h}});return i?.nativeBlob&&(i=i.nativeBlob),i instanceof Map&&(i=ps(i)),o.send(i||null),new gr(a,o)}class _s{constructor(e,t){if(t)this.promise=e,this._controller=t;else{const s=new Promise((i,r)=>{this._controller={abort(){const o=new Error("fetch request aborted");o.name="AbortError",r(o)}}});this.promise=Promise.race([e,s])}}abort(){this._controller.abort()}response(){return this.promise}}function Ir(n,e){return function(s,i){if(e?.haltRequests)return new _s(new Promise(()=>{}),{});if(i?.uploadProgress)return br(s,i);let{method:r,headers:o,body:a,timeout:c,format:d,cache:h=!1}=i;const l=typeof AbortController=="function"?new AbortController:null;a?.nativeBlob&&(a=a.nativeBlob),a instanceof Map&&(a=ps(a));let u={method:r,body:a};if(l&&(u=Object.assign(u,{signal:l.signal})),h||(s=ms(s)),u=Object.assign(u,{mode:"cors",credentials:"omit",referrer:"no-referrer",cache:"default"}),o){const _=new Headers;for(const[g,R]of o.entries())_.append(g,R);u.headers=_}const p=fetch(s,u).then(async _=>{const{status:g}=_;let R;try{d==="json"?R=await _.json():d==="buffer"?R=await _.arrayBuffer():d==="text"&&(R=await _.text())}catch(_e){if(!(_e.name==="SyntaxError"&&g>=400))throw _e}return{status:g,body:R}},_=>{throw _.name==="AbortError"?new L:_ instanceof TypeError?new Y(`${r} ${s}: ${_.message}`):_}),m=new _s(p,l);return c&&(m.promise=yr(n,c,m,m.promise)),m}}class Sr{constructor(e){const{assets:t}=e;this._assets=t,this._clock=new Gi,this._request=Ir(this._clock.createTimeout)}async loadOlm(){return self.window=self,self.document={},importScripts(this._assets.olmWasmJsPath),this._olm=self.Olm,await this._olm.init({locateFile:()=>this._assets.olmWasmPath}),this._olm}async loadOlmWorker(){return null}get clock(){return this._clock}get request(){return this._request}}class fs{constructor(e){this._start=2e3,this._current=2e3;const t=2e3;this._start=t,this._current=t,this._createTimeout=e,this._max=60*5*1e3}async waitForRetry(){this._timeout=this._createTimeout(this._current);try{await this._timeout.elapsed();const e=2*this._current;this._current=Math.min(this._max,e)}catch(e){if(!(e instanceof L))throw e}finally{this._timeout=void 0}}abort(){this._timeout&&this._timeout.abort()}reset(){this._current=this._start,this.abort()}get nextValue(){return this._current}}class Er{constructor({retryDelay:e,createMeasure:t,onlineStatus:s}){this._onlineStatus=s,this._retryDelay=e,this._createTimeMeasure=t,this._state=new re(2),this._isStarted=!1,this._isReconnecting=!1}get lastVersionsResponse(){return this._versionsResponse}get connectionStatus(){return this._state}get retryIn(){return this._state.get()===0?this._retryDelay.nextValue-this._stateSince.measure():0}get isStarted(){return this._isStarted}start(){this._isStarted=!0}stop(){this._isStarted=!1}async onRequestFailed(e){if(!!this._isStarted&&!this._isReconnecting){this._isReconnecting=!0;const t=this._onlineStatus&&this._onlineStatus.subscribe(s=>{s&&this.tryNow()});try{await this._reconnectLoop(e)}catch(s){console.error(s)}finally{t&&t(),this._isReconnecting=!1}}}tryNow(){this._retryDelay&&this._retryDelay.abort()}_setState(e){e!==this._state.get()&&(e===0?this._stateSince=this._createTimeMeasure():this._stateSince=null,this._state.set(e))}async _reconnectLoop(e){for(this._versionsResponse=void 0,this._retryDelay.reset();this._isStarted&&!this._versionsResponse;)try{this._setState(1);const t=e.versions({timeout:3e4});this._versionsResponse=await t.response(),this._setState(2)}catch(t){if(t.name==="ConnectionError")this._setState(0),await this._retryDelay.waitForRetry();else throw t}}}class Rr extends fe{constructor(){super(),this._onOffline=this._onOffline.bind(this),this._onOnline=this._onOnline.bind(this)}_onOffline(){this.emit(!1)}_onOnline(){this.emit(!0)}get(){return navigator.onLine}onSubscribeFirst(){window.addEventListener("offline",this._onOffline),window.addEventListener("online",this._onOnline)}onUnsubscribeLast(){window.removeEventListener("offline",this._onOffline),window.removeEventListener("online",this._onOnline)}}class ye{constructor(){this._handlersByName={}}emit(e,t){const s=this._handlersByName[e];s&&s.forEach(i=>i(t))}disposableOn(e,t){return this.on(e,t),()=>{this.off(e,t)}}on(e,t){let s=this._handlersByName[e];s||(this.onFirstSubscriptionAdded(e),this._handlersByName[e]=s=new Set),s.add(t)}off(e,t){const s=this._handlersByName[e];s&&(s.delete(t),s.size===0&&(delete this._handlersByName[e],this.onLastSubscriptionRemoved(e)))}onFirstSubscriptionAdded(e){}onLastSubscriptionRemoved(e){}}for(var ys=/[\\\"\x00-\x1F]/g,G={},Ve=0;Ve<32;++Ve)G[String.fromCharCode(Ve)]="\\U"+("0000"+Ve.toString(16)).slice(-4).toUpperCase();G["\b"]="\\b",G["	"]="\\t",G[`
`]="\\n",G["\f"]="\\f",G["\r"]="\\r",G['"']='\\"',G["\\"]="\\\\";function gs(n){return ys.lastIndex=0,n.replace(ys,function(e){return G[e]})}function vt(n){switch(typeof n){case"string":return'"'+gs(n)+'"';case"number":return isFinite(n)?n:"null";case"boolean":return n;case"object":return n===null?"null":Array.isArray(n)?kr(n):Mr(n);default:throw new Error("Cannot stringify: "+typeof n)}}function kr(n){for(var e="[",t="",s=0;s<n.length;++s)t+=e,e=",",t+=vt(n[s]);return e!=","?"[]":t+"]"}function Mr(n){var e="{",t="",s=Object.keys(n);s.sort();for(var i=0;i<s.length;++i){var r=s[i];t+=e+'"'+gs(r)+'":',e=",",t+=vt(n[r])}return e!=","?"{}":t+"}"}var wt={stringify:vt};function bt(...n){const e={};for(const t of n)e[t]=t;return Object.freeze(e)}const ae=bt("Sync","Timeline","Retry"),U="e2ee:",It="m.olm.v1.curve25519-aes-sha2",q="m.megolm.v1.aes-sha2";class M extends Error{constructor(e,t,s=null){super(`Decryption error ${e}${s?": "+JSON.stringify(s):""}`),this.code=e,this.event=t,this.details=s}}const vs="ed25519";function St(n,e,t,s,i,r=void 0){const o=Object.assign({},i);delete o.unsigned,delete o.signatures;const a=wt.stringify(o),c=i?.signatures?.[e]?.[`${vs}:${t}`];try{if(!c)throw new Error("no signature");return n.ed25519_verify(s,a,c),!0}catch(d){if(r){const h=r.log({l:"Invalid signature, ignoring.",ed25519Key:s,canonicalJson:a,signature:c});h.error=d,h.logLevel=r.level.Warn}return!1}}function Cr(){return{type:"m.room.encryption",state_key:"",content:{algorithm:q,rotation_period_ms:6048e5,rotation_period_msgs:100}}}const He=Object.freeze({Joined:"joined",Invited:"invited",WorldReadable:"world_readable",Shared:"shared"});function ze(n,e){switch(e){case He.WorldReadable:return!0;case He.Shared:return n!==void 0;case He.Joined:return n==="join";case He.Invited:return n==="invite"||n==="join";default:return!1}}function Et(n){return n.unsigned?.prev_content||n.prev_content}const j="m.room.redaction";function Rt(n){return!!n?.unsigned?.redacted_because}var A=(n=>(n[n.None=1]="None",n[n.BeingCreated=2]="BeingCreated",n[n.Invited=4]="Invited",n[n.Joined=8]="Joined",n[n.Replaced=16]="Replaced",n[n.Archived=32]="Archived",n))(A||{}),V=(n=>(n[n.DirectMessage=0]="DirectMessage",n[n.Private=1]="Private",n[n.Public=2]="Public",n))(V||{});function ge(n,e){let t;const s=o=>{const a=e(o);a instanceof Promise&&(t=t??[],t.push(a))},i=n.state?.events;if(i)for(let o=0;o<i.length;o++)s(i[o]);let r=n.timeline?.events;if(r)for(let o=0;o<r.length;o++){const a=r[o];typeof a.state_key=="string"&&s(a)}if(t)return Promise.all(t).then(()=>{})}function Tr(n,e,t,s,i){return e.length&&(n=e.reduce((r,o)=>Dr(r,o,t,s,i),n)),n}function Ar(n,e,t,s){e.summary&&(n=Ur(n,e.summary)),t!==n.membership&&(n=n.cloneIfNeeded(),n.membership=t),e.account_data&&(n=e.account_data.events.reduce(xr,n)),ge(e,r=>{n=ws(n,r,s)});const i=e.unread_notifications;return i&&(n=Kr(n,i)),n}function Kr(n,e){const t=e.highlight_count||0;t!==n.highlightCount&&(n=n.cloneIfNeeded(),n.highlightCount=t);const s=e.notification_count;return s!==n.notificationCount&&(n=n.cloneIfNeeded(),n.notificationCount=s),n}function xr(n,e){if(e?.type==="m.tag"){let t=e?.content?.tags;(!t||Array.isArray(t)||typeof t!="object")&&(t=null),n=n.cloneIfNeeded(),n.tags=t}return n}function ws(n,e,t){if(e.type==="m.room.create")n=n.cloneIfNeeded(),n.lastMessageTimestamp=e.origin_server_ts;else if(e.type==="m.room.encryption"){const s=e.content?.algorithm;!n.encryption&&s===q&&(n=n.cloneIfNeeded(),n.encryption=e.content)}else if(e.type==="m.room.name"){const s=e.content?.name;s!==n.name&&(n=n.cloneIfNeeded(),n.name=s)}else if(e.type==="m.room.avatar"){const s=e.content?.url;s!==n.avatarUrl&&(n=n.cloneIfNeeded(),n.avatarUrl=s)}else if(e.type==="m.room.canonical_alias"){const s=e.content;n=n.cloneIfNeeded(),n.canonicalAlias=s.alias}else if(e.type==="m.room.member"){const s=e.content;if(s.is_direct===!0&&s.membership==="invite"&&!n.isDirectMessage){let i;e.sender===t?i=e.state_key:e.state_key===t&&(i=e.sender),i&&(n=n.cloneIfNeeded(),n.isDirectMessage=!0,n.dmUserId=i)}else s.membership==="leave"&&n.isDirectMessage&&n.dmUserId===e.state_key&&(n=n.cloneIfNeeded(),n.isDirectMessage=!1,n.dmUserId=null)}return n}function Dr(n,e,t,s,i){return e.eventType==="m.room.message"&&((!n.lastMessageTimestamp||e.timestamp>n.lastMessageTimestamp)&&(n=n.cloneIfNeeded(),n.lastMessageTimestamp=e.timestamp),!t&&e.sender!==i&&s&&(n=n.cloneIfNeeded(),n.isUnread=!0)),n}function Ur(n,e){const t=e["m.heroes"],s=e["m.joined_member_count"],i=e["m.invited_member_count"];return t&&Array.isArray(t)&&(n=n.cloneIfNeeded(),n.heroes=t),Number.isInteger(i)&&(n=n.cloneIfNeeded(),n.inviteCount=i),Number.isInteger(s)&&(n=n.cloneIfNeeded(),n.joinCount=s),n}class H{constructor(e,t){this.roomId=e?e.roomId:t,this.name=e?e.name:null,this.lastMessageTimestamp=e?e.lastMessageTimestamp:null,this.isUnread=e?e.isUnread:!1,this.encryption=e?e.encryption:null,this.membership=e?e.membership:null,this.inviteCount=e?e.inviteCount:0,this.joinCount=e?e.joinCount:0,this.heroes=e?e.heroes:null,this.canonicalAlias=e?e.canonicalAlias:null,this.hasFetchedMembers=e?e.hasFetchedMembers:!1,this.isTrackingMembers=e?e.isTrackingMembers:!1,this.avatarUrl=e?e.avatarUrl:null,this.notificationCount=e?e.notificationCount:0,this.highlightCount=e?e.highlightCount:0,this.tags=e?e.tags:null,this.isDirectMessage=e?e.isDirectMessage:!1,this.dmUserId=e?e.dmUserId:null,this.cloned=!!e}changedKeys(e){return Object.getOwnPropertyNames(this).filter(s=>s!=="cloned"&&this[s]!==e[s])}cloneIfNeeded(){return this.cloned?this:new H(this)}serialize(){return Object.entries(this).reduce((e,[t,s])=>(t!=="cloned"&&s!==null&&(e[t]=s),e),{})}applyTimelineEntries(e,t,s,i){return Tr(this,e,t,s,i)}applySyncResponse(e,t,s){return Ar(this,e,t,s)}get needsHeroes(){return!this.name&&!this.canonicalAlias&&this.heroes&&this.heroes.length>0}isNewJoin(e){return this.membership==="join"&&e.membership!=="join"}}class Fr{constructor(e){this._data=null,this.applyChanges(new H(null,e))}get data(){return this._data}writeClearUnread(e){const t=new H(this._data);return t.isUnread=!1,t.notificationCount=0,t.highlightCount=0,e.roomSummary.set(t.serialize()),t}writeHasFetchedMembers(e,t){const s=new H(this._data);return s.hasFetchedMembers=e,t.roomSummary.set(s.serialize()),s}writeIsTrackingMembers(e,t){const s=new H(this._data);return s.isTrackingMembers=e,t.roomSummary.set(s.serialize()),s}writeData(e,t){if(e!==this._data)return t.roomSummary.set(e.serialize()),e}writeArchivedData(e,t){if(e!==this._data)return t.archivedRoomSummary.set(e.serialize()),e}async writeAndApplyData(e,t){if(e===this._data)return!1;const s=await t.readWriteTxn([t.storeNames.roomSummary]);try{s.roomSummary.set(e.serialize())}catch(i){throw s.abort(),i}return await s.complete(),this.applyChanges(e),!0}applyChanges(e){this._data=e,this._data.cloned=!1}async load(e){this.applyChanges(new H(e))}}var b=(n=>(n.session="session",n.roomState="roomState",n.roomSummary="roomSummary",n.archivedRoomSummary="archivedRoomSummary",n.invites="invites",n.roomMembers="roomMembers",n.timelineEvents="timelineEvents",n.timelineRelations="timelineRelations",n.timelineFragments="timelineFragments",n.pendingEvents="pendingEvents",n.userIdentities="userIdentities",n.deviceIdentities="deviceIdentities",n.olmSessions="olmSessions",n.inboundGroupSessions="inboundGroupSessions",n.outboundGroupSessions="outboundGroupSessions",n.groupSessionDecryptions="groupSessionDecryptions",n.operations="operations",n.accountData="accountData",n.calls="calls",n))(b||{});const Me=Object.values(b);class z extends Error{constructor(e,t=null){super(e),t&&(this.errcode=t.name),this.cause=t}get name(){return"StorageError"}}const I={get minStorageKey(){return 0},get middleStorageKey(){return 2147483647},get maxStorageKey(){return 4294967295}};class S{constructor(e,t){this.fragmentId=e,this.eventIndex=t}nextFragmentKey(){return new S(this.fragmentId+1,I.middleStorageKey)}nextKeyForDirection(e){return e.isForward?this.nextKey():this.previousKey()}previousKey(){return new S(this.fragmentId,this.eventIndex-1)}nextKey(){return new S(this.fragmentId,this.eventIndex+1)}static get maxKey(){return new S(I.maxStorageKey,I.maxStorageKey)}static get minKey(){return new S(I.minStorageKey,I.minStorageKey)}static get defaultLiveKey(){return S.defaultFragmentKey(I.minStorageKey)}static defaultFragmentKey(e){return new S(e,I.middleStorageKey)}toString(){return`[${this.fragmentId}/${this.eventIndex}]`}equals(e){return this.fragmentId===e?.fragmentId&&this.eventIndex===e?.eventIndex}}const kt=Number.MAX_SAFE_INTEGER;class bs{constructor(e){this._fragmentIdComparer=e}compare(e){return this.fragmentId===e.fragmentId?this.entryIndex-e.entryIndex:this.fragmentId===kt?1:e.fragmentId===kt?-1:this._fragmentIdComparer.compare(this.fragmentId,e.fragmentId)}asEventKey(){return new S(this.fragmentId,this.entryIndex)}}const Pr="m.reaction",X="m.annotation";function Or(n,e){return{"m.relates_to":{event_id:n,key:e,rel_type:X}}}function Mt(n){return n.event_id||n["m.in_reply_to"]?.event_id}function Is(n,e){n.event_id!==void 0?n.event_id=e:n["m.in_reply_to"]&&(n["m.in_reply_to"].event_id=e)}function Nr(n){if(n.type===j)return n.redacts;{const e=ee(n);if(e)return Mt(e)}return null}function Z(n){return n?.["m.relates_to"]}function ee(n){return Z(n.content)}class Br{constructor(){this._entries=[]}get firstTimestamp(){return this._entries.reduce((e,t)=>t.isRedaction?e:Math.min(t.timestamp,e),Number.MAX_SAFE_INTEGER)}get annotationEntry(){return this._entries.find(e=>!e.isRedaction)}get redactionEntry(){return this._entries.find(e=>e.isRedaction)}get count(){return this._entries.reduce((e,t)=>e+(t.isRedaction?-1:1),0)}add(e){this._entries.push(e)}remove(e){const t=this._entries.indexOf(e);return t===-1?!1:(this._entries.splice(t,1),!0)}get willAnnotate(){const e=this._entries.reduce((t,s)=>!t||s.pendingEvent.queueIndex>t.pendingEvent.queueIndex?s:t,null);return e?!e.isRedaction:!1}get isEmpty(){return this._entries.length===0}}function Ss(n){return n.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}function Lr(n){switch(n){case"m.file":return"sent a file.";case"m.image":return"sent an image.";case"m.video":return"sent a video.";case"m.audio":return"sent an audio file."}return null}function qr(n){return n==="m.emote"?"* ":""}function jr(n,e,t,s){return{msgtype:e,body:t,format:"org.matrix.custom.html",formatted_body:s,"m.relates_to":{"m.in_reply_to":{event_id:n}}}}function $r(n,e,t){const s=Lr(n.content.msgtype),i=qr(n.content.msgtype),r=n.sender,o=n.displayName||r,a=s||n.content.formatted_body||n.content.body&&Ss(n.content.body)||"",c=`<mx-reply><blockquote>In reply to ${i}<a href="https://matrix.to/#/${r}">${o}</a><br />${a}</blockquote></mx-reply>`,h=(s||n.content.body||"").split(`
`);h[0]=`> ${i}<${r}> ${h[0]}`;const u=h.join(`
> `)+`

`+t,p=c+Ss(t);return jr(n.id,e,u,p)}class Es extends bs{constructor(e){super(e),this._pendingRedactions=null,this._pendingAnnotations=null,this._contextEntry=null,this._contextForEntries=null}get isReply(){return!!this.relation?.["m.in_reply_to"]}get isRedacting(){return!!this._pendingRedactions}get isRedacted(){return this.isRedacting}get isRedaction(){return this.eventType===j}get redactionReason(){return this._pendingRedactions?this._pendingRedactions[0].content?.reason:null}setContextEntry(e){this._contextEntry=e,e._setAsContextOf(this)}_setAsContextOf(e){this._contextForEntries||(this._contextForEntries=[]),this._contextForEntries.push(e)}get contextForEntries(){return this._contextForEntries}get contextEntry(){return this._contextEntry}addLocalRelation(e){if(e.eventType===j&&e.isRelatedToId(this.id)){if(this._pendingRedactions||(this._pendingRedactions=[]),this._pendingRedactions.push(e),this._pendingRedactions.length===1)return"isRedacted"}else{const t=e.redactingEntry||e;if(t.isRelatedToId(this.id)&&t.relation.rel_type===X&&this._addPendingAnnotation(e))return"pendingAnnotations"}}removeLocalRelation(e){if(e.eventType===j&&e.isRelatedToId(this.id)&&this._pendingRedactions){const t=this._pendingRedactions.length;if(this._pendingRedactions=this._pendingRedactions.filter(s=>s!==e),this._pendingRedactions.length===0&&(this._pendingRedactions=null,t!==0))return"isRedacted"}else{const t=e.redactingEntry||e;if(t.isRelatedToId(this.id)&&t.relation?.rel_type===X&&this._pendingAnnotations&&this._removePendingAnnotation(e))return"pendingAnnotations"}}_addPendingAnnotation(e){this._pendingAnnotations||(this._pendingAnnotations=new Map);const{key:t}=(e.redactingEntry||e).relation;if(t){let s=this._pendingAnnotations.get(t);return s||(s=new Br,this._pendingAnnotations.set(t,s)),s.add(e),!0}return!1}_removePendingAnnotation(e){const{key:t}=(e.redactingEntry||e).relation;if(t){let s=this._pendingAnnotations.get(t);return s.remove(e)&&s.isEmpty&&this._pendingAnnotations.delete(t),this._pendingAnnotations.size===0&&(this._pendingAnnotations=null),!0}return!1}async abortPendingRedaction(){if(this._pendingRedactions)for(const e of this._pendingRedactions)await e.pendingEvent.abort()}get pendingRedaction(){return this._pendingRedactions?this._pendingRedactions[0]:null}annotate(e){return Or(this.id,e)}createReplyContent(e,t){return $r(this,e,t)}isRelatedToId(e){return e&&this.relatedEventId===e}haveAnnotation(e){const t=this.annotations?.[e]?.me||!1,s=this.pendingAnnotations?.get(e),i=s?.willAnnotate||!1;return t&&(!s||i)||!t&&i}get relation(){return Z(this.content)}get pendingAnnotations(){return this._pendingAnnotations}get annotations(){return null}}class Wr extends Es{constructor({pendingEvent:e,member:t,clock:s,redactingEntry:i}){super(null),this._pendingEvent=e,this._member=t,this._timestamp=s.now()-(100-e.queueIndex),this._redactingEntry=i}get fragmentId(){return kt}get entryIndex(){return this._pendingEvent.queueIndex}get content(){return this._pendingEvent.content}get event(){return null}get eventType(){return this._pendingEvent.eventType}get stateKey(){return null}get sender(){return this._member?.userId}get displayName(){return this._member?.name}get avatarUrl(){return this._member?.avatarUrl}get timestamp(){return this._timestamp}get isPending(){return!0}get id(){return this._pendingEvent.txnId}get pendingEvent(){return this._pendingEvent}notifyUpdate(){}isRelatedToId(e){return e&&e===this._pendingEvent.relatedTxnId?!0:super.isRelatedToId(e)}get relatedEventId(){return this._pendingEvent.relatedEventId}get redactingEntry(){return this._redactingEntry}get contextEventId(){return this.isReply?this._pendingEvent.relatedEventId??this._pendingEvent.relatedTxnId:null}}const P=bt("Waiting","EncryptingAttachments","UploadingAttachments","Encrypting","Sending","Sent","Error"),Rs=["m.relates_to"];class Gr{constructor({data:e,remove:t,emitUpdate:s,attachments:i}){this._data=e,this._attachments=i,this._emitUpdate=s,this._removeFromQueueCallback=t,this._aborted=!1,this._status=P.Waiting,this._sendRequest=null,this._attachmentsTotalBytes=0,this._attachments&&(this._attachmentsTotalBytes=Object.values(this._attachments).reduce((r,o)=>r+o.size,0))}get roomId(){return this._data.roomId}get queueIndex(){return this._data.queueIndex}get eventType(){return this._data.eventType}get txnId(){return this._data.txnId}get remoteId(){return this._data.remoteId}get content(){return this._data.content}get relatedTxnId(){return this._data.relatedTxnId}get relatedEventId(){const e=Z(this.content);return e?Mt(e):this._data.relatedEventId}setRelatedEventId(e){const t=Z(this.content);t?Is(t,e):this._data.relatedEventId=e}get data(){return this._data}getAttachment(e){return this._attachments&&this._attachments[e]}get needsSending(){return!this.remoteId&&!this.aborted}get needsEncryption(){return this._data.needsEncryption&&!this.aborted}get needsUpload(){return this._data.needsUpload&&!this.aborted}get isMissingAttachments(){return this.needsUpload&&!this._attachments}setEncrypting(){this._status=P.Encrypting,this._emitUpdate("status")}get contentForEncryption(){const e=Object.assign({},this._data.content);for(const t of Rs)delete e[t];return e}_preserveContentFields(e){const t=this._data.content;for(const s of Rs)t[s]!==void 0&&(e[s]=t[s])}setEncrypted(e,t){this._preserveContentFields(t),this._data.encryptedEventType=e,this._data.encryptedContent=t,this._data.needsEncryption=!1}setError(e){this._status=P.Error,this._error=e,this._emitUpdate("status")}setWaiting(){this._status=P.Waiting,this._emitUpdate("status")}get status(){return this._status}get error(){return this._error}get hasStartedSending(){return this._status===P.Sending||this._status===P.Sent}get attachmentsTotalBytes(){return this._attachmentsTotalBytes}get attachmentsSentBytes(){return this._attachments&&Object.values(this._attachments).reduce((e,t)=>e+t.sentBytes,0)}async uploadAttachments(e,t){if(!this.needsUpload)return;if(!this._attachments)throw new Error("attachments missing");if(this.needsEncryption){this._status=P.EncryptingAttachments,this._emitUpdate("status");for(const i of Object.values(this._attachments))if(await t.wrap("encrypt",()=>(t.set("size",i.size),i.encrypt())),this.aborted)throw new L}this._status=P.UploadingAttachments,this._emitUpdate("status");const s=Object.entries(this._attachments);s.sort(([,i],[,r])=>i.size-r.size);for(const[i,r]of s)await t.wrap("upload",o=>(o.set("size",r.size),r.upload(e,()=>{this._emitUpdate("attachmentsSentBytes")},o))),r.applyToContent(i,this.content);this._data.needsUpload=!1}async abort(){if(!this._aborted){if(this._aborted=!0,this._attachments)for(const e of Object.values(this._attachments))e.abort();this._sendRequest?.abort(),await this._removeFromQueueCallback()}}get aborted(){return this._aborted}async send(e,t){this._status=P.Sending,this._emitUpdate("status");const s=this._data.encryptedEventType||this._data.eventType,i=this._data.encryptedContent||this._data.content;s===j?this._sendRequest=e.redact(this.roomId,this._data.relatedEventId,this.txnId,i,{log:t}):this._sendRequest=e.send(this.roomId,s,this.txnId,i,{log:t});const r=await this._sendRequest.response();this._sendRequest=null,this._data.remoteId=r.event_id,t.set("id",this._data.remoteId),this._status=P.Sent,this._emitUpdate("status")}dispose(){if(this._attachments)for(const e of Object.values(this._attachments))e.dispose()}}class F extends Es{constructor(e,t){super(t),this._eventEntry=e,this._decryptionError=null,this._decryptionResult=null}clone(){const e=new F(this._eventEntry,this._fragmentIdComparer);return e.updateFrom(this),e}updateFrom(e){e._decryptionResult&&(this._decryptionResult=e._decryptionResult),e._decryptionError&&(this._decryptionError=e._decryptionError),this._contextForEntries=e.contextForEntries,this._contextEntry=e.contextEntry}get data(){return this._eventEntry}get event(){return this._eventEntry.event}get fragmentId(){return this._eventEntry.fragmentId}get entryIndex(){return this._eventEntry.eventIndex}get content(){return this._decryptionResult?.event?.content||this._eventEntry.event.content}get prevContent(){return Et(this._eventEntry.event)}get eventType(){return this._decryptionResult?.event?.type||this._eventEntry.event.type}get stateKey(){return this._eventEntry.event.state_key}get sender(){return this._eventEntry.event.sender}get displayName(){return this._eventEntry.displayName}get avatarUrl(){return this._eventEntry.avatarUrl}get timestamp(){return this._eventEntry.event.origin_server_ts}get id(){return this._eventEntry.event.event_id}setDecryptionResult(e){this._decryptionResult=e}get isEncrypted(){return this._eventEntry.event.type==="m.room.encrypted"}get isDecrypted(){return!!this._decryptionResult?.event}get isVerified(){return this.isEncrypted&&this._decryptionResult?.isVerified}get isUnverified(){return this.isEncrypted&&this._decryptionResult?.isUnverified}setDecryptionError(e){this._decryptionError=e}get decryptionError(){return this._decryptionError}get relatedEventId(){return Nr(this.event)}get isRedacted(){return super.isRedacted||Rt(this._eventEntry.event)}get redactionReason(){const e=this._eventEntry.event.unsigned?.redacted_because;return e?e.content?.reason:super.redactionReason}get annotations(){return this._eventEntry.annotations}get relation(){const e=this._eventEntry.event.content;return e&&Z(e)||Z(this.content)}get contextEventId(){return this.isReply?this.relatedEventId:null}}function Ct(n,e,t){return{fragmentId:n.fragmentId,eventIndex:n.eventIndex,roomId:e,event:t}}function Ce(n,e,t){t.isForward?n.push(e):n.unshift(e)}function Vr(n,e,t){return t.isForward?n.concat(e):e.concat(n)}const D="m.room.member";class v{constructor(e){this._data=e}static fromUserId(e,t,s){return new v({roomId:e,userId:t,membership:s})}static fromMemberEvent(e,t){const s=t?.state_key;if(typeof s!="string")return;const i=t.content,r=Et(t),o=i?.membership,a=i?.displayname||r?.displayname,c=i?.avatar_url||r?.avatar_url;return this._validateAndCreateMember(e,s,o,a,c)}static fromReplacingMemberEvent(e,t){const s=t&&t.state_key;if(typeof s!="string")return;const i=Et(t);return this._validateAndCreateMember(e,s,i?.membership,i?.displayname,i?.avatar_url)}static _validateAndCreateMember(e,t,s,i,r){if(typeof s=="string")return new v({roomId:e,userId:t,membership:s,avatarUrl:r,displayName:i})}get data(){return this._data}get membership(){return this._data.membership}get displayName(){return this._data.displayName}get name(){return this._data.displayName||this._data.userId}get avatarUrl(){return this._data.avatarUrl}get roomId(){return this._data.roomId}get userId(){return this._data.userId}serialize(){return this._data}equals(e){const t=this._data,s=e._data;return t.roomId===s.roomId&&t.userId===s.userId&&t.membership===s.membership&&t.displayName===s.displayName&&t.avatarUrl===s.avatarUrl}}class ks{constructor(e,t){this.member=e,this.previousMembership=t}get roomId(){return this.member.roomId}get userId(){return this.member.userId}get membership(){return this.member.membership}get wasInvited(){return this.previousMembership==="invite"&&this.membership!=="invite"}get hasLeft(){return this.previousMembership==="join"&&this.membership!=="join"}get hasJoined(){return this.previousMembership!=="join"&&this.membership==="join"}}function Tt(n){return typeof n=="number"}const Hr=["event_id","type","room_id","user_id","sender","state_key","prev_state","content","unsigned","origin_server_ts"].reduce(function(n,e){return n[e]=1,n},{}),zr={"m.room.member":{membership:1},"m.room.create":{creator:1},"m.room.join_rules":{join_rule:1},"m.room.power_levels":{ban:1,events:1,events_default:1,kick:1,redact:1,state_default:1,users:1,users_default:1},"m.room.aliases":{aliases:1}};function Qr(n,e){for(const i of Object.keys(e))Hr[i]||delete e[i];const{content:t}=e,s=zr[e.type];for(const i of Object.keys(t))s?.[i]||delete t[i];e.unsigned=e.unsigned||{},e.unsigned.redacted_because=n}function Jr(n,e){const t=[];for(;Tt(n.previousId);){const s=e.get(n.previousId);if(!s)break;if(s.nextId!==n.id)throw new Error(`Previous fragment ${s.id} doesn't point back to ${n.id}`);e.delete(n.previousId),t.unshift(s),n=s}return t}function Yr(n,e){const t=[];for(;Tt(n.nextId);){const s=e.get(n.nextId);if(!s)break;if(s.previousId!==n.id)throw new Error(`Next fragment ${s.id} doesn't point back to ${n.id}`);e.delete(n.nextId),t.push(s),n=s}return t}function Xr(n){const e=new Map;for(let s of n)e.set(s.id,s);const t=[];for(;e.size;){const s=e.values().next().value;e.delete(s.id);const i=Jr(s,e),r=Yr(s,e),o=i.concat(s,r);t.push(o)}return t.map(s=>new Zr(s))}class At{constructor(e,t,s){this.id=e,this.previousId=t,this.nextId=s}}class Zr{constructor(e){this._idToSortIndex=new Map,e.forEach((t,s)=>{this._idToSortIndex.set(t.id,s)})}compare(e,t){const s=this._idToSortIndex.get(e);if(s===void 0)throw new Error(`first id ${e} isn't part of this island`);const i=this._idToSortIndex.get(t);if(i===void 0)throw new Error(`second id ${t} isn't part of this island`);return s-i}get fragmentIds(){return this._idToSortIndex.keys()}}class Ms extends Error{get name(){return"CompareError"}}class en{constructor(e){this._fragmentsById=e.reduce((t,s)=>(t.set(s.id,s),t),new Map),this.rebuild(e)}_getIsland(e){const t=this._idToIsland.get(e);if(t===void 0)throw new Ms(`Unknown fragment id ${e}`);return t}compare(e,t){if(e===t)return 0;const s=this._getIsland(e),i=this._getIsland(t);if(s!==i)throw new Ms(`${e} and ${t} are on different islands, can't tell order`);return s.compare(e,t)}rebuild(e){const t=Xr(e);this._idToIsland=new Map;for(let s of t)for(let i of s.fragmentIds)this._idToIsland.set(i,s)}add(e){const t=new At(e.id,e.previousId,e.nextId);this._fragmentsById.set(e.id,t),this.rebuild(this._fragmentsById.values())}append(e,t){const s=new At(e,t,null),i=this._fragmentsById.get(t);i&&(i.nextId=e),this._fragmentsById.set(e,s),this.rebuild(this._fragmentsById.values())}prepend(e,t){const s=new At(e,null,t),i=this._fragmentsById.get(t);i&&(i.previousId=e),this._fragmentsById.set(e,s),this.rebuild(this._fragmentsById.values())}}function tn(n){return"objectStore"in n?`${n.objectStore.name}.${n.name}`:n.name}function sn(n){return"objectStore"in n?n.objectStore?.transaction?.db?.name:n.transaction?.db?.name}class Cs extends z{constructor(e,t,s=null){const i=t&&"source"in t?t.source:t,r=i?tn(i):"",o=i?sn(i):"";let a=`${e} on ${o}.${r}`;s&&(a+=": ",typeof s.name=="string"&&(a+=`(name: ${s.name}) `),typeof s.code=="number"&&(a+=`(code: ${s.code}) `)),s&&(a+=s.message),super(a,s),this.storeName=r,this.databaseName=o}}class Kt extends Cs{constructor(e){const t=e.target,s=t.source,i=t.error;super("IDBRequest failed",s,i),this.errorEvent=e}preventTransactionAbort(){this.errorEvent.preventDefault()}}class Q extends Cs{constructor(e,t,s,i){super(`${e}(${i.map(r=>JSON.stringify(r)).join(", ")}) failed`,t,s)}}const Ts={done:!0},te={done:!1};function Qe(n){const e=n.toString(16);return"0".repeat(8-e.length)+e}function xt(n){return parseInt(n,16)}function As(n,e,t,s=window.indexedDB){const i=s.open(n,t);return i.onupgradeneeded=async r=>{const o=r.target,a=o.result,c=o.transaction,d=r.oldVersion;try{await e(a,c,d,t)}catch{try{c.abort()}catch{}}},K(i)}function K(n){return new Promise((e,t)=>{n.addEventListener("success",s=>{e(s.target.result)}),n.addEventListener("error",s=>{const i=new Kt(s);t(i)})})}function Dt(n){return new Promise((e,t)=>{n.addEventListener("complete",()=>{e()}),n.addEventListener("abort",s=>{t(new L)})})}function C(n,e){return new Promise((t,s)=>{n.onerror=i=>{s(new Kt(i))},n.onsuccess=i=>{const r=i.target.result;if(!r){t(!1);return}const o=e(r.value,r.key,r),a=o?.done,c=o?.jumpTo;a?t(!0):c?r.continue(c):r.continue()}}).catch(t=>{throw new z("iterateCursor failed",t)})}class Ks{constructor(e,t){this._target=e,this._transaction=t}get idbFactory(){return this._transaction.idbFactory}get IDBKeyRange(){return this._transaction.IDBKeyRange}get databaseName(){return this._transaction.databaseName}_openCursor(e,t){return e&&t?this._target.openCursor(e,t):e?this._target.openCursor(e):t?this._target.openCursor(null,t):this._target.openCursor()}supports(e){return this._target.supports(e)}count(e){return K(this._target.count(e))}get(e){return K(this._target.get(e))}getKey(e){return this._target.supports("getKey")?K(this._target.getKey(e)):K(this._target.get(e)).then(t=>{if(t){let s=this._target.keyPath;return typeof s=="string"&&(s=[s]),s.reduce((i,r)=>i[r],t)}})}reduce(e,t,s){return this._reduce(e,t,s,"next")}reduceReverse(e,t,s){return this._reduce(e,t,s,"prev")}selectLimit(e,t){return this._selectLimit(e,t,"next")}selectLimitReverse(e,t){return this._selectLimit(e,t,"prev")}selectWhile(e,t){return this._selectWhile(e,t,"next")}selectWhileReverse(e,t){return this._selectWhile(e,t,"prev")}async selectAll(e,t){const s=this._openCursor(e,t),i=[];return await C(s,r=>(i.push(r),te)),i}selectFirst(e){return this._find(e,()=>!0,"next")}selectLast(e){return this._find(e,()=>!0,"prev")}find(e,t){return this._find(e,t,"next")}findReverse(e,t){return this._find(e,t,"prev")}async findMaxKey(e){const t=this._target.openKeyCursor(e,"prev");let s;return await C(t,(i,r)=>(s=r,Ts)),s}async iterateValues(e,t){const s=this._target.openCursor(e,"next");await C(s,(i,r,o)=>({done:t(i,r,o)}))}async iterateKeys(e,t){const s=this._target.openKeyCursor(e,"next");await C(s,(i,r,o)=>({done:t(r,o)}))}async findExistingKeys(e,t,s){const i=(l,u)=>t?-this.idbFactory.cmp(l,u):this.idbFactory.cmp(l,u),r=e.slice().sort(i),o=r[0],a=r[r.length-1],c=t?"prev":"next",d=this._target.openKeyCursor(this.IDBKeyRange.bound(o,a),c);let h=0;await C(d,(l,u,p)=>{for(;h<r.length&&i(r[h],u)<0;)h+=1;let m=!1;if(r[h]===u){const _=p.primaryKey;m=s(u,_),h+=1}return m||h>=r.length?Ts:{done:!1,jumpTo:r[h]}})}_reduce(e,t,s,i){let r=s;const o=this._openCursor(e,i);return C(o,a=>(r=t(r,a),te))}_selectLimit(e,t,s){return this._selectUntil(e,i=>i.length===t,s)}async _selectUntil(e,t,s){const i=this._openCursor(e,s),r=[];return await C(i,o=>(r.push(o),{done:t(r,o)})),r}async _selectWhile(e,t,s){const i=this._openCursor(e,s),r=[];return await C(i,o=>{const a=t(o);return a&&r.push(o),{done:!a}}),r}async iterateWhile(e,t){const s=this._openCursor(e,"next");await C(s,i=>({done:!t(i)}))}async _find(e,t,s){const i=this._openCursor(e,s);let r;if(await C(i,a=>{const c=t(a);return c&&(r=a),{done:c}}))return r}}const se=!1;function ie(n,e,t){const s=t?.name,i=t?.transaction?.db?.name;console.info(`${i}.${s}.${n}(${e.map(r=>JSON.stringify(r)).join(", ")})`)}class xs{constructor(e){this._qt=e}get keyPath(){return this._qtStore.keyPath}get _qtStore(){return"objectStore"in this._qt?this._qt.objectStore:this._qt}supports(e){return!!this._qt[e]}openKeyCursor(e,t){try{return this._qt.openKeyCursor?(se&&ie("openKeyCursor",[e,t],this._qt),this._qt.openKeyCursor(e,t)):(se&&ie("openCursor",[e,t],this._qt),this.openCursor(e,t))}catch(s){throw new Q("openKeyCursor",this._qt,s,[e,t])}}openCursor(e,t){try{return se&&ie("openCursor",[],this._qt),this._qt.openCursor(e,t)}catch(s){throw new Q("openCursor",this._qt,s,[e,t])}}put(e,t){try{return se&&ie("put",[e,t],this._qt),this._qtStore.put(e,t)}catch(s){throw new Q("put",this._qt,s,[e,t])}}add(e,t){try{return se&&ie("add",[e,t],this._qt),this._qtStore.add(e,t)}catch(s){throw new Q("add",this._qt,s,[e,t])}}get(e){try{return se&&ie("get",[e],this._qt),this._qt.get(e)}catch(t){throw new Q("get",this._qt,t,[e])}}getKey(e){try{return se&&ie("getKey",[e],this._qt),this._qt.getKey(e)}catch(t){throw new Q("getKey",this._qt,t,[e])}}delete(e){try{return se&&ie("delete",[e],this._qt),this._qtStore.delete(e)}catch(t){throw new Q("delete",this._qt,t,[e])}}count(e){try{return this._qt.count(e)}catch(t){throw new Q("count",this._qt,t,[e])}}index(e){try{return this._qtStore.index(e)}catch(t){throw new Q("index",this._qt,t,[e])}}get indexNames(){return Array.from(this._qtStore.indexNames)}}class Ds extends Ks{constructor(e,t){super(new xs(e),t)}get _idbStore(){return this._target}index(e){return new Ks(new xs(this._idbStore.index(e)),this._transaction)}put(e,t){const s=this._idbStore.put(e);this._prepareErrorLog(s,t,"put",void 0,e)}add(e,t){const s=this._idbStore.add(e);this._prepareErrorLog(s,t,"add",void 0,e)}async tryAdd(e,t){try{return await K(this._idbStore.add(e)),!0}catch(s){if(s instanceof Kt)return t.log({l:"could not write",id:this._getKeys(e),e:s},t.level.Warn),s.preventTransactionAbort(),!1;throw s}}delete(e,t){const s=this._idbStore.delete(e);this._prepareErrorLog(s,t,"delete",e,void 0)}_prepareErrorLog(e,t,s,i,r){t&&t.ensureRefId(),K(e).catch(o=>{let a;r?a=this._getKeys(r):i&&(a=[i]),this._transaction.addWriteError(o,t,s,a)})}_getKeys(e){const t=[],{keyPath:s}=this._idbStore;try{t.push(this._readKeyPath(e,s))}catch{console.warn("could not read keyPath",s)}for(const i of this._idbStore.indexNames)try{const r=this._idbStore.index(i);t.push(this._readKeyPath(e,r.keyPath))}catch{console.warn("could not read index",i)}return t}_readKeyPath(e,t){if(Array.isArray(t)){let s=e;for(const i of t)if(typeof s=="object")s=s[i];else break;return s}else return e[t]}}function rn(n){return JSON.stringify(Us(n))}function nn(n){return Fs(JSON.parse(n))}function Us(n){if(typeof n=="object"&&n!==null&&!Array.isArray(n)){if(n.byteLength)return{_type:n.constructor.name,value:Array.from(n)};let e={};for(const t in n)n.hasOwnProperty(t)&&(e[t]=Us(n[t]));return e}else return n}function Fs(n){if(typeof n=="object"&&n!==null&&!Array.isArray(n)){if(typeof n._type=="string")switch(n._type){case"Int8Array":return Int8Array.from(n.value);case"Uint8Array":return Uint8Array.from(n.value);case"Uint8ClampedArray":return Uint8ClampedArray.from(n.value);case"Int16Array":return Int16Array.from(n.value);case"Uint16Array":return Uint16Array.from(n.value);case"Int32Array":return Int32Array.from(n.value);case"Uint32Array":return Uint32Array.from(n.value);case"Float32Array":return Float32Array.from(n.value);case"Float64Array":return Float64Array.from(n.value);case"BigInt64Array":return BigInt64Array.from(n.value);case"BigUint64Array":return BigUint64Array.from(n.value);default:return n.value}let e={};for(const t in n)n.hasOwnProperty(t)&&(e[t]=Fs(n[t]));return e}else return n}function Ps(n){return`${n}.session.`}function on(n,e){const t=[];for(let s=0;s<n.length;s++){const i=n.key(s);i?.startsWith(Ps(e))&&t.push(i)}for(const s of t)n.removeItem(s)}class Ut{constructor(e,t){this._sessionStore=e,this._localStorage=t}get _localStorageKeyPrefix(){return Ps(this._sessionStore.databaseName)}async get(e){const t=await this._sessionStore.get(e);if(t)return t.value}_writeKeyToLocalStorage(e,t){try{const s=this._localStorageKeyPrefix+e,i=rn(t);this._localStorage.setItem(s,i)}catch(s){console.error("could not write to localStorage",s)}}writeE2EEIdentityToLocalStorage(){this._sessionStore.iterateValues(void 0,(e,t)=>(t.startsWith(U)&&this._writeKeyToLocalStorage(t,e.value),!1))}async tryRestoreE2EEIdentityFromLocalStorage(e){let t=!1;const s=this._localStorageKeyPrefix,i=s+U;for(let r=0;r<this._localStorage.length;r+=1){const o=this._localStorage.key(r);if(o.startsWith(i)){const a=nn(this._localStorage.getItem(o)),c=o.substr(s.length),d=await this._sessionStore.getKey(c)===c;e.set(c,!d),d||(this._sessionStore.put({key:c,value:a}),t=!0)}}return t}set(e,t){e.startsWith(U)&&this._writeKeyToLocalStorage(e,t),this._sessionStore.put({key:e,value:t})}add(e,t){e.startsWith(U)&&this._writeKeyToLocalStorage(e,t),this._sessionStore.add({key:e,value:t})}remove(e){e.startsWith(U)&&this._localStorage.removeItem(this._localStorageKeyPrefix+e),this._sessionStore.delete(e)}}class Os{constructor(e){this._summaryStore=e}getAll(){return this._summaryStore.selectAll()}set(e){this._summaryStore.put(e)}get(e){return this._summaryStore.get(e)}async has(e){const t=await this._summaryStore.getKey(e);return e===t}remove(e){this._summaryStore.delete(e)}}class an{constructor(e){this._inviteStore=e}getAll(){return this._inviteStore.selectAll()}set(e){this._inviteStore.put(e)}remove(e){this._inviteStore.delete(e)}}var O=(n=>(n[n.All=1]="All",n[n.Debug=2]="Debug",n[n.Detail=3]="Detail",n[n.Info=4]="Info",n[n.Warn=5]="Warn",n[n.Error=6]="Error",n[n.Fatal=7]="Fatal",n[n.Off=8]="Off",n))(O||{});class Ft{constructor(e){this._parentFilter=e}filter(e,t){return!(this._parentFilter&&!this._parentFilter.filter(e,t)||this._min!==void 0&&!Array.isArray(t)&&e.logLevel<this._min)}minLevel(e){return this._min=e,this}}function Je(){}class cn{constructor(){this.item=new dn(this)}log(e){return this.item}addReporter(){}get reporters(){return[]}getOpenRootItems(){return[]}forceFinish(){}child(e){return this.item}run(e,t){return t(this.item)}wrapOrRun(e,t,s){return e?e.wrap(t,s):this.run(t,s)}runDetached(e,t){return new Promise(s=>s(t(this.item))).then(Je,Je),this.item}get level(){return O}}class dn{constructor(e){this.logger=e}wrap(e,t){return this.run(t)}run(e){return e(this)}log(e){return this}set(e){return this}runDetached(e,t){return new Promise(s=>s(t(this))).then(Je,Je),this}wrapDetached(e,t){return this.refDetached()}refDetached(){}ensureRefId(){}get level(){return O}get duration(){return 0}catch(e){return e}child(){return this}finish(){}forceFinish(){}serialize(){}}const hn=new cn;function N(n,e,t){return`${n}|${Qe(e)}|${Qe(t)}`}function ln(n){const[e,t,s]=n.split("|");return{roomId:e,eventKey:new S(xt(t),xt(s))}}function Ye(n,e){return`${n}|${e}`}function Ns(n){const[e,t]=n.split("|");return{roomId:e,eventId:t}}class Xe{constructor(e,t,s,i,r=!1,o=!1){this._IDBKeyRange=e,this._only=t,this._lower=s,this._upper=i,this._lowerOpen=r,this._upperOpen=o}asIDBKeyRange(e){try{if(this._only)return this._IDBKeyRange.only(N(e,this._only.fragmentId,this._only.eventIndex));if(this._lower&&!this._upper)return this._IDBKeyRange.bound(N(e,this._lower.fragmentId,this._lower.eventIndex),N(e,this._lower.fragmentId,I.maxStorageKey),this._lowerOpen,!1);if(!this._lower&&this._upper)return this._IDBKeyRange.bound(N(e,this._upper.fragmentId,I.minStorageKey),N(e,this._upper.fragmentId,this._upper.eventIndex),!1,this._upperOpen);if(this._lower&&this._upper)return this._IDBKeyRange.bound(N(e,this._lower.fragmentId,this._lower.eventIndex),N(e,this._upper.fragmentId,this._upper.eventIndex),this._lowerOpen,this._upperOpen)}catch(t){throw new z("IDBKeyRange failed with data: "+JSON.stringify(this),t)}}}class un{constructor(e){this._timelineStore=e}onlyRange(e){return new Xe(this._timelineStore.IDBKeyRange,e)}upperBoundRange(e,t=!1){return new Xe(this._timelineStore.IDBKeyRange,void 0,void 0,e,void 0,t)}lowerBoundRange(e,t=!1){return new Xe(this._timelineStore.IDBKeyRange,void 0,e,void 0,t)}boundRange(e,t,s=!1,i=!1){return new Xe(this._timelineStore.IDBKeyRange,void 0,e,t,s,i)}async lastEvents(e,t,s){const i=S.maxKey;return i.fragmentId=t,this.eventsBefore(e,i,s)}async firstEvents(e,t,s){const i=S.minKey;return i.fragmentId=t,this.eventsAfter(e,i,s)}eventsAfter(e,t,s){const i=this.lowerBoundRange(t,!0).asIDBKeyRange(e);return this._timelineStore.selectLimit(i,s)}async eventsBefore(e,t,s){const i=this.upperBoundRange(t,!0).asIDBKeyRange(e),r=await this._timelineStore.selectLimitReverse(i,s);return r.reverse(),r}async getEventKeysForIds(e,t){const s=this._timelineStore.index("byEventId"),i=t.map(o=>Ye(e,o)),r=new Map;return await s.findExistingKeys(i,!1,(o,a)=>{const{eventId:c}=Ns(o),{eventKey:d}=ln(a);return r.set(c,d),!1}),r}async findFirstOccurringEventId(e,t){const s=this._timelineStore.index("byEventId"),i=t.map(c=>Ye(e,c)),r=new Array(i.length);let o;function a(){for(let c=0;c<r.length;++c){if(r[c]===void 0)return;if(r[c]===!0)return i[c]}}return await s.findExistingKeys(i,!1,(c,d)=>{const h=i.indexOf(c);return r[h]=d,o=a(),!!o}),o&&Ns(o).eventId}tryInsert(e,t){return e.key=N(e.roomId,e.fragmentId,e.eventIndex),e.eventIdKey=Ye(e.roomId,e.event.event_id),this._timelineStore.tryAdd(e,t)}update(e){this._timelineStore.put(e)}get(e,t){return this._timelineStore.get(N(e,t.fragmentId,t.eventIndex))}getByEventId(e,t){return this._timelineStore.index("byEventId").get(Ye(e,t))}removeAllForRoom(e){const t=N(e,I.minStorageKey,I.minStorageKey),s=N(e,I.maxStorageKey,I.maxStorageKey),i=this._timelineStore.IDBKeyRange.bound(t,s);this._timelineStore.delete(i)}}const k="\0",E="\u{10FFFF}";function $(n,e,t,s){return`${n}|${e}|${t}|${s}`}function Bs(n){const[e,t,s,i]=n.split("|");return{roomId:e,targetEventId:t,relType:s,sourceEventId:i}}class mn{constructor(e){this._store=e}add(e,t,s,i){this._store.add({key:$(e,t,s,i)})}remove(e,t,s,i){this._store.delete($(e,t,s,i))}removeAllForTarget(e,t){const s=this._store.IDBKeyRange.bound($(e,t,k,k),$(e,t,E,E),!0,!0);this._store.delete(s)}removeAllForRoom(e){const t=this._store.IDBKeyRange.bound($(e,k,k,k),$(e,E,E,E),!0,!0);this._store.delete(t)}async getForTargetAndType(e,t,s){const i=this._store.IDBKeyRange.bound($(e,t,s,k),$(e,t,s,E),!0,!0);return(await this._store.selectAll(i)).map(o=>Bs(o.key))}async getAllForTarget(e,t){const s=this._store.IDBKeyRange.bound($(e,t,k,k),$(e,t,E,E),!0,!0);return(await this._store.selectAll(s)).map(r=>Bs(r.key))}}function Ze(n,e,t){return`${n}|${e}|${t}`}class pn{constructor(e){this._roomStateStore=e}get(e,t,s){const i=Ze(e,t,s);return this._roomStateStore.get(i)}getAllForType(e,t){const s=this._roomStateStore.IDBKeyRange.bound(Ze(e,t,""),Ze(e,t,E),!1,!0);return this._roomStateStore.selectAll(s)}set(e,t){const s=Ze(e,t.type,t.state_key),i={roomId:e,event:t,key:s};this._roomStateStore.put(i)}removeAllForRoom(e){const t=this._roomStateStore.IDBKeyRange.bound(e,`${e}|${E}`,!0,!0);this._roomStateStore.delete(t)}}function et(n,e){return`${n}|${e}`}function _n(n){const[e,t]=n.split("|");return{roomId:e,userId:t}}class Ls{constructor(e){this._roomMembersStore=e}get(e,t){return this._roomMembersStore.get(et(e,t))}set(e){e.key=et(e.roomId,e.userId),this._roomMembersStore.put(e)}getAll(e){const t=this._roomMembersStore.IDBKeyRange.lowerBound(et(e,""));return this._roomMembersStore.selectWhile(t,s=>s.roomId===e)}async getAllUserIds(e){const t=[],s=this._roomMembersStore.IDBKeyRange.lowerBound(et(e,""));return await this._roomMembersStore.iterateKeys(s,i=>{const r=_n(i);return r.roomId===e?(t.push(r.userId),!1):!0}),t}removeAllForRoom(e){const t=this._roomMembersStore.IDBKeyRange.bound(e,`${e}|${E}`,!0,!0);this._roomMembersStore.delete(t)}}function tt(n,e){return`${n}|${Qe(e)}`}class fn{constructor(e){this._store=e}_allRange(e){try{return this._store.IDBKeyRange.bound(tt(e,I.minStorageKey),tt(e,I.maxStorageKey))}catch(t){throw new z(`error from IDBKeyRange with roomId ${e}`,t)}}all(e){return this._store.selectAll(this._allRange(e))}liveFragment(e){return this._store.findReverse(this._allRange(e),t=>typeof t.nextId!="number"&&typeof t.nextToken!="string")}add(e){e.key=tt(e.roomId,e.id),this._store.add(e)}update(e){this._store.put(e)}get(e,t){return this._store.get(tt(e,t))}removeAllForRoom(e){this._store.delete(this._allRange(e))}}function ce(n,e){return`${n}|${Qe(e)}`}function yn(n){const[e,t]=n.split("|"),s=xt(t);return{roomId:e,queueIndex:s}}class gn{constructor(e){this._eventStore=e}async getMaxQueueIndex(e){const t=this._eventStore.IDBKeyRange.bound(ce(e,I.minStorageKey),ce(e,I.maxStorageKey),!1,!1),s=await this._eventStore.findMaxKey(t);if(s)return yn(s).queueIndex}remove(e,t){const s=this._eventStore.IDBKeyRange.only(ce(e,t));this._eventStore.delete(s)}async exists(e,t){const s=this._eventStore.IDBKeyRange.only(ce(e,t));return!!await this._eventStore.getKey(s)}add(e){e.key=ce(e.roomId,e.queueIndex),this._eventStore.add(e)}update(e){this._eventStore.put(e)}getAll(){return this._eventStore.selectAll()}removeAllForRoom(e){const t=ce(e,I.minStorageKey),s=ce(e,I.maxStorageKey),i=this._eventStore.IDBKeyRange.bound(t,s);this._eventStore.delete(i)}}class vn{constructor(e){this._store=e}get(e){return this._store.get(e)}set(e){this._store.put(e)}remove(e){this._store.delete(e)}}function de(n,e){return`${n}|${e}`}function wn(n){const[e,t]=n.split("|");return{userId:e,deviceId:t}}class bn{constructor(e){this._store=e}getAllForUserId(e){const t=this._store.IDBKeyRange.lowerBound(de(e,""));return this._store.selectWhile(t,s=>s.userId===e)}async getAllDeviceIds(e){const t=[],s=this._store.IDBKeyRange.lowerBound(de(e,""));return await this._store.iterateKeys(s,i=>{const r=wn(i);return r.userId===e?(t.push(r.deviceId),!1):!0}),t}get(e,t){return this._store.get(de(e,t))}set(e){e.key=de(e.userId,e.deviceId),this._store.put(e)}getByCurve25519Key(e){return this._store.index("byCurve25519Key").get(e)}remove(e,t){this._store.delete(de(e,t))}removeAllForUser(e){const t=this._store.IDBKeyRange.bound(de(e,k),de(e,E),!0,!0);this._store.delete(t)}}function Te(n,e){return`${n}|${e}`}function In(n){const[e,t]=n.split("|");return{senderKey:e,sessionId:t}}class Sn{constructor(e){this._store=e}async getSessionIds(e){const t=[],s=this._store.IDBKeyRange.lowerBound(Te(e,""));return await this._store.iterateKeys(s,i=>{const r=In(i);return r.senderKey===e?(t.push(r.sessionId),!1):!0}),t}getAll(e){const t=this._store.IDBKeyRange.lowerBound(Te(e,""));return this._store.selectWhile(t,s=>s.senderKey===e)}get(e,t){return this._store.get(Te(e,t))}set(e){e.key=Te(e.senderKey,e.sessionId),this._store.put(e)}remove(e,t){this._store.delete(Te(e,t))}}var st=(n=>(n[n.NotBackedUp=0]="NotBackedUp",n[n.BackedUp=1]="BackedUp",n))(st||{}),Ae=(n=>(n[n.DeviceMessage=1]="DeviceMessage",n[n.Backup=2]="Backup",n[n.Outbound=3]="Outbound",n))(Ae||{});function ve(n,e,t){return`${n}|${e}|${t}`}class En{constructor(e){this._store=e}async has(e,t,s){const i=ve(e,t,s),r=await this._store.getKey(i);return i===r}get(e,t,s){return this._store.get(ve(e,t,s))}set(e){const t=e;t.key=ve(e.roomId,e.senderKey,e.sessionId),this._store.put(t)}removeAllForRoom(e){const t=this._store.IDBKeyRange.bound(ve(e,k,k),ve(e,E,E));this._store.delete(t)}countNonBackedUpSessions(){return this._store.index("byBackup").count(this._store.IDBKeyRange.only(0))}getFirstNonBackedUpSessions(e){return this._store.index("byBackup").selectLimit(this._store.IDBKeyRange.only(0),e)}async markAsBackedUp(e,t,s){const i=await this._store.get(ve(e,t,s));i&&(i.backup=1,this._store.put(i))}async markAllAsNotBackedUp(){const e=this._store.IDBKeyRange.only(1);let t=0;return await this._store.index("byBackup").iterateValues(e,(s,i,r)=>(s.backup=0,r.update(s),t+=1,!1)),t}}class Rn{constructor(e){this._store=e}remove(e){this._store.delete(e)}get(e){return this._store.get(e)}set(e){this._store.put(e)}}function it(n,e,t){return`${n}|${e}|${t}`}class kn{constructor(e){this._store=e}get(e,t,s){return this._store.get(it(e,t,s))}set(e,t,s,i){i.key=it(e,t,s),this._store.put(i)}removeAllForRoom(e){const t=this._store.IDBKeyRange.bound(it(e,k,k),it(e,E,E));this._store.delete(t)}}function Ke(n,e){return`${n}|${e}`}class Mn{constructor(e){this._store=e}getAll(){return this._store.selectAll()}async getAllByTypeAndScope(e,t){const s=Ke(t,e),i=[];return await this._store.index("byScopeAndType").iterateWhile(s,r=>r.scopeTypeKey!==s?!1:(i.push(r),!0)),i}add(e){e.scopeTypeKey=Ke(e.scope,e.type),this._store.add(e)}update(e){this._store.put(e)}remove(e){this._store.delete(e)}async removeAllForScope(e){const t=this._store.IDBKeyRange.bound(Ke(e,k),Ke(e,E));await this._store.index("byScopeAndType").iterateValues(t,(i,r,o)=>(o.delete(),!0))}}class Cn{constructor(e){this._store=e}async get(e){return await this._store.get(e)}set(e){this._store.put(e)}}function we(n,e,t){return`${n}|${e}|${t}`}function qs(n){const[e,t,s]=n.key.split("|");return{intent:e,roomId:t,callId:s,timestamp:n.timestamp}}class Tn{constructor(e){this._callStore=e}async getByIntent(e){const t=this._callStore.IDBKeyRange.bound(we(e,k,k),we(e,E,E),!0,!0);return(await this._callStore.selectAll(t)).map(i=>qs(i))}async getByIntentAndRoom(e,t){const s=this._callStore.IDBKeyRange.bound(we(e,t,k),we(e,t,E),!0,!0);return(await this._callStore.selectAll(s)).map(r=>qs(r))}add(e){const t={key:we(e.intent,e.roomId,e.callId),timestamp:e.timestamp};this._callStore.add(t)}remove(e,t,s){this._callStore.delete(we(e,t,s))}}class An{constructor(e,t,s,i){this.error=e,this.refItem=t,this.operationName=s,this.keys=i}}class js{constructor(e,t,s){this._txn=e,this._allowedStoreNames=t,this._stores={},this._storage=s,this._writeErrors=[]}get idbFactory(){return this._storage.idbFactory}get IDBKeyRange(){return this._storage.IDBKeyRange}get databaseName(){return this._storage.databaseName}get logger(){return this._storage.logger}_idbStore(e){if(!this._allowedStoreNames.includes(e))throw new z(`Invalid store for transaction: ${e}, only ${this._allowedStoreNames.join(", ")} are allowed.`);return new Ds(this._txn.objectStore(e),this)}_store(e,t){if(!this._stores[e]){const s=this._idbStore(e);this._stores[e]=t(s)}return this._stores[e]}get session(){return this._store(b.session,e=>new Ut(e,this._storage.localStorage))}get roomSummary(){return this._store(b.roomSummary,e=>new Os(e))}get archivedRoomSummary(){return this._store(b.archivedRoomSummary,e=>new Os(e))}get invites(){return this._store(b.invites,e=>new an(e))}get timelineFragments(){return this._store(b.timelineFragments,e=>new fn(e))}get timelineEvents(){return this._store(b.timelineEvents,e=>new un(e))}get timelineRelations(){return this._store(b.timelineRelations,e=>new mn(e))}get roomState(){return this._store(b.roomState,e=>new pn(e))}get roomMembers(){return this._store(b.roomMembers,e=>new Ls(e))}get pendingEvents(){return this._store(b.pendingEvents,e=>new gn(e))}get userIdentities(){return this._store(b.userIdentities,e=>new vn(e))}get deviceIdentities(){return this._store(b.deviceIdentities,e=>new bn(e))}get olmSessions(){return this._store(b.olmSessions,e=>new Sn(e))}get inboundGroupSessions(){return this._store(b.inboundGroupSessions,e=>new En(e))}get outboundGroupSessions(){return this._store(b.outboundGroupSessions,e=>new Rn(e))}get groupSessionDecryptions(){return this._store(b.groupSessionDecryptions,e=>new kn(e))}get operations(){return this._store(b.operations,e=>new Mn(e))}get accountData(){return this._store(b.accountData,e=>new Cn(e))}get calls(){return this._store(b.calls,e=>new Tn(e))}async complete(e){try{await Dt(this._txn)}catch(t){throw this._writeErrors.length?(this._logWriteErrors(e),this._writeErrors[0].error):t}}getCause(e){return e instanceof z&&e.errcode==="AbortError"&&this._writeErrors.length?this._writeErrors[0].error:e}abort(e){try{this._txn.abort()}catch{e?.set("couldNotAbortTxn",!0)}this._writeErrors.length&&this._logWriteErrors(e)}addWriteError(e,t,s,i){(e.errcode!=="AbortError"||this._writeErrors.length===0)&&this._writeErrors.push(new An(e,t,s,i))}_logWriteErrors(e){const t=i=>{e||i.set("allowedStoreNames",this._allowedStoreNames);for(const r of this._writeErrors)i.wrap({l:r.operationName,id:r.keys},o=>{r.refItem&&o.refDetached(r.refItem),o.catch(r.error)})},s=`${this._writeErrors.length} storage write operation(s) failed`;e?e.wrap(s,t):this.logger.run(s,t)}}const $s="782rh281re38-boguskey";class Kn{constructor(e,t,s,i,r,o){this._db=e,this.idbFactory=t,this.IDBKeyRange=s,this._hasWebkitEarlyCloseTxnBug=i,this.storeNames=b,this.localStorage=r,this.logger=o}_validateStoreNames(e){const t=e.findIndex(s=>!Me.includes(s));if(t!==-1)throw new z(`Tried top, a transaction unknown store ${e[t]}`)}async readTxn(e){this._validateStoreNames(e);try{const t=this._db.transaction(e,"readonly");return this._hasWebkitEarlyCloseTxnBug&&await K(t.objectStore(e[0]).get($s)),new js(t,e,this)}catch(t){throw new z("readTxn failed",t)}}async readWriteTxn(e){this._validateStoreNames(e);try{const t=this._db.transaction(e,"readwrite");return this._hasWebkitEarlyCloseTxnBug&&await K(t.objectStore(e[0]).get($s)),new js(t,e,this)}catch(t){throw new z("readWriteTxn failed",t)}}close(){this._db.close()}get databaseName(){return this._db.name}}async function xn(n){const e=n.transaction(Me,"readonly"),t={};return await Promise.all(Me.map(async s=>{const i=t[s]=[],r=e.objectStore(s);await C(r.openCursor(),o=>(i.push(o),te))})),t}async function Dn(n,e){const t=n.transaction(Me,"readwrite");for(const s of Me){const i=t.objectStore(s);for(const r of e[s])i.add(r)}await Dt(t)}const Ws=[Fn,Pn,On,Nn,Bn,Ln,qn,jn,$n,Wn,Gn,Vn,Hn,zn,Qn,Jn,Yn];function Un(n){return{databaseName:n.name,get idbFactory(){throw new Error("unused")},get IDBKeyRange(){throw new Error("unused")},addWriteError(){}}}function Fn(n){n.createObjectStore("session",{keyPath:"key"}),n.createObjectStore("roomSummary",{keyPath:"roomId"}),n.createObjectStore("timelineFragments",{keyPath:"key"}),n.createObjectStore("timelineEvents",{keyPath:"key"}).createIndex("byEventId","eventIdKey",{unique:!0}),n.createObjectStore("roomState",{keyPath:"key"}),n.createObjectStore("pendingEvents",{keyPath:"key"})}async function Pn(n,e){const t=new Ls(n.createObjectStore("roomMembers",{keyPath:"key"})),s=e.objectStore("roomState");await C(s.openCursor(),i=>{if(i.event.type===D){s.delete(i.key);const r=v.fromMemberEvent(i.roomId,i.event);r&&t.set(r.serialize())}return te})}async function On(n,e,t){const s=e.objectStore("session");try{const r=await K(s.get(1));if(r){s.delete(1);const{syncToken:o,syncFilterId:a,serverVersions:c}=r.value,d=new Ut(s,t);d.set("sync",{token:o,filterId:a}),d.set("serverVersions",c)}}catch(i){e.abort(),console.error("could not migrate session",i.stack)}}function Nn(n){n.createObjectStore("userIdentities",{keyPath:"userId"}),n.createObjectStore("deviceIdentities",{keyPath:"key"}).createIndex("byCurve25519Key","curve25519Key",{unique:!0}),n.createObjectStore("olmSessions",{keyPath:"key"}),n.createObjectStore("inboundGroupSessions",{keyPath:"key"}),n.createObjectStore("outboundGroupSessions",{keyPath:"roomId"}),n.createObjectStore("groupSessionDecryptions",{keyPath:"key"}),n.createObjectStore("operations",{keyPath:"id"}).createIndex("byTypeAndScope","typeScopeKey",{unique:!1})}async function Bn(n,e){const t=e.objectStore("roomSummary"),s=e.objectStore("roomState"),i=[];await C(t.openCursor(),r=>(i.push(r),te));for(const r of i){const o=await K(s.get(`${r.roomId}|m.room.encryption|`));o&&(r.encryption=o?.event?.content,delete r.isEncrypted,t.put(r))}}function Ln(n){n.createObjectStore("accountData",{keyPath:"type"})}function qn(n){n.createObjectStore("invites",{keyPath:"roomId"})}function jn(n){n.createObjectStore("archivedRoomSummary",{keyPath:"summary.roomId"})}async function $n(n,e){try{const t=e.objectStore("operations");t.deleteIndex("byTypeAndScope"),await C(t.openCursor(),(s,i,r)=>{const{typeScopeKey:o}=s;delete s.typeScopeKey;const[a,c]=o.split("|");return s.scopeTypeKey=Ke(c,a),r.update(s),te}),t.createIndex("byScopeAndType","scopeTypeKey",{unique:!1})}catch(t){e.abort(),console.error("could not migrate operations",t.stack)}}function Wn(n){n.createObjectStore("timelineRelations",{keyPath:"key"})}function Gn(){}async function Vn(n,e){const t=e.objectStore("session"),s=await K(t.get("ssssKey"));s&&t.put({key:`${U}ssssKey`,value:s.value})}async function Hn(n,e,t,s){const i=e.objectStore("session"),r=new Ut(new Ds(i,Un(n)),t);r.writeE2EEIdentityToLocalStorage();const o=await r.tryRestoreE2EEIdentityFromLocalStorage(s);s.set("restored",o)}async function zn(n,e){for(const t of n.objectStoreNames){const s=e.objectStore(t);switch(t){case"inboundGroupSessions":case"outboundGroupSessions":case"olmSessions":case"operations":continue;case"session":{await C(s.openCursor(),(i,r,o)=>(r.startsWith(U)||o.delete(),te));break}default:{s.clear();break}}}}async function Qn(n,e,t,s){e.objectStore("inboundGroupSessions").createIndex("byBackup","backup",{unique:!1})}async function Jn(n,e,t,s){const i=e.objectStore("inboundGroupSessions");let r=0,o=0;await C(i.openCursor(),(a,c,d)=>(a.session?(a.backup=st.NotBackedUp,a.source=Ae.DeviceMessage,d.update(a),r+=1):o+=1,te)),s.set("countWithoutSession",o),s.set("countWithSession",r)}function Yn(n){n.createObjectStore("calls",{keyPath:"key"})}async function Xn(n){const e="hydrogen_webkit_test_inactive_txn_bug";try{const t=await As(e,r=>{r.createObjectStore("test",{keyPath:"key"})},1,n),s=t.transaction(["test"],"readonly");await K(s.objectStore("test").get("somekey")),await new Promise(r=>setTimeout(r,0));const i=t.transaction(["test"],"readwrite");await Promise.resolve(),i.objectStore("test").add({key:"somekey",value:"foo"}),await Dt(i),t.close()}catch(t){if(t.name==="TransactionInactiveError")return!0}return!1}const Gs=n=>`hydrogen_session_${n}`,Pt=function(n,e,t,s){const i=(r,o,a,c)=>to(r,o,a,c,t,s);return As(Gs(n),i,Ws.length,e)};async function Zn(){const n=this;if(n?.navigator?.storage?.persist)return await n.navigator.storage.persist();if(n?.document.requestStorageAccess)try{return await n.document.requestStorageAccess(),!0}catch(e){return console.warn("requestStorageAccess threw an error:",e),!1}else return!1}class eo{constructor(e,t=!1,s=self.indexedDB,i=self.IDBKeyRange,r=self.localStorage){this._serviceWorkerHandler=e,this._runSyncInWorker=t,this._idbFactory=s,this._IDBKeyRange=i,this._localStorage=r}async create(e,t){this._runSyncInWorker||await this._serviceWorkerHandler?.preventConcurrentSessionAccess(e),Zn().then(r=>{r||t.log("no persisted storage, database can be evicted by browser",t.level.Warn)});const s=await Xn(this._idbFactory),i=await Pt(e,this._idbFactory,this._localStorage,t);return new Kn(i,this._idbFactory,this._IDBKeyRange,s,this._localStorage,t.logger)}async delete(e){const t=Gs(e);try{on(this._localStorage,t)}catch{}try{const s=this._idbFactory.deleteDatabase(t);await K(s)}catch{}}async export(e,t){const s=await Pt(e,this._idbFactory,this._localStorage,t);return await xn(s)}async import(e,t,s){const i=await Pt(e,this._idbFactory,this._localStorage,s);return await Dn(i,t)}}async function to(n,e,t,s,i,r){const o=t||0;return r.wrap({l:"storage migration",oldVersion:t,version:s},async a=>{for(let c=o;c<s;++c){const d=Ws[c];await a.wrap(`v${c+1}`,h=>d(n,e,i,h))}})}class Vs{constructor({roomId:e,ownUserId:t,fragmentIdComparer:s}){this._roomId=e,this._ownUserId=t,this._fragmentIdComparer=s}async writeRelation(e,t,s){const{relatedEventId:i}=e;if(i){const r=ee(e.event);r&&r.rel_type&&t.timelineRelations.add(this._roomId,r.event_id,r.rel_type,e.id);const o=await t.timelineEvents.getByEventId(this._roomId,i);if(o){const a=await this._applyRelation(e,o,t,s);if(a)return a.map(c=>(t.timelineEvents.update(c),new F(c,this._fragmentIdComparer)))}}return null}async writeGapRelation(e,t,s,i){const r=new F(e,this._fragmentIdComparer),o=await this.writeRelation(r,s,i);if(t.isBackward&&!Rt(e.event)){const a=await s.timelineRelations.getAllForTarget(this._roomId,r.id);if(a.length)for(const c of a){const d=await s.timelineEvents.getByEventId(this._roomId,c.sourceEventId);if(d){const h=new F(d,this._fragmentIdComparer);await this._applyRelation(h,e,s,i)}}}return o}async _applyRelation(e,t,s,i){if(e.eventType===j)return i.wrap("redact",async r=>{const o=t.event,a=ee(o);if(this._applyRedaction(e.event,t,s,r)){const d=[t];if(a){const h=await this._reaggregateRelation(o,a,s,r);h&&d.push(h)}return d}return null});{const r=ee(e.event);if(r&&!Rt(t.event)&&r.rel_type===X&&i.wrap("react",c=>this._aggregateAnnotation(e.event,t,c)))return[t]}return null}_applyRedaction(e,t,s,i){const r=t.event;i.set("redactionId",e.event_id),i.set("id",r.event_id);const o=ee(r);return o&&o.rel_type&&s.timelineRelations.remove(this._roomId,o.event_id,o.rel_type,r.event_id),s.timelineRelations.removeAllForTarget(this._roomId,r.event_id),Qr(e,r),delete t.annotations,!0}_aggregateAnnotation(e,t){const s=ee(e);if(!s)return!1;let{annotations:i}=t;i||(t.annotations=i={});let r=i[s.key];r||(i[s.key]=r={count:0,me:!1,firstTimestamp:Number.MAX_SAFE_INTEGER});const o=e.sender===this._ownUserId;return r.me=r.me||o,r.count+=1,r.firstTimestamp=Math.min(r.firstTimestamp,e.origin_server_ts),!0}async _reaggregateRelation(e,t,s,i){return t.rel_type===X?i.wrap("reaggregate annotations",r=>this._reaggregateAnnotation(t.event_id,t.key,s,r)):null}async _reaggregateAnnotation(e,t,s,i){const r=await s.timelineEvents.getByEventId(this._roomId,e);if(!r||!r.annotations)return null;i.set("id",e);const o=await s.timelineRelations.getForTargetAndType(this._roomId,e,X);return i.set("relations",o.length),delete r.annotations[t],so(r.annotations)&&delete r.annotations,await Promise.all(o.map(async a=>{const c=await s.timelineEvents.getByEventId(this._roomId,a.sourceEventId);c||i.log({l:"missing annotation",id:a.sourceEventId}),ee(c.event).key===t&&this._aggregateAnnotation(c.event,r,i)})),r}}function so(n){for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}class J{constructor(e){this.isForward=e}get isBackward(){return!this.isForward}asApiString(){return this.isForward?"f":"b"}reverse(){return this.isForward?J.Backward:J.Forward}static get Forward(){return io}static get Backward(){return ro}}const io=new J(!0),ro=new J(!1);class B extends bs{constructor(e,t,s){super(s),this._fragment=e,this._isFragmentStart=t}static start(e,t){return new B(e,!0,t)}static end(e,t){return new B(e,!1,t)}get started(){return this._isFragmentStart}get hasEnded(){return!this.started}get fragment(){return this._fragment}get fragmentId(){return this._fragment.id}get entryIndex(){return this.started?I.minStorageKey:I.maxStorageKey}get isGap(){return!!this.token&&!this.edgeReached}get token(){return this.started?this.fragment.previousToken:this.fragment.nextToken}set token(e){this.started?this.fragment.previousToken=e:this.fragment.nextToken=e}get edgeReached(){return this.started?this.fragment.startReached:this.fragment.endReached}set edgeReached(e){this.started?this.fragment.startReached=e:this.fragment.endReached=e}get linkedFragmentId(){return this.started?this.fragment.previousId:this.fragment.nextId}set linkedFragmentId(e){this.started?this.fragment.previousId=e:this.fragment.nextId=e}get hasLinkedFragment(){return Tt(this.linkedFragmentId)}get direction(){return this.started?J.Backward:J.Forward}withUpdatedFragment(e){return new B(e,this._isFragmentStart,this._fragmentIdComparer)}createNeighbourEntry(e){return new B(e,!this._isFragmentStart,this._fragmentIdComparer)}addLocalRelation(){}removeLocalRelation(){}}function no(n){const e=new Set;return n.filter(t=>e.has(t.event_id)?!1:(e.add(t.event_id),!0))}class oo{constructor({roomId:e,fragmentIdComparer:t,memberWriter:s,relationWriter:i}){this._roomId=e,this._memberWriter=s,this._relationWriter=i,this._fragmentIdComparer=t,this._lastLiveKey=null}async load(e,t){const s=await e.timelineFragments.liveFragment(this._roomId);if(s){const[i]=await e.timelineEvents.lastEvents(this._roomId,s.id,1),r=i?i.eventIndex:S.defaultLiveKey.eventIndex;this._lastLiveKey=new S(s.id,r)}this._lastLiveKey&&t.set("live key",this._lastLiveKey.toString())}async _createLiveFragment(e,t){const s=await e.timelineFragments.liveFragment(this._roomId);if(s)return s;{t||(t=null);const i={roomId:this._roomId,id:S.defaultLiveKey.fragmentId,previousId:null,nextId:null,previousToken:t,nextToken:null};return e.timelineFragments.add(i),this._fragmentIdComparer.add(i),i}}async _replaceLiveFragment(e,t,s,i){const r=await i.timelineFragments.get(this._roomId,e);if(!r)throw new Error(`old live fragment doesn't exist: ${e}`);r.nextId=t,i.timelineFragments.update(r);const o={roomId:this._roomId,id:t,previousId:e,nextId:null,previousToken:s,nextToken:null};return i.timelineFragments.add(o),this._fragmentIdComparer.append(t,e),{oldFragment:r,newFragment:o}}async _ensureLiveFragment(e,t,s,i,r){if(e){if(s.limited){const o=e.fragmentId;e=e.nextFragmentKey();const{oldFragment:a,newFragment:c}=await this._replaceLiveFragment(o,e.fragmentId,s.prev_batch,i);t.push(B.end(a,this._fragmentIdComparer)),t.push(B.start(c,this._fragmentIdComparer)),r.log({l:"live fragment",limited:!0,id:e.fragmentId})}}else{let o=await this._createLiveFragment(i,s.prev_batch);e=new S(o.id,S.defaultLiveKey.eventIndex),t.push(B.start(o,this._fragmentIdComparer)),r.log({l:"live fragment",first:!0,id:e.fragmentId})}return e}async _writeStateEvents(e,t,s){let i=0;for(const r of e)r.type!==D&&(t.roomState.set(this._roomId,r),i+=1);s.set("stateEvents",i)}async _writeTimeline(e,t,s,i,r,o){const a=[],c=[];if(e?.length){i=await this._ensureLiveFragment(i,a,t,r,o),o.set("timelineEvents",e.length);let d=0;for(const h of e){i=i.nextKey();const l=Ct(i,this._roomId,h);let u=await s.lookupMemberAtEvent(h.sender,h,r);if(u&&(l.displayName=u.displayName,l.avatarUrl=u.avatarUrl),!await r.timelineEvents.tryInsert(l,o))continue;const m=new F(l,this._fragmentIdComparer);a.push(m);const _=await this._relationWriter.writeRelation(m,r,o);_&&c.push(..._),typeof h.state_key=="string"&&h.type!==D&&(d+=1,r.roomState.set(this._roomId,h))}o.set("timelineStateEventCount",d)}return{currentKey:i,entries:a,updatedEntries:c}}async _handleRejoinOverlap(e,t,s){if(this._lastLiveKey){const{fragmentId:i}=this._lastLiveKey,[r]=await t.timelineEvents.lastEvents(this._roomId,i,1);if(r){const o=r.event.event_id,{events:a}=e,c=a.findIndex(d=>d.event_id===o);if(c!==-1)return s.set("overlap_event_id",o),Object.assign({},e,{limited:!1,events:a.slice(c+1)})}}return e.limited?e:(s.set("force_limited_without_overlap",!0),Object.assign({},e,{limited:!0}))}async writeSync(e,t,s,i,r){let{timeline:o}=e;r.set("isRejoin",t),t&&(o=await this._handleRejoinOverlap(o,i,r));let a;Array.isArray(o?.events)&&(a=no(o.events));const{state:c}=e;let d;Array.isArray(c?.events)&&(d=c.events);const h=this._memberWriter.prepareMemberSync(d,a,s);d&&await this._writeStateEvents(d,i,r);const{currentKey:l,entries:u,updatedEntries:p}=await this._writeTimeline(a,o,h,this._lastLiveKey,i,r),m=await h.write(i);return{entries:u,updatedEntries:p,newLiveKey:l,memberChanges:m,memberSync:h}}afterSync(e){this._lastLiveKey=e}get lastMessageKey(){return this._lastLiveKey}}class Hs{constructor(e){this.limit=e,this._entries=[]}get size(){return this._entries.length}_get(e){return this._getByIndexAndMoveUp(this._entries.findIndex(e))}_getByIndexAndMoveUp(e){if(e!==-1){const t=this._entries[e];return e>0&&(this._entries.splice(e,1),this._entries.unshift(t)),t}}_set(e,t){let s=t?this._entries.findIndex(t):-1;this._entries.unshift(e),s===-1?this._entries.length>this.limit&&(s=this._entries.length-1):s+=1,s!==-1&&(this.onEvictEntry(this._entries[s]),this._entries.splice(s,1))}onEvictEntry(e){}}class zs extends Hs{constructor(e,t){super(e),this._keyFn=t}get(e){return this._get(t=>this._keyFn(t)===e)}set(e){const t=this._keyFn(e);this._set(e,s=>this._keyFn(s)===t)}}class ao{constructor(e){this._roomId=e,this._cache=new zs(5,t=>t.userId)}prepareMemberSync(e,t,s){return new co(this,e,t,s)}async _writeMember(e,t){let s=this._cache.get(e.userId);if(!s){const i=await t.roomMembers.get(this._roomId,e.userId);i&&(s=new v(i))}if(!s||!s.equals(e))return t.roomMembers.set(e.serialize()),this._cache.set(e),new ks(e,s?.membership)}async lookupMember(e,t){let s=this._cache.get(e);if(!s){const i=await t.roomMembers.get(this._roomId,e);i&&(s=new v(i),this._cache.set(s))}return s}}class co{constructor(e,t,s,i){this._memberWriter=e,this._timelineEvents=s,this._hasFetchedMembers=i,this._newStateMembers=null,t&&(this._newStateMembers=this._stateEventsToMembers(t))}get _roomId(){return this._memberWriter._roomId}_stateEventsToMembers(e){let t;for(const s of e)if(s.type===D){const i=v.fromMemberEvent(this._roomId,s);i&&(t||(t=new Map),t.set(i.userId,i))}return t}_timelineEventsToMembers(e){let t;for(let s=e.length-1;s>=0;s--){const i=e[s],r=i.state_key;if(i.type===D&&!t?.has(r)){const o=v.fromMemberEvent(this._roomId,i);o&&(t||(t=new Map),t.set(o.userId,o))}}return t}async lookupMemberAtEvent(e,t,s){let i;return this._timelineEvents&&(i=this._findPrecedingMemberEventInTimeline(e,t),i)||(i=this._newStateMembers?.get(e),i)?i:await this._memberWriter.lookupMember(e,s)}async write(e){const t=new Map;let s;if(this._timelineEvents&&(s=this._timelineEventsToMembers(this._timelineEvents)),this._newStateMembers){for(const i of this._newStateMembers.values())if(!s?.has(i.userId)){const r=await this._memberWriter._writeMember(i,e);r&&(!this._hasFetchedMembers&&!r.previousMembership&&(r.previousMembership=i.membership),t.set(r.userId,r))}}if(s)for(const i of s.values()){const r=await this._memberWriter._writeMember(i,e);r&&t.set(r.userId,r)}return t}_findPrecedingMemberEventInTimeline(e,t){let s=-1;for(let i=this._timelineEvents.length-1;i>=0;i--)if(this._timelineEvents[i].event_id===t.event_id){s=i;break}for(let i=s-1;i>=0;i--){const r=this._timelineEvents[i];if(r.type===D&&r.state_key===e){const o=v.fromMemberEvent(this._roomId,r);if(o)return o}}}}class ho{constructor({roomId:e,storage:t,fragmentIdComparer:s,relationWriter:i}){this._roomId=e,this._storage=t,this._fragmentIdComparer=s,this._relationWriter=i}async _findOverlappingEvents(e,t,s,i){const r=t.map(d=>d.event_id),o=await s.timelineEvents.getEventKeysForIds(this._roomId,r);i.set("existingEvents",o.size);const a=t.filter(d=>!o.has(d.event_id));i.set("nonOverlappingEvents",a.length);let c;if(e.hasLinkedFragment){i.set("linkedFragmentId",e.linkedFragmentId);for(const d of o.values())if(d.fragmentId===e.linkedFragmentId){i.set("foundLinkedFragment",!0);const h=await s.timelineFragments.get(this._roomId,e.linkedFragmentId);c=e.createNeighbourEntry(h);break}}return{nonOverlappingEvents:a,neighbourFragmentEntry:c}}async _findFragmentEdgeEventKey(e,t){const{fragmentId:s,direction:i}=e,r=await this._findFragmentEdgeEvent(s,i,t);return r?new S(r.fragmentId,r.eventIndex):S.defaultFragmentKey(e.fragmentId)}async _findFragmentEdgeEvent(e,t,s){if(t.isBackward){const[i]=await s.timelineEvents.firstEvents(this._roomId,e,1);return i}else{const[i]=await s.timelineEvents.lastEvents(this._roomId,e,1);return i}}async _storeEvents(e,t,s,i,r,o){const a=[],c=[];let d=t;for(let h=0;h<e.length;++h){const l=e[h];d=d.nextKeyForDirection(s);const u=Ct(d,this._roomId,l),p=this._findMember(l.sender,i,e,h,s);p&&(u.displayName=p.displayName,u.avatarUrl=p.avatarUrl);const m=await this._relationWriter.writeGapRelation(u,s,r,o);if(m&&c.push(...m),await r.timelineEvents.tryInsert(u,o)){const _=new F(u,this._fragmentIdComparer);Ce(a,_,s)}}return{entries:a,updatedEntries:c}}_findMember(e,t,s,i,r){function o(d){return d.type===D&&d.state_key===e}const a=r.isBackward?1:-1;for(let d=i+a;d>=0&&d<s.length;d+=a){const h=s[d];if(o(h))return v.fromMemberEvent(this._roomId,h)}for(let d=i;d>=0&&d<s.length;d-=a){const h=s[d];if(o(h))return v.fromReplacingMemberEvent(this._roomId,h)}const c=t?.find(o);if(c)return v.fromMemberEvent(this._roomId,c)}async _updateFragments(e,t,s,i,r,o){const{direction:a}=e,c=[];return Ce(i,e,a),t?(o.set("closedGapWith",t.fragmentId),t.token=null,e.token=null,r.timelineFragments.update(t.fragment),Ce(i,t,a),c.push(e.fragment),c.push(t.fragment)):e.token=s,r.timelineFragments.update(e.fragment),c}async writeFragmentFill(e,t,s,i,r){const{fragmentId:o,direction:a}=e,{chunk:c,state:d}=t;let{end:h}=t;if(!Array.isArray(c))throw new Error("Invalid chunk in response");if(typeof h!="string"&&typeof h<"u")throw new Error("Invalid end token in response");const l=await i.timelineFragments.get(this._roomId,o);if(!l)throw new Error(`Unknown fragment: ${o}`);if(e=e.withUpdatedFragment(l),e.token!==s)throw new Error("The pagination token has changed locally while fetching messages.");if(c.length===0)return e.edgeReached=!0,await i.timelineFragments.update(e.fragment),{entries:[e],updatedEntries:[],fragments:[]};let u=await this._findFragmentEdgeEventKey(e,i);r.set("lastKey",u.toString());const{nonOverlappingEvents:p,neighbourFragmentEntry:m}=await this._findOverlappingEvents(e,c,i,r),{entries:_,updatedEntries:g}=await this._storeEvents(p,u,a,d,i,r),R=await this._updateFragments(e,m,h,_,i,r);return{entries:_,updatedEntries:g,fragments:R}}}function Ot(n){typeof n=="function"?n():n.dispose()}function lo(n){return n&&(typeof n=="function"||typeof n.dispose=="function")}class Qs{constructor(){this._disposables=[]}track(e){if(!lo(e))throw new Error("Not a disposable");return this.isDisposed?(console.warn("Disposables already disposed, disposing new value"),Ot(e),e):(this._disposables.push(e),e)}untrack(e){if(!this._disposables)return;const t=this._disposables.indexOf(e);t>=0&&this._disposables.splice(t,1)}dispose(){if(this._disposables){for(const e of this._disposables)Ot(e);this._disposables=void 0}}get isDisposed(){return this._disposables===void 0}disposeTracked(e){if(e==null||this.isDisposed)return;const t=this._disposables.indexOf(e);if(t!==-1){const[s]=this._disposables.splice(t,1);Ot(s)}else console.warn("disposable not found, did it leak?",e)}}class Js{constructor(e,t){this.decryptRequest=null,this._promise=e(this,t)}complete(){return this._promise}dispose(){this.decryptRequest&&(this.decryptRequest.dispose(),this.decryptRequest=null)}}async function uo(n,e,t,s,i,r){let o=[];const a=r.timelineEvents,c=r.timelineFragments;for(;o.length<s&&e;){let d;t.isForward?d=await a.eventsAfter(n,e,s):d=await a.eventsBefore(n,e,s);let h=d.map(l=>new F(l,i));if(o=Vr(o,h,t),o.length<s){const l=await c.get(n,e.fragmentId);let u=new B(l,t.isBackward,i);if(Ce(o,u,t),!u.token&&u.hasLinkedFragment){const p=await c.get(n,u.linkedFragmentId);i.add(p);const m=new B(p,t.isForward,i);Ce(o,m,t),e=m.asEventKey()}else e=null}}return o}class Ys{constructor({roomId:e,storage:t,fragmentIdComparer:s}){this._roomId=e,this._storage=t,this._fragmentIdComparer=s,this._decryptEntries=null}enableEncryption(e){this._decryptEntries=e}get readTxnStores(){const e=[this._storage.storeNames.timelineEvents,this._storage.storeNames.timelineFragments];return this._decryptEntries&&e.push(this._storage.storeNames.inboundGroupSessions),e}readFrom(e,t,s,i){return new Js(async(r,o)=>{const a=await this._storage.readTxn(this.readTxnStores);return await this._readFrom(e,t,s,r,a,o)},i)}readFromEnd(e,t=null,s){return new Js(async(i,r)=>{const o=t||await this._storage.readTxn(this.readTxnStores),a=await o.timelineFragments.liveFragment(this._roomId);let c;if(!a)c=[];else{this._fragmentIdComparer.add(a);const d=B.end(a,this._fragmentIdComparer),h=d.asEventKey();c=await this._readFrom(h,J.Backward,e,i,o,r),c.unshift(d)}return c},s)}async readById(e,t){let s=[this._storage.storeNames.timelineEvents];this._decryptEntries&&s.push(this._storage.storeNames.inboundGroupSessions);const i=await this._storage.readTxn(s),r=await i.timelineEvents.getByEventId(this._roomId,e);if(r){const o=new F(r,this._fragmentIdComparer);return this._decryptEntries&&await this._decryptEntries([o],i,t).complete(),o}}async _readFrom(e,t,s,i,r,o){const a=await uo(this._roomId,e,t,s,this._fragmentIdComparer,r);if(this._decryptEntries){i.decryptRequest=this._decryptEntries(a,r,o);try{await i.decryptRequest.complete()}finally{i.decryptRequest=null}}return a}}class mo extends F{get fragmentId(){throw new Error("Cannot access fragmentId for non-persisted EventEntry")}get entryIndex(){throw new Error("Cannot access entryIndex for non-persisted EventEntry")}get isNonPersisted(){return!0}get isRedacting(){return!1}get isRedacted(){return super.isRedacting}}class po{constructor(e){this._userId=e}get id(){return this._userId}}class rt{constructor({roomId:e,storage:t,closeCallback:s,fragmentIdComparer:i,pendingEvents:r,clock:o,powerLevelsObservable:a,hsApi:c}){this._roomId=e,this._storage=t,this._closeCallback=s,this._fragmentIdComparer=i,this._disposables=new Qs,this._pendingEvents=r,this._clock=o,this._remoteEntries=new ls((d,h)=>d.compare(h)),this._ownMember=null,this._timelineReader=new Ys({roomId:this._roomId,storage:this._storage,fragmentIdComparer:this._fragmentIdComparer}),this._readerRequest=null,this._allEntries=null,this._contextEntriesNotInTimeline=new Map,this._decryptEntries=null,this._hsApi=c,this.initializePowerLevels(a)}initializePowerLevels(e){e&&(this._powerLevels=e.get(),this._disposables.track(e.subscribe(t=>this._powerLevels=t)))}async load(e,t,s){const i=await this._storage.readTxn(this._timelineReader.readTxnStores.concat(this._storage.storeNames.roomMembers,this._storage.storeNames.roomState)),r=await i.roomMembers.get(this._roomId,e.id);r?this._ownMember=new v(r):this._ownMember=v.fromUserId(this._roomId,e.id,t);const o=this._disposables.track(this._timelineReader.readFromEnd(20,i,s));try{const a=await o.complete();this._loadContextEntriesWhereNeeded(a),this._setupEntries(a)}finally{this._disposables.disposeTracked(o)}}_setupEntries(e){this._remoteEntries.setManySorted(e),this._pendingEvents?this._localEntries=new ir(this._pendingEvents,t=>this._mapPendingEventToEntry(t),(t,s)=>{t.notifyUpdate(s)},t=>this._applyAndEmitLocalRelationChange(t,s=>s.removeLocalRelation(t))):this._localEntries=new Qi,this._allEntries=new cr(this._remoteEntries,this._localEntries)}async _mapPendingEventToEntry(e){let t;e.eventType===j&&(t=await this._getOrLoadEntry(e.relatedTxnId,e.relatedEventId));const s=new Wr({pendingEvent:e,member:this._ownMember,clock:this._clock,redactingEntry:t});return this._loadContextEntriesWhereNeeded([s]),this._applyAndEmitLocalRelationChange(s,i=>i.addLocalRelation(s)),s}_applyAndEmitLocalRelationChange(e,t){const s=i=>{const r=t(i);return r||!1};if(this._findAndUpdateEntryById(e.pendingEvent.relatedTxnId,e.relatedEventId,s),e.redactingEntry){const i=e.redactingEntry.pendingEvent?.relatedTxnId;this._findAndUpdateEntryById(i,e.redactingEntry.relatedEventId,s),e.redactingEntry.contextForEntries?.forEach(r=>this._emitUpdateForEntry(r,"contextEntry"))}}_findAndUpdateEntryById(e,t,s){let i=!1;e&&(i=this._localEntries.findAndUpdate(r=>r.id===e,s)),!i&&t&&this._remoteEntries.findAndUpdate(r=>r.id===t,s)}async getOwnAnnotationEntry(e,t){const s=await this._storage.readWriteTxn([this._storage.storeNames.timelineEvents,this._storage.storeNames.timelineRelations]),i=await s.timelineRelations.getForTargetAndType(this._roomId,e,X);for(const r of i){const o=await s.timelineEvents.getByEventId(this._roomId,r.sourceEventId);if(o&&o.event.sender===this._ownMember.userId&&ee(o.event).key===t){const a=new F(o,this._fragmentIdComparer);return this._addLocalRelationsToNewRemoteEntries([a]),a}}return null}updateOwnMember(e){this._ownMember=e}_addLocalRelationsToNewRemoteEntries(e){if(!!this._localEntries?.hasSubscriptions){for(const t of this._localEntries)if(t.relatedEventId&&e.find(i=>i.id===t.relatedEventId)?.addLocalRelation(t),t.redactingEntry){const s=t.redactingEntry.relatedEventId;e.find(r=>r.id===s)?.addLocalRelation(t)}}}static _entryUpdater(e,t){return e.contextForEntries?.forEach(s=>s.setContextEntry(t)),t.updateFrom(e),t}replaceEntries(e){this._addLocalRelationsToNewRemoteEntries(e);for(const t of e)try{this._remoteEntries.getAndUpdate(t,rt._entryUpdater);const s=this._contextEntriesNotInTimeline.get(t.id);s&&(rt._entryUpdater(s,t),this._contextEntriesNotInTimeline.set(t.id,t)),t.contextForEntries?.forEach(i=>this._emitUpdateForEntry(i,"contextEntry"))}catch(s){if(s.name==="CompareError")continue;throw s}}addEntries(e){this._addLocalRelationsToNewRemoteEntries(e),this._updateEntriesFetchedFromHomeserver(e),this._moveEntryToRemoteEntries(e),this._loadContextEntriesWhereNeeded(e),this._remoteEntries.setManySorted(e)}_updateEntriesFetchedFromHomeserver(e){for(const t of e){const s=this._contextEntriesNotInTimeline.get(t.relatedEventId);s?.isNonPersisted&&s?.addLocalRelation(t)&&s.contextForEntries?.forEach(i=>this._emitUpdateForEntry(i,"contextEntry"))}}_moveEntryToRemoteEntries(e){for(const t of e){const s=this._contextEntriesNotInTimeline.get(t.id);s&&(s.contextForEntries.forEach(i=>{i.setContextEntry(t),this._emitUpdateForEntry(i,"contextEntry")}),this._contextEntriesNotInTimeline.delete(t.id))}}_emitUpdateForEntry(e,t){const s=e.isPending?e.id:null,i=e.isPending?null:e.id;this._findAndUpdateEntryById(s,i,()=>t)}async _loadContextEntriesWhereNeeded(e){for(const t of e){if(!t.contextEventId)continue;const s=t.contextEventId;let i=e.find(r=>r.id===s);i||(i=this._findLoadedEventById(s)),i?t.setContextEntry(i):this._loadContextEntryNotInTimeline(t)}}async _loadContextEntryNotInTimeline(e){const t=e.contextEventId;let s=await this._getEventFromStorage(t);s||(s=await this._getEventFromHomeserver(t)),s&&(this._contextEntriesNotInTimeline.set(t,s),e.setContextEntry(s),this._emitUpdateForEntry(e,"contextEntry"))}_findLoadedEventById(e){return this.getByEventId(e)??this._contextEntriesNotInTimeline.get(e)}async _getEventFromStorage(e){return await this._timelineReader.readById(e)}async _getEventFromHomeserver(e){const t=await this._hsApi.context(this._roomId,e,0).response(),s=t.event.sender,i=t.state.find(a=>a.type===D&&a.user_id===s),r={event:t.event,displayName:i.content.displayname,avatarUrl:i.content.avatar_url},o=new mo(r,this._fragmentIdComparer);return this._decryptEntries&&await this._decryptEntries([o]).complete(),o}async loadAtTop(e){if(this._disposables.isDisposed)return!0;const t=this._remoteEntries.array.find(i=>!!i.eventType);if(!t)return!0;const s=this._disposables.track(this._timelineReader.readFrom(t.asEventKey(),J.Backward,e));try{const i=await s.complete();return this.addEntries(i),i.length<e}finally{this._disposables.disposeTracked(s)}}async _getOrLoadEntry(e,t){if(e){for(const s of this._localEntries)if(s.id===e)return s}return t?this.getByEventId(t)??await this._getEventFromStorage(t):null}getByEventId(e){for(let t=0;t<this._remoteEntries.length;t+=1){const s=this._remoteEntries.get(t);if(s.id===e)return s}return null}get entries(){return this._allEntries}get remoteEntries(){return this._remoteEntries.array}dispose(){this._closeCallback&&(this._disposables.dispose(),this._closeCallback(),this._closeCallback=null)}enableEncryption(e){this._decryptEntries=e,this._timelineReader.enableEncryption(e)}get powerLevels(){return this._powerLevels}get me(){return this._ownMember}}async function _o({roomId:n,storage:e,txn:t}){return t||(t=await e.readTxn([e.storeNames.roomMembers])),(await t.roomMembers.getAll(n)).map(i=>new v(i))}async function fo({summary:n,syncToken:e,roomId:t,hsApi:s,storage:i,setChangedMembersMap:r},o){const a=new Map;r(a);const c=await s.members(t,{at:e},{log:o}).response(),d=await i.readWriteTxn([i.storeNames.roomSummary,i.storeNames.roomMembers]);let h,l;try{h=n.writeHasFetchedMembers(!0,d);const{roomMembers:u}=d,p=c.chunk;if(!Array.isArray(p))throw new Error("malformed");o.set("members",p.length),l=await Promise.all(p.map(async m=>{const _=m?.state_key;if(!_)throw new Error("malformed");const g=a.get(_);if(g)return g;{const R=v.fromMemberEvent(t,m);return R&&u.set(R.serialize()),R}}))}catch(u){throw d.abort(),u}finally{r(null)}return await d.complete(),n.applyChanges(h),l}async function yo(n,e){const{summary:t}=n;return t.data.hasFetchedMembers?_o(n):e.wrapOrRun(n.log,"fetchMembers",s=>fo(n,s))}async function go(n,e){const t=await vo(n),{summary:s}=n;return!s.data.hasFetchedMembers&&!t?e.wrapOrRun(n.log,"fetchMember",i=>wo(n,i)):t}async function vo({roomId:n,userId:e,storage:t}){const i=await(await t.readTxn([t.storeNames.roomMembers])).roomMembers.get(n,e);return i?new v(i):null}async function wo({roomId:n,userId:e,hsApi:t,storage:s},i){let r;try{r=await t.state(n,"m.room.member",e,{log:i}).response()}catch(c){if(c.name==="HomeServerError"&&c.errcode==="M_NOT_FOUND")return null;throw c}const o=new v({roomId:n,userId:e,membership:r.membership,avatarUrl:r.avatar_url,displayName:r.displayname}),a=await s.readWriteTxn([s.storeNames.roomMembers]);try{a.roomMembers.set(o.serialize())}catch(c){throw a.abort(),c}return await a.complete(),o}class bo{constructor(e){this._retentionCount=1,this._freeCallback=e}retain(){this._retentionCount+=1}release(){this._retentionCount-=1,this._retentionCount===0&&this._freeCallback()}}class Io extends bo{constructor({members:e,closeCallback:t}){super(t),this._members=new oe;for(const s of e)this._members.add(s.userId,s)}afterSync(e){for(const[t,s]of e.entries())this._members.set(t,s.member)}get members(){return this._members}}function Nt(n,e,t){const s=e.joinCount+e.inviteCount-1;if(n.length>=s)if(n.length>1){const i=n[n.length-1];return n.slice(0,n.length-1).map(o=>o.name).join(", ")+" and "+i.name}else{const i=n[0];return i?i.name:(t.log({l:"could get get other member name",length:n.length,otherMember:!!i,otherMemberMembership:i?.membership}),"Unknown DM Name")}else return n.length<s?n.map(i=>i.name).join(", ")+` and ${s} others`:null}class Bt{constructor(e){this._roomId=e,this._members=new Map}async calculateChanges(e,t,s){const i=new Map,r=[];for(const o of this._members.keys())e.indexOf(o)===-1&&r.push(o);for(const[o,a]of t.entries())(this._members.has(o)||e.indexOf(o)!==-1)&&i.set(o,a.member);for(const o of e)if(!this._members.has(o)&&!i.has(o)){const a=await s.roomMembers.get(this._roomId,o);if(a){const c=new v(a);i.set(c.userId,c)}}return{updatedHeroMembers:i.values(),removedUserIds:r}}applyChanges({updatedHeroMembers:e,removedUserIds:t},s,i){for(const o of t)this._members.delete(o);for(const o of e)t.includes(o.userId)||this._members.set(o.userId,o);const r=Array.from(this._members.values()).sort((o,a)=>o.name.localeCompare(a.name));this._roomName=Nt(r,s,i)}get roomName(){return this._roomName}get roomAvatarUrl(){if(this._members.size===1)for(const e of this._members.values())return e.avatarUrl;return null}get roomAvatarColorId(){if(this._members.size===1)for(const e of this._members.keys())return e;return null}}class So{constructor(e){this._map=new Map,this._notifyEmpty=e}observe(e,t=null){let s=this._map.get(e);return s||(s=new Eo(this,t,e),this._map.set(e,s)),s}updateEvents(e){for(let t=0;t<e.length;t+=1){const s=e[t];this._map.get(s.id)?.update(s)}}_remove(e){this._map.delete(e),this._map.size===0&&this._notifyEmpty()}}class Eo extends fe{constructor(e,t,s){super(),this._eventMap=e,this._entry=t,this._id=s,Promise.resolve().then(()=>{this.hasSubscriptions||(this._eventMap._remove(this._id),this._eventMap=null)})}subscribe(e){if(!this._eventMap)throw new Error("ObservedEvent expired, subscribe right after calling room.observeEvent()");return super.subscribe(e)}onUnsubscribeLast(){this._eventMap._remove(this._id),this._eventMap=null,super.onUnsubscribeLast()}update(e){this._entry=e,this.emit(this._entry)}get(){return this._entry}}function Ro(n){return n||hn.item}const ko="m.room.power_levels";class nt{constructor({powerLevelEvent:e,createEvent:t,ownUserId:s,membership:i}){this._plEvent=e,this._createEvent=t,this._ownUserId=s,this._membership=i}canRedactFromSender(e){return e===this._ownUserId&&this._membership==="join"?!0:this.canRedact}canSendType(e){return this._myLevel>=this._getEventTypeLevel(e)}get canRedact(){return this._myLevel>=this._getActionLevel("redact")}get _myLevel(){return this._membership!=="join"?Number.MIN_SAFE_INTEGER:this.getUserLevel(this._ownUserId)}getUserLevel(e){if(this._plEvent){let t=this._plEvent.content?.users?.[e];if(typeof t!="number"&&(t=this._plEvent.content?.users_default),typeof t=="number")return t}else if(this._createEvent&&e===this._createEvent.content?.creator)return 100;return 0}_getActionLevel(e){const t=this._plEvent?.content[e];return typeof t=="number"?t:50}_getEventTypeLevel(e){const t=this._plEvent?.content?.events?.[e];if(typeof t=="number")return t;{const s=this._plEvent?.content?.events_default;return typeof s=="number"?s:0}}}class Mo extends oe{constructor(e){super(),this.type=e}async load(e,t){const s=await t.roomState.getAllForType(e,this.type);for(let i=0;i<s.length;++i){const{event:r}=s[i];this.add(r.state_key,r)}}handleStateEvent(e){e.type===this.type&&this.set(e.state_key,e)}setRemoveCallback(e){this.removeCallback=e}onUnsubscribeLast(){this.removeCallback?.()}}class Co extends fe{constructor(e,t){super(),this.type=e,this.stateKey=t}async load(e,t){this.event=(await t.roomState.get(e,this.type,this.stateKey))?.event}handleStateEvent(e){e.type===this.type&&e.state_key===this.stateKey&&(this.event=e,this.emit(this.get()))}get(){return this.event}setRemoveCallback(e){this.removeCallback=e}onUnsubscribeLast(){this.removeCallback?.()}}const To="m.room.encrypted";class Xs extends ye{constructor({roomId:e,storage:t,hsApi:s,mediaRepository:i,emitCollectionChange:r,user:o,createRoomEncryption:a,getSyncToken:c,platform:d}){super(),this._roomId=e,this._storage=t,this._hsApi=s,this._mediaRepository=i,this._summary=new Fr(e),this._fragmentIdComparer=new en([]),this._emitCollectionChange=r,this._timeline=null,this._user=o,this._changedMembersDuringSync=null,this._memberList=null,this._createRoomEncryption=a,this._roomEncryption=null,this._getSyncToken=c,this._platform=d,this._observedEvents=null,this._roomStateObservers=new Set,this._powerLevels=null,this._powerLevelLoading=null,this._observedMembers=null}async observeStateType(e,t=void 0){const s=new Mo(e);return await this._addStateObserver(s,t),s}async observeStateTypeAndKey(e,t,s=void 0){const i=new Co(e,t);return await this._addStateObserver(i,s),i}async _addStateObserver(e,t){t||(t=await this._storage.readTxn([this._storage.storeNames.roomState])),await e.load(this.id,t),this._roomStateObservers.add(e),e.setRemoveCallback(()=>{this._roomStateObservers.delete(e)})}async _eventIdsToEntries(e,t){const s=[];return await Promise.all(e.map(async i=>{const r=await t.timelineEvents.getByEventId(this._roomId,i);r&&s.push(new F(r,this._fragmentIdComparer))})),s}_getAdditionalTimelineRetryEntries(e,t){let s=this._roomEncryption.filterUndecryptedEventEntriesForKeys(this._timeline.remoteEntries,t);const i=e.reduce((r,o)=>(r.add(o.id),r),new Set);return s=s.filter(r=>!i.has(r.id)),s}async notifyRoomKey(e,t,s){if(!this._roomEncryption)return;const i=await this._storage.readTxn([this._storage.storeNames.timelineEvents,this._storage.storeNames.inboundGroupSessions]);let r=await this._eventIdsToEntries(t,i);if(this._timeline){const o=this._getAdditionalTimelineRetryEntries(r,[e]);r=r.concat(o)}if(r.length){await this._decryptEntries(ae.Retry,r,i,s).complete(),this._timeline?.replaceEntries(r);const a=this._summary.data.applyTimelineEntries(r,!1,!1);await this._summary.writeAndApplyData(a,this._storage)&&this._emitUpdate()}}_setEncryption(e){return e&&!this._roomEncryption?(this._roomEncryption=e,this._timeline&&this._timeline.enableEncryption(this._decryptEntries.bind(this,ae.Timeline)),!0):!1}_decryptEntries(e,t,s,i=null){return new Ao(async(o,a)=>{if(s||(s=await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions])),o.cancelled)return;const c=t.filter(m=>m.eventType===To).map(m=>m.event);if(o.preparation=await this._roomEncryption.prepareDecryptAll(c,null,e,s),o.cancelled)return;const d=await o.preparation.decrypt();if(o.preparation=null,o.cancelled)return;const h=[this._storage.storeNames.groupSessionDecryptions],l=this._isTimelineOpen;l&&h.push(this._storage.storeNames.deviceIdentities);const u=await this._storage.readWriteTxn(h);let p;try{p=await d.write(u,a),l&&await p.verifyKnownSenders(u)}catch(m){throw u.abort(),m}await u.complete(),p.applyToEntries(t),this._observedEvents&&this._observedEvents.updateEvents(t),l&&p.hasUnverifiedSenders&&a.wrapDetached("fetch unknown senders keys",async m=>{const _=await p.fetchAndVerifyRemainingSenders(this._hsApi,m),g=[];_.applyToEntries(t,R=>g.push(R)),this._timeline?.replaceEntries(g),this._observedEvents?.updateEvents(g)})},Ro(i))}async _getSyncRetryDecryptEntries(e,t,s){let r=(await Promise.all(e.map(async o=>{const a=await t.getEventIdsForMissingKey(o,s);if(a)return this._eventIdsToEntries(a,s)}))).reduce((o,a)=>a?o.concat(a):o,[]);if(this._timeline){const a=this._getAdditionalTimelineRetryEntries(r,e).map(c=>c.clone());r=r.concat(a)}return r}async load(e,t,s){s.set("id",this.id);try{if(e&&this._summary.load(e),this._summary.data.encryption){const i=this._createRoomEncryption(this,this._summary.data.encryption);this._setEncryption(i)}if(this._summary.data.needsHeroes){this._heroes=new Bt(this._roomId);const i=await this._heroes.calculateChanges(this._summary.data.heroes,[],t);this._heroes.applyChanges(i,this._summary.data,s)}}catch(i){throw new cs(`Could not load room ${this._roomId}`,i)}}async observeMember(e){this._observedMembers||(this._observedMembers=new Map);const t=this._observedMembers.get(e);if(t)return t;const s=await go({summary:this._summary,roomId:this._roomId,userId:e,storage:this._storage,hsApi:this._hsApi},this._platform.logger);if(!s)return null;const i=new We(s,()=>this._observedMembers.delete(e));return this._observedMembers.set(e,i),i}async loadMemberList(e=void 0,t=null){if(this._memberList)return this._memberList.retain(),this._memberList;{const s=await yo({summary:this._summary,roomId:this._roomId,hsApi:this._hsApi,storage:this._storage,txn:e,syncToken:this._getSyncToken(),setChangedMembersMap:i=>this._changedMembersDuringSync=i,log:t},this._platform.logger);return this._memberList=new Io({members:s,closeCallback:()=>{this._memberList=null}}),this._memberList}}fillGap(e,t,s=null){return this._platform.logger.wrapOrRun(s,"fillGap",async i=>{if(i.set("id",this.id),i.set("fragment",e.fragmentId),i.set("dir",e.direction.asApiString()),e.edgeReached){i.set("edgeReached",!0);return}const r=await this._hsApi.messages(this._roomId,{from:e.token,dir:e.direction.asApiString(),limit:t,filter:{lazy_load_members:!0,include_redundant_members:!0}},{log:i}).response(),o=await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents,this._storage.storeNames.timelineEvents,this._storage.storeNames.timelineRelations,this._storage.storeNames.timelineFragments]);let a,c;try{a=await this._writeGapFill(r.chunk,o,i);const d=new Vs({roomId:this._roomId,fragmentIdComparer:this._fragmentIdComparer,ownUserId:this._user.id});c=await new ho({roomId:this._roomId,storage:this._storage,fragmentIdComparer:this._fragmentIdComparer,relationWriter:d}).writeFragmentFill(e,r,e.token,o,i)}catch(d){throw o.abort(),d}await o.complete(),this._roomEncryption&&await this._decryptEntries(ae.Timeline,c.entries,null,i).complete();for(const d of c.fragments)this._fragmentIdComparer.add(d);a&&this._applyGapFill(a),this._timeline&&(this._timeline.replaceEntries(c.updatedEntries),this._timeline.addEntries(c.entries))})}async _writeGapFill(e,t,s){}_applyGapFill(){}get name(){if(this._heroes)return this._heroes.roomName;const e=this._summary.data;return e.name?e.name:e.canonicalAlias?e.canonicalAlias:null}get id(){return this._roomId}get avatarUrl(){return this._summary.data.avatarUrl?this._summary.data.avatarUrl:this._heroes?this._heroes.roomAvatarUrl:null}get avatarColorId(){return this._roomId}get lastMessageTimestamp(){return this._summary.data.lastMessageTimestamp}get isLowPriority(){const e=this._summary.data.tags;return!!(e&&e["m.lowpriority"])}get isEncrypted(){return!!this._summary.data.encryption}get isJoined(){return this.membership==="join"}get isLeft(){return this.membership==="leave"}get canonicalAlias(){return this._summary.data.canonicalAlias}get joinedMemberCount(){return this._summary.data.joinCount}get mediaRepository(){return this._mediaRepository}get membership(){return this._summary.data.membership}get user(){return this._user}isDirectMessageForUserId(e){if(this._summary.data.dmUserId===e)return!0;{const{heroes:t,joinCount:s,inviteCount:i}=this._summary.data;if(t&&t.includes(e)&&s+i===2)return!0}return!1}async _loadPowerLevels(){const e=await this._storage.readTxn([this._storage.storeNames.roomState]),t=await e.roomState.get(this._roomId,"m.room.power_levels","");if(t)return new nt({powerLevelEvent:t.event,ownUserId:this._user.id,membership:this.membership});const s=await e.roomState.get(this._roomId,"m.room.create","");if(s)return new nt({createEvent:s.event,ownUserId:this._user.id,membership:this.membership});{const i=this.membership;return new nt({ownUserId:this._user.id,membership:i})}}async observePowerLevels(){this._powerLevelLoading&&await this._powerLevelLoading;let e=this._powerLevels;if(!e){this._powerLevelLoading=this._loadPowerLevels();const t=await this._powerLevelLoading;e=new We(t,()=>{this._powerLevels=null}),this._powerLevels=e,this._powerLevelLoading=null}return e}enableKeyBackup(e){this._roomEncryption?.enableKeyBackup(e),this._timeline&&e&&this._platform.logger.run("enableKeyBackup",t=>this._roomEncryption.restoreMissingSessionsFromBackup(this._timeline.remoteEntries,t))}get _isTimelineOpen(){return!!this._timeline}_emitUpdate(){this.emit("change"),this._emitCollectionChange(this)}openTimeline(e=null){return this._platform.logger.wrapOrRun(e,"open timeline",async t=>{if(t.set("id",this.id),this._timeline)throw new Error("not dealing with load race here for now");this._timeline=new rt({roomId:this.id,storage:this._storage,fragmentIdComparer:this._fragmentIdComparer,pendingEvents:this._getPendingEvents(),closeCallback:()=>{this._timeline=null,this._roomEncryption&&this._roomEncryption.notifyTimelineClosed()},clock:this._platform.clock,logger:this._platform.logger,powerLevelsObservable:await this.observePowerLevels(),hsApi:this._hsApi});try{this._roomEncryption&&this._timeline.enableEncryption(this._decryptEntries.bind(this,ae.Timeline)),await this._timeline.load(this._user,this.membership,t)}catch(s){throw this._timeline.dispose(),s}return this._timeline})}_getPendingEvents(){return null}observeEvent(e){this._observedEvents||(this._observedEvents=new So(()=>{this._observedEvents=null}));let t=null;this._timeline&&(t=this._timeline.getByEventId(e));const s=this._observedEvents.observe(e,t);return t||this._readEventById(e).then(i=>{s.update(i)}).catch(i=>{console.warn(`could not load event ${e} from storage`,i)}),s}async _readEventById(e){return await new Ys({roomId:this._roomId,storage:this._storage,fragmentIdComparer:this._fragmentIdComparer}).readById(e)}dispose(){this._roomEncryption?.dispose(),this._timeline?.dispose()}}class Ao{constructor(e,t){this._cancelled=!1,this.preparation=null,this._promise=t.wrap("decryptEntries",s=>e(this,s))}complete(){return this._promise}get cancelled(){return this._cancelled}dispose(){this._cancelled=!0,this.preparation&&this.preparation.dispose()}}function be(n,e){return Lt(n,e,()=>[],(t,s)=>t.push(s))}function Lt(n,e,t,s){return n.reduce((i,r)=>{const o=e(r);let a=i.get(o);return a||(a=t(),i.set(o,a)),s(a,r),i},new Map)}function Zs(n,e){return n.reduce((t,s)=>{const i=e(s);return t[i]?t[i]+=1:t[i]=1,t},{})}function ot(){return at("t")}function at(n){const t=Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(16);return n+"0".repeat(14-t.length)+t}function ei(n){return n.startsWith("t")&&n.length===15}function qt(n){const e=be(n,s=>s.device.userId);return{messages:Array.from(e.entries()).reduce((s,[i,r])=>(s[i]=r.reduce((o,a)=>(o[a.device.deviceId]=a.content,o),{}),s),{})}}class Ko extends ye{constructor({roomId:e,storage:t,hsApi:s,pendingEvents:i}){super(),i=i||[],this._roomId=e,this._storage=t,this._hsApi=s,this._pendingEvents=new ls((r,o)=>r.queueIndex-o.queueIndex),this._pendingEvents.setManyUnsorted(i.map(r=>this._createPendingEvent(r))),this._isSending=!1,this._offline=!1,this._roomEncryption=null,this._currentQueueIndex=0}addExistingPendingEvent(e){this._pendingEvents.set(this._createPendingEvent(e))}removePendingEvents(e){for(const t of e){const s=this._pendingEvents.array.findIndex(i=>i.remoteId===t.remoteId);if(s!==-1){const i=this._pendingEvents.get(s);this._pendingEvents.remove(s),i.dispose()}}}_createPendingEvent(e,t=null){const s=new Gr({data:e,remove:()=>this._removeEvent(s),emitUpdate:i=>this._pendingEvents.update(s,i),attachments:t});return s}enableEncryption(e){this._roomEncryption=e}_sendLoop(e){this._isSending=!0,this._sendLoopLogItem=e.runDetached("send queue flush",async t=>{try{for(const s of this._pendingEvents)await t.wrap("send event",async i=>{i.set("queueIndex",s.queueIndex);try{this._currentQueueIndex=s.queueIndex,await this._sendEvent(s,i),this.emit("pendingEvent",s)}catch(r){r instanceof Y?(this._offline=!0,i.set("offline",!0),s.setWaiting()):(i.catch(r),r.name==="HomeServerError"&&(r.statusCode===400||r.statusCode===403||r.statusCode===404)?(i.set("remove",!0),await s.abort()):s.setError(r))}finally{this._currentQueueIndex=0}})}finally{this._isSending=!1,this._sendLoopLogItem=null}})}async _sendEvent(e,t){if(e.needsUpload&&(await t.wrap("upload attachments",s=>e.uploadAttachments(this._hsApi,s)),await this._tryUpdateEvent(e)),e.needsEncryption){e.setEncrypting();const s=e.contentForEncryption,{type:i,content:r}=await t.wrap("encrypt",o=>this._roomEncryption.encrypt(e.eventType,s,this._hsApi,o));e.setEncrypted(i,r),await this._tryUpdateEvent(e)}if(e.needsSending){await e.send(this._hsApi,t);const s=await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);try{await this._tryUpdateEventWithTxn(e,s),await this._resolveRemoteIdInPendingRelations(e.txnId,e.remoteId,s)}catch(i){throw s.abort(),i}await s.complete()}}async _resolveRemoteIdInPendingRelations(e,t,s){const i=this._pendingEvents.array.filter(r=>r.relatedTxnId===e&&r.relatedEventId!==t);for(const r of i)r.setRelatedEventId(t),await this._tryUpdateEventWithTxn(r,s);return i}async removeRemoteEchos(e,t,s){const i=[];for(const r of e){const o=r.unsigned&&r.unsigned.transaction_id;let a;if(o?a=this._pendingEvents.array.findIndex(c=>c.txnId===o):a=this._pendingEvents.array.findIndex(c=>c.remoteId===r.event_id),a!==-1){const c=this._pendingEvents.get(a),d=r.event_id;s.log({l:"removeRemoteEcho",queueIndex:c.queueIndex,remoteId:d,txnId:o}),t.pendingEvents.remove(c.roomId,c.queueIndex),i.push(c),await this._resolveRemoteIdInPendingRelations(o,d,t)}}return i}async _removeEvent(e){if(this._pendingEvents.array.indexOf(e)!==-1){const s=await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);try{s.pendingEvents.remove(e.roomId,e.queueIndex)}catch{s.abort()}await s.complete();const i=this._pendingEvents.array.indexOf(e);i!==-1&&this._pendingEvents.remove(i)}e.dispose()}emitRemovals(e){for(const t of e){const s=this._pendingEvents.array.indexOf(t);s!==-1&&this._pendingEvents.remove(s),t.dispose()}}resumeSending(e){this._offline=!1,this._pendingEvents.length&&e.wrap("resumeSending",t=>{t.set("id",this._roomId),t.set("pendingEvents",this._pendingEvents.length),this._isSending||this._sendLoop(t),this._sendLoopLogItem&&t.refDetached(this._sendLoopLogItem)})}async enqueueEvent(e,t,s,i){const r=Z(t);let o=null;if(r){const a=Mt(r);if(ei(a)&&(o=a,Is(r,null)),r.rel_type===X&&this._pendingEvents.array.some(d=>{const h=Z(d.content);return d.eventType===e&&h&&h.key===r.key&&(d.relatedTxnId===o||h.event_id===r.event_id)})){i.set("already_annotating",!0);return}}await this._enqueueEvent(e,t,s,o,null,i)}async _enqueueEvent(e,t,s,i,r,o){const a=await this._createAndStoreEvent(e,t,i,r,s);this._pendingEvents.set(a),o.set("queueIndex",a.queueIndex),o.set("pendingEvents",this._pendingEvents.length),!this._isSending&&!this._offline&&this._sendLoop(o),this._sendLoopLogItem&&o.refDetached(this._sendLoopLogItem)}async enqueueRedaction(e,t,s){if(this._pendingEvents.array.some(a=>a.eventType===j&&(a.relatedTxnId===e||a.relatedEventId===e))){s.set("already_redacting",!0);return}let r,o;if(ei(e)){r=e;const a=e,c=this._pendingEvents.array.find(d=>d.txnId===a);if(c&&!c.remoteId&&c.status!==P.Sending){s.set("remove",r),await c.abort();return}else if(c)o=c.remoteId;else return}else{o=e;const a=this._pendingEvents.array.find(c=>c.remoteId===o);a&&(r=a.txnId)}s.set("relatedTxnId",r),s.set("relatedEventId",o),await this._enqueueEvent(j,{reason:t},null,r,o,s)}get pendingEvents(){return this._pendingEvents}async _tryUpdateEvent(e){const t=await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);try{this._tryUpdateEventWithTxn(e,t)}catch(s){throw t.abort(),s}await t.complete()}async _tryUpdateEventWithTxn(e,t){await t.pendingEvents.exists(e.roomId,e.queueIndex)&&t.pendingEvents.update(e.data)}async _createAndStoreEvent(e,t,s,i,r){const o=await this._storage.readWriteTxn([this._storage.storeNames.pendingEvents]);let a;try{const c=o.pendingEvents,d=await c.getMaxQueueIndex(this._roomId)||0,l=Math.max(d,this._currentQueueIndex)+1,u=e!==j&&e!==Pr&&!!this._roomEncryption;a=this._createPendingEvent({roomId:this._roomId,queueIndex:l,eventType:e,content:t,relatedTxnId:s,relatedEventId:i,txnId:ot(),needsEncryption:u,needsUpload:!!r},r),c.add(a.data)}catch(c){throw o.abort(),c}return await o.complete(),a}dispose(){for(const e of this._pendingEvents)e.dispose()}}async function xo(n,e,t){if(t===void 0||t.key===void 0||t.iv===void 0||t.hashes===void 0||t.hashes.sha256===void 0)throw new Error("Invalid info. Missing info.key, info.iv or info.hashes.sha256 key");const{crypto:s}=n,{base64:i}=n.encoding;var r=i.decode(t.iv),o=i.encode(i.decode(t.hashes.sha256));const a=await s.digest("SHA-256",e);if(i.encode(new Uint8Array(a))!=o)throw new Error("Mismatched SHA-256 digest");var c;return t.v=="v1"||t.v=="v2"?c=64:c=128,await s.aes.decryptCTR({jwkKey:t.key,iv:r,data:e,counterLength:c})}async function Do(n,e){const{crypto:t}=n,{base64:s}=n.encoding,i=await t.aes.generateIV(),r=await t.aes.generateKey("jwk",256),o=await e.readAsBuffer(),a=await t.aes.encryptCTR({jwkKey:r,iv:i,data:o}),c=await t.digest("SHA-256",a);return{blob:n.createBlob(a,"application/octet-stream"),info:{v:"v2",key:r,iv:s.encodeUnpadded(i),hashes:{sha256:s.encodeUnpadded(c)}}}}class ti{constructor({filename:e,blob:t,platform:s}){this._filename=e,this._unencryptedBlob=t,this._transferredBlob=this._unencryptedBlob,this._platform=s,this._mxcUrl=null,this._encryptionInfo=null,this._uploadRequest=null,this._aborted=!1,this._error=null,this._sentBytes=0}get size(){return this._transferredBlob.size}get sentBytes(){return this._sentBytes}abort(){this._uploadRequest?.abort()}get localPreview(){return this._unencryptedBlob}async encrypt(){if(this._encryptionInfo)throw new Error("already encrypted");const{info:e,blob:t}=await Do(this._platform,this._transferredBlob);this._transferredBlob=t,this._encryptionInfo=e}async upload(e,t,s){this._uploadRequest=e.uploadAttachment(this._transferredBlob,this._filename,{uploadProgress:r=>{this._sentBytes=r,t()},log:s});const{content_uri:i}=await this._uploadRequest.response();this._mxcUrl=i}applyToContent(e,t){if(!this._mxcUrl)throw new Error("upload has not finished");let s=e.substr(0,e.lastIndexOf("url"));ct(`${s}info.size`,t,this._transferredBlob.size),ct(`${s}info.mimetype`,t,this._unencryptedBlob.mimeType),this._encryptionInfo?ct(`${s}file`,t,Object.assign(this._encryptionInfo,{mimetype:this._unencryptedBlob.mimeType,url:this._mxcUrl})):ct(`${s}url`,t,this._mxcUrl)}dispose(){this._unencryptedBlob.dispose(),this._transferredBlob.dispose()}}function ct(n,e,t){const s=n.split(".");let i=e;for(let o=0;o<s.length-1;o+=1){const a=s[o];i[a]||(i[a]={}),i=i[a]}const r=s[s.length-1];i[r]=t}const Uo="m.room.encrypted";class si extends Xs{constructor(e){super(e),this._roomStateHandler=e.roomStateHandler,this._sendQueue=e.sendQueue;const t=new Vs({roomId:this.id,fragmentIdComparer:this._fragmentIdComparer,ownUserId:this._user.id});this._syncWriter=new oo({roomId:this.id,fragmentIdComparer:this._fragmentIdComparer,relationWriter:t,memberWriter:new ao(this.id)})}_setEncryption(e){return super._setEncryption(e)?(this._sendQueue.enableEncryption(this._roomEncryption),!0):!1}get sendQueue(){return this._sendQueue}async prepareSync(e,t,s,i,r){r.set("id",this.id),s&&r.set("newKeys",s.length);let o=this._summary.data.applySyncResponse(e,t,this._user.id),a=this._roomEncryption;!a&&o.encryption&&(r.set("enableEncryption",!0),a=this._createRoomEncryption(this,o.encryption));let c,d;if(a){let h=e?.timeline?.events||[];s&&(c=await this._getSyncRetryDecryptEntries(s,a,i),c.length&&(r.set("retry",c.length),h=h.concat(c.map(l=>l.event)))),h=h.filter(l=>l?.type===Uo),h.length&&(d=await a.prepareDecryptAll(h,s,ae.Sync,i))}return{roomEncryption:a,summaryChanges:o,decryptPreparation:d,decryptChanges:null,retryEntries:c}}async afterPrepareSync(e,t){e.decryptPreparation&&await t.wrap("decrypt",async s=>{s.set("id",this.id),e.decryptChanges=await e.decryptPreparation.decrypt(),e.decryptPreparation=null},t.level.Detail)}async writeSync(e,t,{summaryChanges:s,decryptChanges:i,roomEncryption:r,retryEntries:o},a,c){c.set("id",this.id);const d=s.isNewJoin(this._summary.data);d&&(a.roomState.removeAllForRoom(this.id),a.roomMembers.removeAllForRoom(this.id));const{entries:h,updatedEntries:l,newLiveKey:u,memberChanges:p,memberSync:m}=await c.wrap("syncWriter",os=>this._syncWriter.writeSync(e,d,s.hasFetchedMembers,a,os),c.level.Detail);let _;i&&(_=await c.wrap("decryptChanges",os=>i.write(a,os)),c.set("decryptionResults",_.results.size),c.set("decryptionErrors",_.errors.size),this._isTimelineOpen&&await _.verifyKnownSenders(a),_.applyToEntries(h),o?.length&&(_.applyToEntries(o),l.push(...o))),c.set("newEntries",h.length),c.set("updatedEntries",l.length);let g;r&&(g=await r.writeSync(e,p,a,c),c.set("shouldFlushKeyShares",g.shouldFlush));const R=h.concat(l);s=s.applyTimelineEntries(R,t,!this._isTimelineOpen,this._user.id),s.membership!=="join"?a.roomSummary.remove(this.id):s=this._summary.writeData(s,a),s&&c.set("summaryChanges",s.changedKeys(this._summary.data));let _e;s?.needsHeroes&&(this._heroes||(this._heroes=new Bt(this._roomId)),_e=await this._heroes.calculateChanges(s.heroes,p,a));let Ni;Array.isArray(e.timeline?.events)&&(Ni=await this._sendQueue.removeRemoteEchos(e.timeline.events,a,c));const Tc=this._getPowerLevelsEvent(e);return await this._runRoomStateHandlers(e,m,a,c),{roomResponse:e,summaryChanges:s,roomEncryption:r,newEntries:h,updatedEntries:l,newLiveKey:u,removedPendingEvents:Ni,memberChanges:p,heroChanges:_e,powerLevelsEvent:Tc,encryptionChanges:g,decryption:_}}afterSync(e,t){const{summaryChanges:s,newEntries:i,updatedEntries:r,newLiveKey:o,removedPendingEvents:a,memberChanges:c,powerLevelsEvent:d,heroChanges:h,roomEncryption:l,roomResponse:u,encryptionChanges:p}=e;if(t.set("id",this.id),this._syncWriter.afterSync(o),this._setEncryption(l),this._roomEncryption&&this._roomEncryption.afterSync(p),c.size){if(this._changedMembersDuringSync)for(const[_,g]of c.entries())this._changedMembersDuringSync.set(_,g.member);if(this._memberList&&this._memberList.afterSync(c),this._roomStateHandler.updateRoomMembers(this,c),this._observedMembers&&this._updateObservedMembers(c),this._timeline){for(const[_,g]of c.entries())if(_===this._user.id){this._timeline.updateOwnMember(g.member);break}}}let m=!1;if(s&&(this._summary.applyChanges(s),this._summary.data.needsHeroes||(this._heroes=null),m=!0),this._heroes&&h){const _=this.name;this._heroes.applyChanges(h,this._summary.data,t),_!==this.name&&(m=!0)}d&&this._updatePowerLevels(d),m&&this._emitUpdate(),this._timeline&&(this._timeline.replaceEntries(r),this._timeline.addEntries(i)),this._observedEvents&&(this._observedEvents.updateEvents(r),this._observedEvents.updateEvents(i)),a&&this._sendQueue.emitRemovals(a),this._emitSyncRoomState(u)}_updateObservedMembers(e){for(const[t,s]of e){const i=this._observedMembers.get(t);i&&i.set(s.member)}}_getPowerLevelsEvent(e){let t;return ge(e,s=>{s.state_key===""&&s.type===ko&&(t=s)}),t}_updatePowerLevels(e){if(this._powerLevels){const t=new nt({powerLevelEvent:e,ownUserId:this._user.id,membership:this.membership});this._powerLevels.set(t)}}async afterSyncCompleted({encryptionChanges:e,decryption:t,newEntries:s,updatedEntries:i},r){const o=e?.shouldFlush,a=this._isTimelineOpen&&t?.hasUnverifiedSenders;(o||a)&&await r.wrap({l:"room",id:this.id},async c=>{const d=[];if(o&&d.push(this._roomEncryption.flushPendingRoomKeyShares(this._hsApi,null,c)),a){const h=c.wrap("verify senders",async l=>{const u=await t.fetchAndVerifyRemainingSenders(this._hsApi,l),p=[],m=_=>p.push(_);u.applyToEntries(s,m),u.applyToEntries(i,m),l.set("verifiedEntries",p.length),this._timeline?.replaceEntries(p),this._observedEvents?.updateEvents(p)});d.push(h)}await Promise.all(d)})}start(e,t){if(this._roomEncryption){const s=e?.get("share_room_key");s&&t.wrapDetached("flush room keys",i=>(i.set("id",this.id),this._roomEncryption.flushPendingRoomKeyShares(this._hsApi,s,i)))}this._sendQueue.resumeSending(t)}async load(e,t,s){try{await super.load(e,t,s),await this._syncWriter.load(t,s)}catch(i){throw new cs(`Could not load room ${this._roomId}`,i)}}async _writeGapFill(e,t,s){return await this._sendQueue.removeRemoteEchos(e,t,s)}_applyGapFill(e){this._sendQueue.emitRemovals(e)}sendEvent(e,t,s,i=null){return this._platform.logger.wrapOrRun(i,"send",r=>(r.set("id",this.id),this._sendQueue.enqueueEvent(e,t,s,r)))}sendRedaction(e,t,s=null){return this._platform.logger.wrapOrRun(s,"redact",i=>(i.set("id",this.id),this._sendQueue.enqueueRedaction(e,t,i)))}async ensureMessageKeyIsShared(e=null){if(!!this._roomEncryption)return this._platform.logger.wrapOrRun(e,"ensureMessageKeyIsShared",t=>(t.set("id",this.id),this._roomEncryption.ensureMessageKeyIsShared(this._hsApi,t)))}get avatarColorId(){return this._heroes?.roomAvatarColorId||this._roomId}get isUnread(){return this._summary.data.isUnread}get notificationCount(){return this._summary.data.notificationCount}get highlightCount(){return this._summary.data.highlightCount}get isTrackingMembers(){return this._summary.data.isTrackingMembers}async _getLastEventId(){const e=this._syncWriter.lastMessageKey;if(e)return(await(await this._storage.readTxn([this._storage.storeNames.timelineEvents])).timelineEvents.get(this._roomId,e))?.event?.event_id}async clearUnread(e=null){if(this.isUnread||this.notificationCount)return await this._platform.logger.wrapOrRun(e,"clearUnread",async t=>{t.set("id",this.id);const s=await this._storage.readWriteTxn([this._storage.storeNames.roomSummary]);let i;try{i=this._summary.writeClearUnread(s)}catch(r){throw s.abort(),r}await s.complete(),this._summary.applyChanges(i),this._emitUpdate();try{const r=await this._getLastEventId();r&&await this._hsApi.receipt(this._roomId,"m.read",r)}catch(r){if(r.name!=="ConnectionError")throw r}})}leave(e=null){return this._platform.logger.wrapOrRun(e,"leave room",async t=>{t.set("id",this.id),await this._hsApi.leave(this.id,{log:t}).response()})}_getPendingEvents(){return this._sendQueue.pendingEvents}_runRoomStateHandlers(e,t,s,i){const r=[];return ge(e,o=>{r.push(this._roomStateHandler.handleRoomState(this,o,t,s,i))}),Promise.all(r)}_emitSyncRoomState(e){ge(e,t=>{for(const s of this._roomStateObservers)s.handleStateEvent(t)})}writeIsTrackingMembers(e,t){return this._summary.writeIsTrackingMembers(e,t)}applyIsTrackingMembersChanges(e){this._summary.applyChanges(e)}createAttachment(e,t){return new ti({blob:e,filename:t,platform:this._platform})}dispose(){super.dispose(),this._sendQueue.dispose()}}class Fo extends Xs{constructor(e){super(e),this._releaseCallback=e.releaseCallback,this._forgetCallback=e.forgetCallback,this._retentionCount=1,this._kickDetails=null,this._kickedBy=null}retain(){this._retentionCount+=1}release(){this._retentionCount-=1,this._retentionCount===0&&this._releaseCallback()}async _getKickAuthor(e,t){const s=await t.roomMembers.get(this.id,e);return s?new v(s):v.fromUserId(this.id,e,"join")}async load(e,t,s){const{summary:i,kickDetails:r}=e;return this._kickDetails=r,this._kickDetails&&(this._kickedBy=await this._getKickAuthor(this._kickDetails.sender,t)),super.load(i,t,s)}async writeSync(e,t,s,i,r){if(r.set("id",this.id),s==="leave"){const o=Po(t,this._user.id);if(o||e){const a=o||this._kickDetails;let c;o&&(c=await this._getKickAuthor(o.sender,i));const d=e||this._summary.data;return i.archivedRoomSummary.set({summary:d.serialize(),kickDetails:a}),{kickDetails:a,kickedBy:c,summaryData:d}}}else s==="join"&&i.archivedRoomSummary.remove(this.id);return{}}afterSync({summaryData:e,kickDetails:t,kickedBy:s},i){i.set("id",this.id),e&&this._summary.applyChanges(e),t&&(this._kickDetails=t),s&&(this._kickedBy=s),this._emitUpdate()}get isKicked(){return this._kickDetails?.membership==="leave"}get isBanned(){return this._kickDetails?.membership==="ban"}get kickedBy(){return this._kickedBy}get kickReason(){return this._kickDetails?.reason}isArchived(){return!0}forget(e=null){return this._platform.logger.wrapOrRun(e,"forget room",async t=>{t.set("id",this.id),await this._hsApi.forget(this.id,{log:t}).response();const s=this._storage.storeNames,i=await this._storage.readWriteTxn([s.roomState,s.archivedRoomSummary,s.roomMembers,s.timelineEvents,s.timelineFragments,s.timelineRelations,s.pendingEvents,s.inboundGroupSessions,s.groupSessionDecryptions,s.operations]);i.roomState.removeAllForRoom(this.id),i.archivedRoomSummary.remove(this.id),i.roomMembers.removeAllForRoom(this.id),i.timelineEvents.removeAllForRoom(this.id),i.timelineFragments.removeAllForRoom(this.id),i.timelineRelations.removeAllForRoom(this.id),i.pendingEvents.removeAllForRoom(this.id),i.inboundGroupSessions.removeAllForRoom(this.id),i.groupSessionDecryptions.removeAllForRoom(this.id),await i.operations.removeAllForScope(this.id),await i.complete(),this._retentionCount=0,this._releaseCallback(),this._forgetCallback(this.id)})}join(e=null){return this._platform.logger.wrapOrRun(e,"rejoin archived room",async t=>{await this._hsApi.join(this.id,{log:t}).response()})}}function Po(n,e){let t;if(ge(n,s=>{s.type===D&&s.state_key===e&&s.sender!==s.state_key&&(t=s)}),t)return{membership:t.content?.membership,reason:t.content?.reason,sender:t.sender}}async function Oo(n,e,t){const s=await Promise.all(n.map(async i=>{const r=await e.profile(i,{log:t}).response();return new No(i,r.displayname,r.avatar_url)}));return s.sort((i,r)=>i.name.localeCompare(r.name)),s}class No{constructor(e,t,s){this.userId=e,this.displayName=t,this.avatarUrl=s}get name(){return this.displayName||this.userId}}class Bo{constructor(e){this.userId=e}get displayName(){}get name(){return this.userId}get avatarUrl(){}}function Lo(n){switch(n){case V.DirectMessage:case V.Private:return!0;case V.Public:return!1}}function qo(n){switch(n){case V.DirectMessage:return"trusted_private_chat";case V.Private:return"private_chat";case V.Public:return"public_chat"}}class jo extends ye{constructor(e,t,s,i,r,o){if(super(),this.id=e,this.options=t,this.updateCallback=s,this.mediaRepository=i,this.platform=r,this.profiles=[],this._isCancelled=!1,this.isEncrypted=t.isEncrypted===void 0?Lo(t.type):t.isEncrypted,t.name)this._calculatedName=t.name;else{const a={joinCount:1,inviteCount:t.invites?.length||0},c=(t.invites||[]).map(d=>new Bo(d));this._calculatedName=Nt(c,a,o)}}async create(e,t){try{let s;if(this.options.avatar){const{avatar:o}=this.options,a=new ti({filename:o.name,blob:o.blob,platform:this.platform});await a.upload(e,()=>{},t),s={info:o.info},a.applyToContent("url",s)}const i={is_direct:this.options.type===V.DirectMessage,preset:qo(this.options.type),initial_state:[]};this.options.name&&(i.name=this.options.name),this.options.topic&&(i.topic=this.options.topic),this.options.invites&&(i.invite=this.options.invites),this.options.alias&&(i.room_alias_name=this.options.alias),this.options.isFederationDisabled===!0&&(i.creation_content={"m.federate":!1}),this.options.powerLevelContentOverride&&(i.power_level_content_override=this.options.powerLevelContentOverride),this.isEncrypted&&i.initial_state.push(Cr()),s&&i.initial_state.push({type:"m.room.avatar",state_key:"",content:s});const r=await e.createRoom(i,{log:t}).response();this._roomId=r.room_id}catch(s){this._error=s}this.emitChange()}async loadProfiles(e,t){try{if(!this.options.name&&this.options.invites){this.profiles=await Oo(this.options.invites,e,t);const s={joinCount:1,inviteCount:this.options.invites.length};this._calculatedName=Nt(this.profiles,s,t),this.emitChange()}}catch{}}emitChange(e){this.updateCallback(this,e),this.emit("change")}get avatarColorId(){return this.options.invites?.[0]??this._roomId??this.id}get avatarUrl(){return this.profiles?.[0]?.avatarUrl}get avatarBlobUrl(){return this.options.avatar?.blob?.url}get roomId(){return this._roomId}get name(){return this._calculatedName}get isBeingCreated(){return!0}get error(){return this._error}cancel(){this._isCancelled||(this.dispose(),this._isCancelled=!0,this.emitChange("isCancelled"))}get isCancelled(){return this._isCancelled}dispose(){this.options.avatar&&this.options.avatar.blob.dispose()}async adjustDirectMessageMapIfNeeded(e,t,s,i){if(!this.options.invites||this.options.type!==V.DirectMessage)return;const r=this.options.invites[0],o="m.direct";await i.wrap("set "+o,async a=>{try{const c=await t.readWriteTxn([t.storeNames.accountData]);let d;try{d=await c.accountData.get(o),d||(d={type:o,content:{}});const h=d.content;let l=h[r];l||(h[r]=l=[]),l.push(this._roomId),c.accountData.set(d),await c.complete()}catch(h){throw c.abort(),h}await s.setAccountData(e.id,o,d.content,{log:a}).response()}catch(c){a.catch(c)}})}}class $o extends ye{constructor({roomId:e,user:t,hsApi:s,mediaRepository:i,emitCollectionRemove:r,emitCollectionUpdate:o,platform:a}){super(),this._roomId=e,this._user=t,this._hsApi=s,this._emitCollectionRemove=r,this._emitCollectionUpdate=o,this._mediaRepository=i,this._platform=a,this._inviteData=null,this._accepting=!1,this._rejecting=!1,this._accepted=!1,this._rejected=!1}get isInvite(){return!0}get id(){return this._roomId}get name(){return this._inviteData.name||this._inviteData.canonicalAlias}get isDirectMessage(){return this._inviteData.isDirectMessage}get avatarUrl(){return this._inviteData.avatarUrl}get avatarColorId(){return this._inviteData.avatarColorId||this.id}get timestamp(){return this._inviteData.timestamp}get isEncrypted(){return this._inviteData.isEncrypted}get inviter(){return this._inviter}isDirectMessageForUserId(e){return this.isDirectMessage&&this._inviter.userId===e}get isPublic(){return this._inviteData.joinRule==="public"}get canonicalAlias(){return this._inviteData.canonicalAlias}async accept(e=null){await this._platform.logger.wrapOrRun(e,"acceptInvite",async t=>{this._accepting=!0,this._emitChange("accepting"),await this._hsApi.join(this._roomId,{log:t}).response()})}async reject(e=null){await this._platform.logger.wrapOrRun(e,"rejectInvite",async t=>{this._rejecting=!0,this._emitChange("rejecting"),await this._hsApi.leave(this._roomId,{log:t}).response()})}get accepting(){return this._accepting}get accepted(){return this._accepted}get rejecting(){return this._rejecting}get rejected(){return this._rejected}get mediaRepository(){return this._mediaRepository}_emitChange(e){this.emit("change"),this._emitCollectionUpdate(this,e)}load(e,t){t.set("id",this.id),this._inviteData=e,this._inviter=e.inviter?new v(e.inviter):null}async writeSync(e,t,s,i){if(e==="invite"){i.set("id",this.id),i.set("add",!0);const r=t.invite_state?.events;if(!Array.isArray(r))return null;const o=this._createSummaryData(r);let a;!o.name&&!o.canonicalAlias&&(a=await this._createHeroes(r,i));const c=this._getMyInvite(r);if(!c)return null;const d=this._getInviter(c,r),h=this._createData(r,c,d,o,a);return s.invites.set(h),{inviteData:h,inviter:d}}else return i.set("id",this.id),i.set("membership",e),s.invites.remove(this.id),{removed:!0,membership:e}}afterSync(e,t){t.set("id",this.id),e&&(e.removed?(this._accepting=!1,this._rejecting=!1,e.membership==="join"?this._accepted=!0:this._rejected=!0,this.emit("change")):(this._inviteData=e.inviteData,this._inviter=e.inviter))}_createData(e,t,s,i,r){const o=r?r.roomName:i.name,a=r?r.roomAvatarUrl:i.avatarUrl,c=r?.roomAvatarColorId||this.id;return{roomId:this.id,isEncrypted:!!i.encryption,isDirectMessage:i.isDirectMessage,name:o,avatarUrl:a,avatarColorId:c,canonicalAlias:i.canonicalAlias,timestamp:this._platform.clock.now(),joinRule:this._getJoinRule(e),inviter:s?.serialize()}}_createSummaryData(e){return e.reduce((t,s)=>ws(t,s,this._user.id),new H(null,this.id))}async _createHeroes(e,t){const s=e.filter(h=>h.type===D),i=s.filter(h=>h.state_key!==this._user.id),r=i.reduce((h,l)=>{const u=v.fromMemberEvent(this.id,l);return h.set(u.userId,new ks(u,null)),h},new Map),o=i.map(h=>h.state_key),a=new Bt(this.id),c=await a.calculateChanges(o,r,null),d=new H(null,this.id);return d.joinCount=s.reduce((h,l)=>h+(l.content?.membership==="join"?1:0),0),d.inviteCount=s.reduce((h,l)=>h+(l.content?.membership==="invite"?1:0),0),a.applyChanges(c,d,t),a}_getMyInvite(e){return e.find(t=>t.type===D&&t.state_key===this._user.id)}_getInviter(e,t){const s=t.find(i=>i.type===D&&i.state_key===e.sender);if(s)return v.fromMemberEvent(this.id,s)}_getJoinRule(e){const t=e.find(s=>s.type==="m.room.join_rules");return t?t.content?.join_rule:null}}class he{constructor(e){this._description=e}static httpPusher(e,t,s,i){return new he({kind:"http",append:!0,data:Object.assign({},i,{url:e+"/_matrix/push/v1/notify"}),pushkey:s,app_id:t,app_display_name:"Hydrogen",device_display_name:"Hydrogen",lang:"en"})}static createDefaultPayload(e){return{session_id:e}}async enable(e,t){try{t.set("endpoint",new URL(this._description.data.endpoint).host)}catch{t.set("endpoint",null)}await e.setPusher(this._description,{log:t}).response()}async disable(e,t){const s=Object.assign({},this._description,{kind:null});await e.setPusher(s,{log:t}).response()}serialize(){return this._description}equals(e){return this._description.app_id!==e._description.app_id||this._description.pushkey!==e._description.pushkey?!1:JSON.stringify(this._description.data)===JSON.stringify(e._description.data)}}class Wo{constructor({storage:e,callHandler:t}){this._storage=e,this._olmDecryption=null,this._megolmDecryption=null,this._callHandler=t,this._senderDeviceCache=new zs(10,s=>s.curve25519Key)}enableEncryption({olmDecryption:e,megolmDecryption:t}){this._olmDecryption=e,this._megolmDecryption=t}obtainSyncLock(e){return this._olmDecryption?.obtainDecryptionLock(e)}async prepareSync(e,t,s,i){i.set("messageTypes",Zs(e,a=>a.type));const r=e.filter(a=>a.type==="m.room.encrypted");if(!this._olmDecryption){i.log("can't decrypt, encryption not enabled",i.level.Warn);return}const o=r.filter(a=>a.content?.algorithm===It);if(o.length){const a=await this._olmDecryption.decryptAll(o,t,s);i.set("decryptedTypes",Zs(a.results,d=>d.event?.type));for(const d of a.errors)i.child("decrypt_error").catch(d);const c=this._megolmDecryption.roomKeysFromDeviceMessages(a.results,i);return new Go(a,c)}}async writeSync(e,t){return e.olmDecryptChanges.write(t),{hasNewRoomKeys:(await Promise.all(e.newRoomKeys.map(r=>this._megolmDecryption.writeRoomKey(r,t)))).some(r=>!!r),decryptionResults:e.olmDecryptChanges.results}}async afterSyncCompleted(e,t,s,i){if(this._callHandler){const r=e.filter(o=>this._callHandler.handlesDeviceMessageEventType(o.event?.type));r.length&&await i.wrap("process call signalling messages",async o=>{for(const a of r){const c=await t.deviceForId(a.event.sender,a.event.content.device_id,s,o);a.setDevice(c),a.isVerified?this._callHandler.handleDeviceMessage(a.event,a.userId,a.deviceId,o):o.log({l:"could not verify olm fingerprint key matches, ignoring",ed25519Key:a.device.ed25519Key,claimedEd25519Key:a.claimedEd25519Key,deviceId:c.deviceId,userId:c.userId})}})}}}class Go{constructor(e,t){this.olmDecryptChanges=e,this.newRoomKeys=t,this.newKeysByRoom=be(t,s=>s.roomId)}}const xe=U+"olmAccount",jt=U+"areDeviceKeysUploaded",dt=U+"serverOTKCount";async function ii(n,e,t,s,i){const r=n.pickle(e),o=await i.readWriteTxn([i.storeNames.session]);try{o.session.add(xe,r),o.session.add(jt,t),o.session.add(dt,s)}catch(a){throw o.abort(),a}await o.complete()}class le{static async load({olm:e,pickleKey:t,hsApi:s,userId:i,deviceId:r,olmWorker:o,txn:a}){const c=await a.session.get(xe);if(c){const d=new e.Account,h=await a.session.get(jt);d.unpickle(t,c);const l=await a.session.get(dt);return new le({pickleKey:t,hsApi:s,account:d,userId:i,deviceId:r,areDeviceKeysUploaded:h,serverOTKCount:l,olm:e,olmWorker:o})}}static async adoptDehydratedDevice({olm:e,dehydratedDevice:t,pickleKey:s,hsApi:i,userId:r,olmWorker:o,storage:a}){const c=t.adoptUnpickledOlmAccount(),d=JSON.parse(c.one_time_keys()),l=Object.entries(d.curve25519).length,u=!0;return await ii(c,s,u,l,a),new le({pickleKey:s,hsApi:i,account:c,userId:r,deviceId:t.deviceId,areDeviceKeysUploaded:u,serverOTKCount:l,olm:e,olmWorker:o})}static async create({olm:e,pickleKey:t,hsApi:s,userId:i,deviceId:r,olmWorker:o,storage:a}){const c=new e.Account;o?await o.createAccountAndOTKs(c,c.max_number_of_one_time_keys()):(c.create(),c.generate_one_time_keys(c.max_number_of_one_time_keys()));const d=!1,h=0;return a&&await ii(c,t,d,h,a),new le({pickleKey:t,hsApi:s,account:c,userId:i,deviceId:r,areDeviceKeysUploaded:d,serverOTKCount:h,olm:e,olmWorker:o})}constructor({pickleKey:e,hsApi:t,account:s,userId:i,deviceId:r,areDeviceKeysUploaded:o,serverOTKCount:a,olm:c,olmWorker:d}){this._olm=c,this._pickleKey=e,this._hsApi=t,this._account=s,this._userId=i,this._deviceId=r,this._areDeviceKeysUploaded=o,this._serverOTKCount=a,this._olmWorker=d,this._identityKeys=JSON.parse(this._account.identity_keys())}get identityKeys(){return this._identityKeys}setDeviceId(e){this._deviceId=e}async uploadKeys(e,t,s){const i=JSON.parse(this._account.one_time_keys()),r=Object.entries(i.curve25519);if(r.length||!this._areDeviceKeysUploaded){const o={};if(!this._areDeviceKeysUploaded){s.set("identity",!0);const d=JSON.parse(this._account.identity_keys());o.device_keys=this._deviceKeysPayload(d)}r.length&&(s.set("otks",!0),o.one_time_keys=this._oneTimeKeysPayload(r));const a=t?this._deviceId:void 0,c=await this._hsApi.uploadKeys(a,o,{log:s}).response();this._serverOTKCount=c?.one_time_key_counts?.signed_curve25519,s.set("serverOTKCount",this._serverOTKCount),await this._updateSessionStorage(e,d=>{r.length&&(this._account.mark_keys_as_published(),d?.set(xe,this._account.pickle(this._pickleKey)),d?.set(dt,this._serverOTKCount)),this._areDeviceKeysUploaded||(this._areDeviceKeysUploaded=!0,d?.set(jt,this._areDeviceKeysUploaded))})}}async generateOTKsIfNeeded(e,t){const s=this._account.max_number_of_one_time_keys(),i=Math.floor(s/2);if(this._serverOTKCount<i){const r=JSON.parse(this._account.one_time_keys()),a=Object.entries(r.curve25519).length,c=i-a-this._serverOTKCount;return c>0&&await t.wrap("generate otks",d=>{d.set("max",s),d.set("server",this._serverOTKCount),d.set("unpublished",a),d.set("new",c),d.set("limit",i),this._account.generate_one_time_keys(c),this._updateSessionStorage(e,h=>{h.set(xe,this._account.pickle(this._pickleKey))})}),!0}return!1}createInboundOlmSession(e,t){const s=new this._olm.Session;try{return s.create_inbound_from(this._account,e,t),s}catch(i){throw s.free(),i}}async createOutboundOlmSession(e,t){const s=new this._olm.Session;try{return this._olmWorker?await this._olmWorker.createOutboundOlmSession(this._account,s,e,t):s.create_outbound(this._account,e,t),s}catch(i){throw s.free(),i}}writeRemoveOneTimeKey(e,t){this._account.remove_one_time_keys(e),t.session.set(xe,this._account.pickle(this._pickleKey))}writeSync(e,t,s){const i=e.signed_curve25519;if(Number.isSafeInteger(i)&&i!==this._serverOTKCount)return t.session.set(dt,i),s.set("otkCount",i),i}afterSync(e){Number.isSafeInteger(e)&&(this._serverOTKCount=e)}_keysAsSignableObject(e){const t={user_id:this._userId,device_id:this._deviceId,algorithms:[It,q],keys:{}};for(const[s,i]of Object.entries(e))t.keys[`${s}:${this._deviceId}`]=i;return t}getDeviceKeysToSignWithCrossSigning(){const e=JSON.parse(this._account.identity_keys());return this._keysAsSignableObject(e)}_deviceKeysPayload(e){const t=this._keysAsSignableObject(e);return this.signObject(t),t}_oneTimeKeysPayload(e){const t={};for(const[s,i]of e){const r={key:i};this.signObject(r),t[`signed_curve25519:${s}`]=r}return t}async _updateSessionStorage(e,t){if(e){const s=await e.readWriteTxn([e.storeNames.session]);try{await t(s.session)}catch(i){throw s.abort(),i}await s.complete()}else await t(void 0)}signObject(e){const t=e.signatures||{},s=e.unsigned;delete e.signatures,delete e.unsigned,t[this._userId]=t[this._userId]||{},t[this._userId]["ed25519:"+this._deviceId]=this._account.sign(wt.stringify(e)),e.signatures=t,s!==void 0&&(e.unsigned=s)}pickleWithKey(e){return this._account.pickle(e)}dispose(){this._account.free(),this._account=void 0}}class ri{constructor(e,t){this._id=e,this._keyDescription=t}get id(){return this._id}get passphraseParams(){return this._keyDescription?.passphrase}get algorithm(){return this._keyDescription?.algorithm}async isCompatible(e,t){if(this.algorithm==="m.secret_storage.v1.aes-hmac-sha2"){const s=this._keyDescription;if(s.mac){const i=await Vo(e.binaryKey,s.iv,t);return s.mac===i}else if(s.passphrase){const i=e.description._keyDescription;return i.passphrase?s.passphrase.algorithm===i.passphrase.algorithm&&s.passphrase.iterations===i.passphrase.iterations&&s.passphrase.salt===i.passphrase.salt:!1}}return!1}}class De{constructor(e,t){this._keyDescription=e,this._binaryKey=t}withDescription(e){return new De(e,this._binaryKey)}get description(){return this._keyDescription}get id(){return this._keyDescription.id}get binaryKey(){return this._binaryKey}get algorithm(){return this._keyDescription.algorithm}}async function Vo(n,e,t){const{crypto:s,encoding:i}=t,{utf8:r,base64:o}=i,{derive:a,aes:c,hmac:d}=s,h=o.decode(e),l=new Uint8Array(8),u="\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0",p=r.encode(""),m=await a.hkdf(n,l,p,"SHA-256",512),_=m.slice(0,32),g=m.slice(32),R=await c.encryptCTR({key:_,iv:h,data:r.encode(u)}),_e=await d.compute(g,R,"SHA-256");return o.encode(_e)}const Ho=5e5,zo=256;async function Qo(n,e,t){const{passphraseParams:s}=n;if(!s)throw new Error("not a passphrase key");if(s.algorithm!=="m.pbkdf2")throw new Error(`Unsupported passphrase algorithm: ${s.algorithm}`);const{utf8:i}=t.encoding,r=await t.crypto.derive.pbkdf2(i.encode(e),s.iterations||Ho,i.encode(s.salt),"SHA-512",s.bits||zo);return new De(n,r)}const Ue=[139,1];function Jo(n,e,t,s){const i=s.encoding.base58.decode(e.replace(/ /g,""));let r=0;for(const a of i)r^=a;if(r!==0)throw new Error("Incorrect parity");for(let a=0;a<Ue.length;++a)if(i[a]!==Ue[a])throw new Error("Incorrect prefix");if(i.length!==Ue.length+t.PRIVATE_KEY_LENGTH+1)throw new Error("Incorrect length");const o=Uint8Array.from(i.slice(Ue.length,Ue.length+t.PRIVATE_KEY_LENGTH));return new De(n,o)}const $t=`${U}ssssKey`,ni=`${U}keyBackupVersion`;async function oi(n){const e=await n.readTxn([n.storeNames.accountData]),s=(await e.accountData.get("m.secret_storage.default_key"))?.content?.key;if(!s)return;const i=await e.accountData.get(`m.secret_storage.key.${s}`);if(!!i)return new ri(s,i.content)}async function Yo(n,e,t){const s=await t.session.get(ni);return t.session.set(ni,e),t.session.set($t,{id:n.id,binaryKey:n.binaryKey}),s}async function Xo(n){const e=await n.session.get($t);if(!e)return;const t=await n.accountData.get(`m.secret_storage.key.${e.id}`);if(t)return new De(new ri(e.id,t.content),e.binaryKey)}async function Zo(n){n.session.remove($t)}async function ea(n,e,t,s,i){const r=await oi(t);if(!r)throw new Error("Could not find a default secret storage key in account data");return await ta(n,e,r,s,i)}async function ta(n,e,t,s,i){let r;if(n===1)r=await Qo(t,e,s);else if(n===0)r=Jo(t,e,i,s);else throw new Error(`Invalid type: ${n}`);return r}async function sa(n,e,t){const s=await oi(e);if(await s?.isCompatible(n,t))return n.withDescription(s)}const ia="org.matrix.msc2697.v1.olm.libolm_pickle";async function ra(n,e,t,s,i){const o=(await e.createDehydratedDevice({device_data:{algorithm:ia,account:n.pickleWithKey(t.binaryKey.slice()),passphrase:t.description?.passphraseParams||{}},initial_device_display_name:s}).response()).device_id;return n.setDeviceId(o),await n.uploadKeys(void 0,!0,i),o}class ai{tryTake(){return this._promise?!1:(this._promise=new Promise(e=>{this._resolve=e}),!0)}async take(){for(;!this.tryTake();)await this.released()}get isTaken(){return!!this._promise}release(){if(this._resolve){this._promise=void 0;const e=this._resolve;this._resolve=void 0,e()}}released(){return this._promise}}class ci{constructor(e){this.locks=e}release(){for(const e of this.locks)e.release()}}function di(n,e,t,s){return{session:n.pickle(s),sessionId:n.session_id(),senderKey:e,lastUsed:t}}class ht{constructor(e,t,s,i=!1){this.data=e,this.pickleKey=t,this.olm=s,this.isNew=i,this.isModified=i}static create(e,t,s,i,r){const o=di(t,e,r,i);return new ht(o,i,s,!0)}get id(){return this.data.sessionId}load(){const e=new this.olm.Session;return e.unpickle(this.pickleKey,this.data.session),e}unload(e){e.free()}save(e){this.data.session=e.pickle(this.pickleKey),this.isModified=!0}}class hi{constructor(e,t,s,i){this.event=e,this.senderCurve25519Key=t,this.claimedEd25519Key=s,this.encryptedEvent=i}setDevice(e){this.device=e}get isVerified(){return this.device?this.device.ed25519Key===this.claimedEd25519Key:!1}get isUnverified(){return this.device?!this.isVerified:!0}get userId(){return this.device?.userId}get deviceId(){return this.device?.deviceId}get isVerificationUnknown(){return!this.device}}var lt=(n=>(n[n.PreKey=0]="PreKey",n[n.Normal=1]="Normal",n))(lt||{});const li=4;function ui(n){n.sort((e,t)=>t.data.lastUsed-e.data.lastUsed)}class na{constructor(e,t,s,i,r,o){this.account=e,this.pickleKey=t,this.now=s,this.ownUserId=i,this.olm=r,this.senderKeyLock=o}async obtainDecryptionLock(e){const t=new Set;for(const i of e){const r=i.content?.sender_key;r&&t.add(r)}const s=await Promise.all(Array.from(t).map(i=>this.senderKeyLock.takeLock(i)));return new ci(s)}async decryptAll(e,t,s){try{const i=be(e,h=>h.content?.sender_key),r=this.now(),o=await Promise.all(Array.from(i.entries()).map(([h,l])=>this._decryptAllForSenderKey(h,l,r,s))),a=o.reduce((h,l)=>h.concat(l.results),[]),c=o.reduce((h,l)=>h.concat(l.errors),[]),d=o.map(h=>h.senderKeyDecryption);return new aa(d,a,c,this.account,t)}catch(i){throw t.release(),i}}async _decryptAllForSenderKey(e,t,s,i){const r=await this._getSessions(e,i),o=new oa(e,r,s),a=[],c=[];for(const d of t)try{const h=this._decryptForSenderKey(o,d,s);a.push(h)}catch(h){c.push(h)}return{results:a,errors:c,senderKeyDecryption:o}}_decryptForSenderKey(e,t,s){const i=e.senderKey,r=this._getMessageAndValidateEvent(t);let o;try{o=e.decrypt(r)}catch(a){throw new M("OLM_BAD_ENCRYPTED_MESSAGE",t,{senderKey:i,error:a.message})}if(typeof o!="string"&&r.type===lt.PreKey){let a;try{a=this._createSessionAndDecrypt(i,r,s)}catch(c){throw new M(`Could not create inbound olm session: ${c.message}`,t,{senderKey:i,error:c})}e.addNewSession(a.session),o=a.plaintext}if(typeof o=="string"){let a;try{a=JSON.parse(o)}catch(c){throw new M("PLAINTEXT_NOT_JSON",t,{plaintext:o,error:c})}return this._validatePayload(a,t),new hi(a,i,a.keys.ed25519)}else throw new M("OLM_NO_MATCHING_SESSION",t,{knownSessionIds:e.sessions.map(a=>a.id)})}_createSessionAndDecrypt(e,t,s){let i;const r=this.account.createInboundOlmSession(e,t.body);try{i=r.decrypt(t.type,t.body);const o=ht.create(e,r,this.olm,this.pickleKey,s);return o.unload(r),{session:o,plaintext:i}}catch(o){throw r.free(),o}}_getMessageAndValidateEvent(e){const t=e.content?.ciphertext;if(!t)throw new M("OLM_MISSING_CIPHERTEXT",e);const s=t?.[this.account.identityKeys.curve25519];if(!s)throw new M("OLM_NOT_INCLUDED_IN_RECIPIENTS",e);return s}async _getSessions(e,t){const i=(await t.olmSessions.getAll(e)).map(r=>new ht(r,this.pickleKey,this.olm));return ui(i),i}_validatePayload(e,t){if(e.sender!==t.sender)throw new M("OLM_FORWARDED_MESSAGE",t,{sentBy:t.sender,encryptedBy:e.sender});if(e.recipient!==this.ownUserId)throw new M("OLM_BAD_RECIPIENT",t,{recipient:e.recipient});if(e.recipient_keys?.ed25519!==this.account.identityKeys.ed25519)throw new M("OLM_BAD_RECIPIENT_KEY",t,{key:e.recipient_keys?.ed25519});if(!e.type)throw new M("missing type on payload",t,{payload:e});if(typeof e.keys?.ed25519!="string")throw new M("Missing or invalid claimed ed25519 key on payload",t,{payload:e})}}class oa{constructor(e,t,s){this.senderKey=e,this.sessions=t,this.timestamp=s}addNewSession(e){this.sessions.unshift(e)}decrypt(e){for(const t of this.sessions){const s=this.decryptWithSession(t,e);if(typeof s=="string")return ui(this.sessions),s}}getModifiedSessions(){return this.sessions.filter(e=>e.isModified)}get hasNewSessions(){return this.sessions.some(e=>e.isNew)}decryptWithSession(e,t){if(t.type===void 0||t.body===void 0)throw new Error("Invalid message without type or body");const s=e.load();try{if(t.type===lt.PreKey&&!s.matches_inbound(t.body))return;try{const i=s.decrypt(t.type,t.body);return e.save(s),e.data.lastUsed=this.timestamp,i}catch(i){if(t.type===lt.PreKey)throw new Error(`Error decrypting prekey message with existing session id ${e.id}: ${i.message}`);return}}finally{e.unload(s)}}}class aa{constructor(e,t,s,i,r){this.senderKeyDecryptions=e,this.results=t,this.errors=s,this.account=i,this.lock=r}get hasNewSessions(){return this.senderKeyDecryptions.some(e=>e.hasNewSessions)}write(e){try{for(const t of this.senderKeyDecryptions){for(const s of t.getModifiedSessions())if(e.olmSessions.set(s.data),s.isNew){const i=s.load();try{this.account.writeRemoveOneTimeKey(i,e)}finally{s.unload(i)}}if(t.sessions.length>li){const{senderKey:s,sessions:i}=t;for(let r=i.length-1;r>=li;r-=1){const o=i[r];e.olmSessions.remove(s,o.id)}}}}finally{this.lock.release()}}}function ca(n){return n.reduce((e,t)=>!e||t<e?t:e,null)}const mi="signed_curve25519",ut=20;class da{constructor(e,t,s,i,r,o,a,c){this.account=e,this.pickleKey=t,this.olm=s,this.storage=i,this.now=r,this.ownUserId=o,this.olmUtil=a,this.senderKeyLock=c,this._batchLocks=new Array(ut);for(let d=0;d<ut;d+=1)this._batchLocks[d]=new ai}async _takeBatchLock(e){const t=this._batchLocks.filter(s=>!s.isTaken).slice(0,e);if(t.length<e){const s=this._batchLocks.filter(i=>i.isTaken).slice(0,e-t.length);t.push(...s)}return await Promise.all(t.map(s=>s.take())),new ci(t)}async encrypt(e,t,s,i,r){let o=[];for(let a=0;a<s.length;a+=ut){const c=s.slice(a,a+ut),d=await this._takeBatchLock(c.length);try{const h=await this._encryptForMaxDevices(e,t,c,i,r);o=o.concat(h)}finally{d.release()}}return o}async _encryptForMaxDevices(e,t,s,i,r){const o=await Promise.all(s.map(a=>this.senderKeyLock.takeLock(a.curve25519Key)));try{const{devicesWithoutSession:a,existingEncryptionTargets:c}=await this._findExistingSessions(s),d=this.now();let h=[];try{if(a.length){const p=await r.wrap("create sessions",m=>this._createNewSessions(a,i,d,m));h=h.concat(p)}await this._loadSessions(c),h=h.concat(c);const l={l:"encrypt",targets:h.length},u=r.wrap(l,()=>h.map(p=>{const m=this._encryptForDevice(e,t,p);return new ha(m,p.device)}));return await this._storeSessions(h,d),u}finally{for(const l of h)l.dispose()}}finally{for(const a of o)a.release()}}async _findExistingSessions(e){const t=await this.storage.readTxn([this.storage.storeNames.olmSessions]),s=await Promise.all(e.map(async o=>await t.olmSessions.getSessionIds(o.curve25519Key))),i=e.filter((o,a)=>!s[a]?.length),r=e.map((o,a)=>{const c=s[a];if(c?.length>0){const d=ca(c);return Fe.fromSessionId(o,d)}}).filter(o=>!!o);return{devicesWithoutSession:i,existingEncryptionTargets:r}}_encryptForDevice(e,t,s){const{session:i,device:r}=s,o=JSON.stringify(this._buildPlainTextMessageForDevice(e,t,r)),a=i.encrypt(o);return{algorithm:It,sender_key:this.account.identityKeys.curve25519,ciphertext:{[r.curve25519Key]:a}}}_buildPlainTextMessageForDevice(e,t,s){return{keys:{ed25519:this.account.identityKeys.ed25519},recipient_keys:{ed25519:s.ed25519Key},recipient:s.userId,sender:this.ownUserId,content:t,type:e}}async _createNewSessions(e,t,s,i){const r=await i.wrap("claim",o=>this._claimOneTimeKeys(t,e,o));try{for(const o of r){const{device:a,oneTimeKey:c}=o;o.session=await this.account.createOutboundOlmSession(a.curve25519Key,c)}await this._storeSessions(r,s)}catch(o){for(const a of r)a.dispose();throw o}return r}async _claimOneTimeKeys(e,t,s){const i=Lt(t,c=>c.userId,()=>new Map,(c,d)=>c.set(d.deviceId,d)),r=Array.from(i.entries()).reduce((c,[d,h])=>(c[d]=Array.from(h.values()).reduce((l,u)=>(l[u.deviceId]=mi,l),{}),c),{}),o=await e.claimKeys({timeout:1e4,one_time_keys:r},{log:s}).response();Object.keys(o.failures).length&&s.log({l:"failures",servers:Object.keys(o.failures)},s.level.Warn);const a=o?.one_time_keys;return this._verifyAndCreateOTKTargets(a,i,s)}_verifyAndCreateOTKTargets(e,t,s){const i=[];for(const[r,o]of Object.entries(e))for(const[a,c]of Object.entries(o)){const[d,h]=Object.entries(c)[0],[l]=d.split(":");if(l===mi){const u=t.get(r)?.get(a);if(u&&St(this.olmUtil,r,a,u.ed25519Key,h,s)){const m=Fe.fromOTK(u,h.key);i.push(m)}}}return i}async _loadSessions(e){const t=await this.storage.readTxn([this.storage.storeNames.olmSessions]);let s=!1;try{await Promise.all(e.map(async i=>{const r=await t.olmSessions.get(i.device.curve25519Key,i.sessionId);if(r&&!s){const o=new this.olm.Session;o.unpickle(this.pickleKey,r.session),i.session=o}}))}catch(i){s=!0;for(const r of e)r.dispose();throw i}}async _storeSessions(e,t){const s=await this.storage.readWriteTxn([this.storage.storeNames.olmSessions]);try{for(const i of e){const r=di(i.session,i.device.curve25519Key,t,this.pickleKey);s.olmSessions.set(r)}}catch(i){throw s.abort(),i}await s.complete()}}class Fe{constructor(e,t,s){this.device=e,this.oneTimeKey=t,this.sessionId=s,this.session=null}static fromOTK(e,t){return new Fe(e,t,null)}static fromSessionId(e,t){return new Fe(e,null,t)}dispose(){this.session&&this.session.free()}}class ha{constructor(e,t){this.content=e,this.device=t}}class la{constructor(e,t,s,i){this._roomId=e,this._results=t,this._errors=s,this._replayEntries=i}async write(e){return await Promise.all(this._replayEntries.map(async t=>{try{this._handleReplayAttack(this._roomId,t,e)}catch(s){this._errors.set(t.eventId,s)}})),{results:this._results,errors:this._errors}}async _handleReplayAttack(e,t,s){const{messageIndex:i,sessionId:r,eventId:o,timestamp:a}=t,c=await s.groupSessionDecryptions.get(e,r,i);if(c&&c.eventId!==o){const h=c.timestamp<a?o:c.eventId;throw this._results.delete(o),new M("MEGOLM_REPLAYED_INDEX",event,{messageIndex:i,badEventId:h,otherEventId:c.eventId})}c||s.groupSessionDecryptions.set(e,r,i,{eventId:o,timestamp:a})}}function Wt(n,e){if(n)for(const[t,s]of n.entries())e.set(t,s)}class ua{constructor(e,t,s){this._roomId=e,this._sessionDecryptions=t,this._initialErrors=s}async decrypt(){try{const e=this._initialErrors,t=new Map,s=[];return await Promise.all(this._sessionDecryptions.map(async i=>{const r=await i.decryptAll();Wt(r.errors,e),Wt(r.results,t),s.push(...r.replayEntries)})),new la(this._roomId,t,e,s)}finally{this.dispose()}}dispose(){for(const e of this._sessionDecryptions)e.dispose()}}class ma{constructor(e,t,s){this.sessionId=e,this.messageIndex=t,this.event=s}get eventId(){return this.event.event_id}get timestamp(){return this.event.origin_server_ts}}class pa{constructor(e,t,s,i){this.key=e,this.events=t,this.olmWorker=s,this.keyLoader=i,this.decryptionRequests=s?[]:void 0}async decryptAll(){const e=[],t=new Map;let s;return await this.keyLoader.useKey(this.key,async i=>{for(const r of this.events)try{const o=r.content.ciphertext;let a;if(this.olmWorker){const l=this.olmWorker.megolmDecrypt(i,o);this.decryptionRequests.push(l),a=await l.response()}else a=i.decrypt(o);const{plaintext:c}=a;let d;try{d=JSON.parse(c)}catch(l){throw new M("PLAINTEXT_NOT_JSON",r,{plaintext:c,err:l})}if(d.room_id!==this.key.roomId)throw new M("MEGOLM_WRONG_ROOM",r,{encryptedRoomId:d.room_id,eventRoomId:this.key.roomId});e.push(new ma(this.key.sessionId,a.message_index,r));const h=new hi(d,this.key.senderKey,this.key.claimedEd25519Key,r);t.set(r.event_id,h)}catch(o){if(o.name==="AbortError")return;s||(s=new Map),s.set(r.event_id,o)}}),{results:t,errors:s,replayEntries:e}}dispose(){if(this.decryptionRequests)for(const e of this.decryptionRequests)e.abort()}}function Gt(n){return n.content?.sender_key}function Vt(n){return n.content?.session_id}function _a(n){return n.content?.ciphertext}function fa(n){return typeof Gt(n)=="string"&&typeof Vt(n)=="string"&&typeof _a(n)=="string"}class ya{constructor(){this.events=[]}get senderKey(){return Gt(this.events[0])}get sessionId(){return Vt(this.events[0])}}function Ht(n){return Lt(n,e=>`${Gt(e)}|${Vt(e)}`,()=>new ya,(e,t)=>e.events.push(t))}class pi{isForSession(e,t,s){return this.roomId===e&&this.senderKey===t&&this.sessionId===s}get isBetter(){return this._isBetter}set isBetter(e){this._isBetter=e}}function _i(n,e){return n.first_known_index()<e.first_known_index()}class zt extends pi{checkBetterThanKeyInStorage(e,t){return this._checkBetterThanKeyInStorage(e,void 0,t)}async write(e,t){let s;if(this.isBetter===void 0&&await this._checkBetterThanKeyInStorage(e,(r,o)=>{s=r.pickle(o)},t),this.isBetter===!1)return!1;s||(s=await e.useKey(this,(r,o)=>r.pickle(o)));const i={roomId:this.roomId,senderKey:this.senderKey,sessionId:this.sessionId,session:s,backup:this.backupStatus,source:this.keySource,claimedKeys:{ed25519:this.claimedEd25519Key}};return t.inboundGroupSessions.set(i),!0}get eventIds(){return this._eventIds}async _checkBetterThanKeyInStorage(e,t,s){if(this.isBetter!==void 0)return this.isBetter;let i=e.getCachedKey(this.roomId,this.senderKey,this.sessionId);if(!i){const r=await gi(this.roomId,this.senderKey,this.sessionId,s);r&&(r.hasSession?i=r:r.eventIds&&(this._eventIds=r.eventIds))}if(i){const r=i;await e.useKey(this,async o=>{await e.useKey(r,(a,c)=>{this.isBetter=_i(o,a),r.isBetter=!this.isBetter,this.isBetter&&t&&t(o,c)})})}else this.isBetter=!0;return this.isBetter}get backupStatus(){return st.NotBackedUp}}class ga extends zt{constructor(e){super(),this._decryptionResult=e}get roomId(){return this._decryptionResult.event.content?.room_id}get senderKey(){return this._decryptionResult.senderCurve25519Key}get sessionId(){return this._decryptionResult.event.content?.session_id}get claimedEd25519Key(){return this._decryptionResult.claimedEd25519Key}get serializationKey(){return this._decryptionResult.event.content?.session_key}get serializationType(){return"create"}get keySource(){return Ae.DeviceMessage}loadInto(e){e.create(this.serializationKey)}}class va extends zt{constructor(e,t,s){super(),this._roomId=e,this.outboundSession=t,this.identityKeys=s,this.isBetter=!0,this._sessionKey=this.outboundSession.session_key()}get roomId(){return this._roomId}get senderKey(){return this.identityKeys.curve25519}get sessionId(){return this.outboundSession.session_id()}get claimedEd25519Key(){return this.identityKeys.ed25519}get serializationKey(){return this._sessionKey}get serializationType(){return"create"}get keySource(){return Ae.Outbound}loadInto(e){e.create(this.serializationKey)}}class wa extends zt{constructor(e,t,s){super(),this._roomId=e,this._sessionId=t,this._backupInfo=s}get roomId(){return this._roomId}get senderKey(){return this._backupInfo.sender_key}get sessionId(){return this._sessionId}get claimedEd25519Key(){return this._backupInfo.sender_claimed_keys?.ed25519}get serializationKey(){return this._backupInfo.session_key}get serializationType(){return"import_session"}get keySource(){return Ae.Backup}loadInto(e){e.import_session(this.serializationKey)}get backupStatus(){return st.BackedUp}}class fi extends pi{constructor(e){super(),this.isBetter=!0,this.storageEntry=e}get roomId(){return this.storageEntry.roomId}get senderKey(){return this.storageEntry.senderKey}get sessionId(){return this.storageEntry.sessionId}get claimedEd25519Key(){return this.storageEntry.claimedKeys.ed25519}get eventIds(){return this.storageEntry.eventIds}get serializationKey(){return this.storageEntry.session||""}get serializationType(){return"unpickle"}loadInto(e,t){e.unpickle(t,this.serializationKey)}get hasSession(){return!!this.serializationKey}}function ba(n){const e=n.event.content?.session_key,t=new ga(n);if(typeof t.roomId=="string"&&typeof t.sessionId=="string"&&typeof t.senderKey=="string"&&typeof e=="string")return t}function yi(n,e,t){const s=t.session_key,i=t.sender_key,r=t.sender_claimed_keys?.ed25519;if(typeof n=="string"&&typeof e=="string"&&typeof i=="string"&&typeof s=="string"&&typeof r=="string")return new wa(n,e,t)}async function gi(n,e,t,s){const i=await s.inboundGroupSessions.get(n,e,t);if(i)return new fi(i)}class Ia{constructor(e,t){this.keyLoader=e,this.olmWorker=t}async addMissingKeyEventIds(e,t,s,i,r){let o=await r.inboundGroupSessions.get(e,t,s);if(!o?.session){if(o){const a=new Set(o.eventIds);for(const c of i)a.add(c);o.eventIds=Array.from(a)}else o={roomId:e,senderKey:t,sessionId:s,eventIds:i};r.inboundGroupSessions.set(o)}}async getEventIdsForMissingKey(e,t,s,i){const r=await i.inboundGroupSessions.get(e,t,s);if(r&&!r.session)return r.eventIds}async hasSession(e,t,s,i){return typeof(await i.inboundGroupSessions.get(e,t,s))?.session=="string"}async prepareDecryptAll(e,t,s,i){const r=new Map,o=[];for(const d of t)fa(d)?o.push(d):r.set(d.event_id,new M("MEGOLM_INVALID_EVENT",d));const a=Ht(o),c=[];return await Promise.all(Array.from(a.values()).map(async d=>{const h=await this.getRoomKey(e,d.senderKey,d.sessionId,s,i);if(h)c.push(new pa(h,d.events,this.olmWorker,this.keyLoader));else for(const l of d.events)r.set(l.event_id,new M("MEGOLM_NO_SESSION",l))})),new ua(e,c,r)}async getRoomKey(e,t,s,i,r){if(i){const c=i.find(d=>d.isForSession(e,t,s));if(c&&await c.checkBetterThanKeyInStorage(this.keyLoader,r))return c}const o=this.keyLoader.getCachedKey(e,t,s);if(o)return o;const a=await gi(e,t,s,r);if(a&&a.serializationKey)return a}writeRoomKey(e,t){return e.write(this.keyLoader,t)}roomKeysFromDeviceMessages(e,t){const s=[];for(const i of e)i.event?.type!=="m.room_key"||i.event.content?.algorithm!==q||t.wrap("room_key",r=>{const o=ba(i);o?(r.set("roomId",o.roomId),r.set("id",o.sessionId),s.push(o)):(r.logLevel=r.level.Warn,r.set("invalid",!0))},t.level.Detail);return s}roomKeyFromBackup(e,t,s){return yi(e,t,s)}dispose(){this.keyLoader.dispose()}}class Sa extends Hs{constructor(e,t,s){super(s),this.pickleKey=t,this.olm=e}getCachedKey(e,t,s){const i=this.findCachedKeyIndex(e,t,s);if(i!==-1)return this._getByIndexAndMoveUp(i).key}async useKey(e,t){const s=await this.allocateOperation(e);try{return await t(s.session,this.pickleKey)}finally{this.releaseOperation(s)}}get running(){return this._entries.some(e=>e.refCount!==0)}dispose(){for(let e=0;e<this._entries.length;e+=1)this._entries[e].dispose();this._entries.splice(0,this._entries.length)}async allocateOperation(e){let t;for(;(t=this.findIndexForAllocation(e))===-1;)await this.operationBecomesUnused();if(t<this.size){const s=this._getByIndexAndMoveUp(t);return s.isForKey(e)?(s.refCount+=1,s):(s.refCount=1,s.key=e,e.loadInto(s.session,this.pickleKey),s)}else{const s=new this.olm.InboundGroupSession;e.loadInto(s,this.pickleKey);const i=new Ea(e,s);return this._set(i),i}}releaseOperation(e){e.refCount-=1,e.refCount<=0&&this.resolveUnusedOperation&&(this.resolveUnusedOperation(),this.operationBecomesUnusedPromise=this.resolveUnusedOperation=void 0)}operationBecomesUnused(){return this.operationBecomesUnusedPromise||(this.operationBecomesUnusedPromise=new Promise(e=>{this.resolveUnusedOperation=e})),this.operationBecomesUnusedPromise}findIndexForAllocation(e){let t=this.findIndexSameKey(e);return t===-1&&(this.size<this.limit?t=this.size:(t=this.findIndexSameSessionUnused(e),t===-1&&(t=this.findIndexOldestUnused()))),t}findCachedKeyIndex(e,t,s){return this._entries.reduce((i,r,o,a)=>{const c=i===-1?void 0:a[i];return r.isBest===!0&&r.isForSameSession(e,t,s)&&(!c||r.isBetter(c))?o:i},-1)}findIndexSameKey(e){return this._entries.findIndex(t=>t.isForSameSession(e.roomId,e.senderKey,e.sessionId)&&t.isForKey(e))}findIndexSameSessionUnused(e){return this._entries.reduce((t,s,i,r)=>{const o=t===-1?void 0:r[t];return s.refCount===0&&s.isForSameSession(e.roomId,e.senderKey,e.sessionId)&&(!o||!s.isBetter(o))?i:t},-1)}findIndexOldestUnused(){for(let e=this._entries.length-1;e>=0;e-=1)if(this._entries[e].refCount===0)return e;return-1}}class Ea{constructor(e,t){this.key=e,this.session=t,this.refCount=1}isForSameSession(e,t,s){return this.key.roomId===e&&this.key.senderKey===t&&this.key.sessionId===s}isBetter(e){return _i(this.session,e.session)}isForKey(e){return this.key.serializationKey===e.serializationKey&&this.key.serializationType===e.serializationType}dispose(){this.session.free(),this.session=void 0}get isBest(){return this.key.isBetter}}const Ra="m.megolm_backup.v1.curve25519-aes-sha2";class Qt{constructor(e,t){this.encryption=e,this.decryption=t}static fromAuthData(e,t,s){const i=e.public_key,r=new s.PkDecryption,o=new s.PkEncryption;try{const a=r.init_with_private_key(t);if(a!==i)throw new Error(`Bad backup key, public key does not match. Calculated ${a} but expected ${i}`);o.set_recipient_key(a)}catch(a){throw r.free(),o.free(),a}return new Qt(o,r)}decryptRoomKey(e){const t=this.decryption.decrypt(e.ephemeral,e.mac,e.ciphertext);return JSON.parse(t)}encryptRoomKey(e,t){const s={algorithm:q,sender_key:e.senderKey,sender_claimed_keys:{ed25519:e.claimedEd25519Key},forwarding_curve25519_key_chain:[],session_key:t};return this.encryption.encrypt(JSON.stringify(s))}dispose(){this.decryption?.free(),this.decryption=void 0,this.encryption?.free(),this.encryption=void 0}}class ka{constructor(e){this._abortable=void 0;const t=i=>(this._abortable=i,i);this._progress=new re(void 0);const s=i=>{this._progress.set(i)};this.result=e(t,s)}get progress(){return this._progress}abort(){this._abortable?.abort(),this._abortable=void 0}}const Ma=200;class Jt{constructor(e,t,s,i,r,o,a=1e4){this.backupInfo=e,this.crypto=t,this.hsApi=s,this.keyLoader=i,this.storage=r,this.platform=o,this.maxDelay=a,this.operationInProgress=new re(void 0),this._stopped=!1,this._needsNewKey=!1,this._hasBackedUpAllKeys=!1}get hasStopped(){return this._stopped}get error(){return this._error}get version(){return this.backupInfo.version}get needsNewKey(){return this._needsNewKey}get hasBackedUpAllKeys(){return this._hasBackedUpAllKeys}async getRoomKey(e,t,s){const i=await this.hsApi.roomKeyForRoomAndSession(this.backupInfo.version,e,t,{log:s}).response();if(!i.session_data)return;const r=this.crypto.decryptRoomKey(i.session_data);if(r?.algorithm===q)return yi(e,t,r);r?.algorithm&&s.set("unknown algorithm",r.algorithm)}markAllForBackup(e){return e.inboundGroupSessions.markAllAsNotBackedUp()}flush(e){this.operationInProgress.get()||e.wrapDetached("flush key backup",async t=>{if(this._needsNewKey){t.set("needsNewKey",this._needsNewKey);return}this._stopped=!1,this._error=void 0,this._hasBackedUpAllKeys=!1;const s=this._runFlushOperation(t);this.operationInProgress.set(s);try{await s.result,this._hasBackedUpAllKeys=!0}catch(i){this._stopped=!0,i.name==="HomeServerError"&&(i.errcode==="M_WRONG_ROOM_KEYS_VERSION"||i.errcode==="M_NOT_FOUND")?(t.set("wrong_version",!0),this._needsNewKey=!0):(i.name!=="AbortError"||i.name==="StorageError"&&i.errcode==="AbortError")&&(this._error=i),t.catch(i)}this.operationInProgress.set(void 0)})}_runFlushOperation(e){return new ka(async(t,s)=>{let i=0,r=0;for(;;){const o=this.platform.random()*this.maxDelay,a=this.platform.clock.createTimeout(o);t(a),await a.elapsed();const c=await this.storage.readTxn([b.inboundGroupSessions]);t(c),i=r+await c.inboundGroupSessions.countNonBackedUpSessions(),s(new vi(i,r));const d=(await c.inboundGroupSessions.getFirstNonBackedUpSessions(Ma)).map(u=>new fi(u));if(d.length===0){e.set("total",i);return}const h=await this.encodeKeysForBackup(d),l=this.hsApi.uploadRoomKeysToBackup(this.backupInfo.version,h,{log:e});t(l),await l.response(),await this.markKeysAsBackedUp(d,t),r+=d.length,s(new vi(i,r))}})}async encodeKeysForBackup(e){const t={rooms:{}},s=t.rooms;for(const i of e){let r=s[i.roomId];r||(r=s[i.roomId]={sessions:{}}),r.sessions[i.sessionId]=await this.encodeRoomKey(i)}return t}async markKeysAsBackedUp(e,t){const s=await this.storage.readWriteTxn([b.inboundGroupSessions]);t(s);try{await Promise.all(e.map(i=>s.inboundGroupSessions.markAsBackedUp(i.roomId,i.senderKey,i.sessionId)))}catch(i){throw s.abort(),i}await s.complete()}async encodeRoomKey(e){return await this.keyLoader.useKey(e,t=>{const s=t.first_known_index(),i=t.export_session(s);return{first_message_index:s,forwarded_count:0,is_verified:!1,session_data:this.crypto.encryptRoomKey(e,i)}})}dispose(){this.crypto.dispose()}static async fromSecretStorage(e,t,s,i,r,o,a){const c=await s.readSecret("m.megolm_backup.v1",a);if(c){const d=new Uint8Array(e.encoding.base64.decode(c)),h=await i.roomKeysVersion().response();if(h.algorithm===Ra){const l=Qt.fromAuthData(h.auth_data,d,t);return new Jt(h,l,i,r,o,e)}else throw new Error(`Unknown backup algorithm: ${h.algorithm}`)}}}class vi{constructor(e,t){this.total=e,this.finished=t}}function Ca(n,e,t,s,i){let r=!1;if(t instanceof Uint8Array){const c=new n.PkSigning;i=c.init_with_seed(t),t=c,r=!0}const o=e.signatures||{};delete e.signatures;const a=e.unsigned;e.unsigned&&delete e.unsigned;try{const c=o[s]||{};return o[s]=c,c["ed25519:"+i]=t.sign(wt.stringify(e))}finally{e.signatures=o,a&&(e.unsigned=a),r&&t.free()}}class Ta{constructor(e){this._isMasterKeyTrusted=!1,this.storage=e.storage,this.secretStorage=e.secretStorage,this.platform=e.platform,this.deviceTracker=e.deviceTracker,this.olm=e.olm,this.hsApi=e.hsApi,this.ownUserId=e.ownUserId,this.e2eeAccount=e.e2eeAccount}async init(e){e.wrap("CrossSigning.init",async t=>{const s=await this.storage.readTxn([this.storage.storeNames.accountData]),i=await this.secretStorage.readSecret("m.cross_signing.master",s),r=new this.olm.PkSigning;let o;try{const c=new Uint8Array(this.platform.encoding.base64.decode(i));o=r.init_with_seed(c)}finally{r.free()}const a=await this.deviceTracker.getCrossSigningKeysForUser(this.ownUserId,this.hsApi,t);t.set({publishedMasterKey:a.masterKey,derivedPublicKey:o}),this._isMasterKeyTrusted=a.masterKey===o,t.set("isMasterKeyTrusted",this.isMasterKeyTrusted)})}async signOwnDevice(e){e.wrap("CrossSigning.signOwnDevice",async t=>{if(!this._isMasterKeyTrusted){t.set("mskNotTrusted",!0);return}const s=this.e2eeAccount.getDeviceKeysToSignWithCrossSigning(),i=await this.signDevice(s),r={[i.user_id]:{[i.device_id]:i}};await this.hsApi.uploadSignatures(r,{log:t}).response()})}async signDevice(e){const t=await this.storage.readTxn([this.storage.storeNames.accountData]),s=await this.secretStorage.readSecret("m.cross_signing.self_signing",t),i=new Uint8Array(this.platform.encoding.base64.decode(s));return Ca(this.olm,e,i,this.ownUserId,""),e}get isMasterKeyTrusted(){return this._isMasterKeyTrusted}}class Aa{constructor({pickleKey:e,olm:t,account:s,keyLoader:i,storage:r,now:o,ownDeviceId:a}){this._pickleKey=e,this._olm=t,this._account=s,this._keyLoader=i,this._storage=r,this._now=o,this._ownDeviceId=a}discardOutboundSession(e,t){t.outboundGroupSessions.remove(e)}async createRoomKeyMessage(e,t){let s=await t.outboundGroupSessions.get(e);if(s){const i=new this._olm.OutboundGroupSession;try{return i.unpickle(this._pickleKey,s.session),this._createRoomKeyMessage(i,e)}finally{i.free()}}}createWithheldMessage(e,t,s){return{algorithm:e.algorithm,code:t,reason:s,room_id:e.room_id,sender_key:this._account.identityKeys.curve25519,session_id:e.session_id}}async ensureOutboundSession(e,t){let s=new this._olm.OutboundGroupSession;try{const i=await this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions,this._storage.storeNames.outboundGroupSessions]);let r;try{let o=await i.outboundGroupSessions.get(e);r=await this._readOrCreateSession(s,o,e,t,i),r&&this._writeSession(this._now(),s,e,i)}catch(o){throw i.abort(),o}return await i.complete(),r}finally{s.free()}}async _readOrCreateSession(e,t,s,i,r){if(t&&e.unpickle(this._pickleKey,t.session),!t||this._needsToRotate(e,t.createdAt,i)){t&&(e.free(),e=new this._olm.OutboundGroupSession),e.create();const o=this._createRoomKeyMessage(e,s);return await new va(s,e,this._account.identityKeys).write(this._keyLoader,r),o}}_writeSession(e,t,s,i){i.outboundGroupSessions.set({roomId:s,session:t.pickle(this._pickleKey),createdAt:e})}async encrypt(e,t,s,i){let r=new this._olm.OutboundGroupSession;try{const o=await this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions,this._storage.storeNames.outboundGroupSessions]);let a,c;try{let d=await o.outboundGroupSessions.get(e);a=await this._readOrCreateSession(r,d,e,i,o),c=this._encryptContent(e,r,t,s);const h=a?this._now():d.createdAt;this._writeSession(h,r,e,o)}catch(d){throw o.abort(),d}return await o.complete(),new Ka(c,a)}finally{r&&r.free()}}_needsToRotate(e,t,s){let i=6048e5;Number.isSafeInteger(s?.rotation_period_ms)&&(i=s?.rotation_period_ms);let r=100;if(Number.isSafeInteger(s?.rotation_period_msgs)&&(r=s?.rotation_period_msgs),this._now()>t+i||e.message_index()>=r)return!0}_encryptContent(e,t,s,i){const r=JSON.stringify({room_id:e,type:s,content:i}),o=t.encrypt(r);return{algorithm:q,sender_key:this._account.identityKeys.curve25519,ciphertext:o,session_id:t.session_id(),device_id:this._ownDeviceId}}_createRoomKeyMessage(e,t){return{room_id:t,session_id:e.session_id(),session_key:e.session_key(),algorithm:q,chain_index:e.message_index()}}}class Ka{constructor(e,t){this.content=e,this.roomKeyMessage=t}}const wi="m.room.encrypted",bi="m.room.history_visibility",xa=60*1e3;class Da{constructor({room:e,deviceTracker:t,olmEncryption:s,megolmEncryption:i,megolmDecryption:r,encryptionParams:o,storage:a,keyBackup:c,notifyMissingMegolmSession:d,clock:h}){this._room=e,this._deviceTracker=t,this._olmEncryption=s,this._megolmEncryption=i,this._megolmDecryption=r,this._encryptionParams=o,this._senderDeviceCache=new Map,this._storage=a,this._keyBackup=c,this._notifyMissingMegolmSession=d,this._clock=h,this._isFlushingRoomKeyShares=!1,this._lastKeyPreShareTime=null,this._keySharePromise=null,this._historyVisibility=void 0,this._disposed=!1}enableKeyBackup(e){this._keyBackup&&!!e||(this._keyBackup=e)}async restoreMissingSessionsFromBackup(e,t){const s=e.filter(h=>h.isEncrypted&&!h.isDecrypted&&h.event).map(h=>h.event),i=Ht(s),r=Array.from(i.values()),o=await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]),a=await Promise.all(r.map(async h=>this._megolmDecryption.hasSession(this._room.id,h.senderKey,h.sessionId,o))),c=r.filter((h,l)=>!a[l]);if(c.length)for(var d=c.length-1;d>=0;d--){const h=c[d];await t.wrap("session",l=>this._requestMissingSessionFromBackup(h.senderKey,h.sessionId,l))}}notifyTimelineClosed(){this._senderDeviceCache=new Map}async writeSync(e,t,s,i){let r=await this._loadHistoryVisibilityIfNeeded(this._historyVisibility,s);const o=[],a=[];if(await ge(e,d=>{if(d.state_key===""&&d.type===bi){const h=d?.content?.history_visibility;if(h!==r)return i.wrap({l:"history_visibility changed",from:r,to:h},async l=>{r=h;const u=await this._deviceTracker.writeHistoryVisibility(this._room,r,s,l);o.push(...u.added),a.push(...u.removed)})}}),t.size){const d=await this._deviceTracker.writeMemberChanges(this._room,t,r,s);o.push(...d.added),a.push(...d.removed)}a.length&&(i.log({l:"discardOutboundSession",leftUsers:a}),this._megolmEncryption.discardOutboundSession(this._room.id,s));let c=!1;return o.length&&(c=await this._addShareRoomKeyOperationForMembers(o,s,i)),{shouldFlush:c,historyVisibility:r}}afterSync({historyVisibility:e}){this._historyVisibility=e}async _loadHistoryVisibilityIfNeeded(e,t=void 0){if(!e){t||(t=await this._storage.readTxn([this._storage.storeNames.roomState]));const s=await t.roomState.get(this._room.id,bi,"");if(s)return s.event?.content?.history_visibility}return e}async prepareDecryptAll(e,t,s,i){const r=new Map,o=[];for(const c of e)c.redacted_because||c.unsigned?.redacted_because||(c.content?.algorithm!==q&&r.set(c.event_id,new Error("Unsupported algorithm: "+c.content?.algorithm)),o.push(c));const a=await this._megolmDecryption.prepareDecryptAll(this._room.id,o,t,i);return new Ua(a,r,s,this,e)}async _processDecryptionResults(e,t,s,i,r,o){const a=e.filter(d=>s.get(d.event_id)?.code==="MEGOLM_NO_SESSION");if(!a.length)return;const c=Ht(a);i===ae.Sync&&await Promise.all(Array.from(c.values()).map(async d=>{const h=d.events.map(l=>l.event_id);return this._megolmDecryption.addMissingKeyEventIds(this._room.id,d.senderKey,d.sessionId,h,r)})),this._keyBackup&&o.wrapDetached("check key backup",async d=>{if(d.set("source",i),d.set("events",a.length),d.set("sessions",c.size),i===ae.Sync){if(await this._clock.createTimeout(1e4).elapsed(),this._disposed)return;const h=await this._storage.readTxn([this._storage.storeNames.inboundGroupSessions]);await Promise.all(Array.from(c).map(async([l,u])=>{await this._megolmDecryption.hasSession(this._room.id,u.senderKey,u.sessionId,h)&&c.delete(l)}))}await Promise.all(Array.from(c.values()).map(h=>d.wrap("session",l=>this._requestMissingSessionFromBackup(h.senderKey,h.sessionId,l))))})}async _verifyDecryptionResults(e,t){await Promise.all(e.map(async s=>{let i=this._senderDeviceCache.get(s.senderCurve25519Key);i||(i=await this._deviceTracker.getDeviceByCurve25519Key(s.senderCurve25519Key,t),this._senderDeviceCache.set(s.senderCurve25519Key,i)),i&&s.setDevice(i)}))}async _fetchKeyAndVerifyDecryptionResults(e,t,s){const i=e.filter(r=>r.isVerificationUnknown);return i.length?s.wrap("fetch unverified senders",async r=>{const o=Array.from(i.reduce((h,l)=>h.add(l.encryptedEvent.sender),new Set));r.set("senders",o),await this._deviceTracker.devicesForUsers(o,t,r);const a=await this._storage.readTxn([this._storage.storeNames.deviceIdentities]);await this._verifyDecryptionResults(i,a);const d=i.filter(h=>!h.isVerificationUnknown).reduce((h,l)=>(h.set(l.encryptedEvent.event_id,l),h),new Map);return new Yt(d,new Map,this)}):new Yt(new Map,new Map,this)}async _requestMissingSessionFromBackup(e,t,s){if(!this._keyBackup){s.set("enabled",!1),this._notifyMissingMegolmSession();return}s.set("id",t),s.set("senderKey",e);try{const i=await this._keyBackup.getRoomKey(this._room.id,t,s);if(i){if(i.senderKey!==e){s.set("wrong_sender_key",i.senderKey),s.logLevel=s.level.Warn;return}let r=!1,o;const a=await this._storage.readWriteTxn([this._storage.storeNames.inboundGroupSessions]);try{r=await this._megolmDecryption.writeRoomKey(i,a),s.set("isBetter",r),r&&(o=i.eventIds)}catch(c){throw a.abort(),c}await a.complete(),r&&await s.wrap("retryDecryption",c=>this._room.notifyRoomKey(i,o||[],c))}}catch(i){i.name==="HomeServerError"&&i.errcode==="M_NOT_FOUND"?(s.error=i,s.logLevel=s.level.Error):s.set("not_found",!0)}}getEventIdsForMissingKey(e,t){return this._megolmDecryption.getEventIdsForMissingKey(this._room.id,e.senderKey,e.sessionId,t)}async ensureMessageKeyIsShared(e,t){if(!(this._lastKeyPreShareTime?.measure()<xa)){this._lastKeyPreShareTime=this._clock.createMeasure();try{this._keySharePromise=(async()=>{const s=await this._megolmEncryption.ensureOutboundSession(this._room.id,this._encryptionParams);s&&(this._keyBackup?.flush(t),await t.wrap("share key",i=>this._shareNewRoomKey(s,e,i)))})(),await this._keySharePromise}finally{this._keySharePromise=null}}}async encrypt(e,t,s,i){this._keySharePromise&&(i.set("waitForRunningKeyShare",!0),await this._keySharePromise);const r=await i.wrap("megolm encrypt",()=>this._megolmEncryption.encrypt(this._room.id,e,t,this._encryptionParams));return r.roomKeyMessage&&(this._keyBackup?.flush(i),await i.wrap("share key",o=>this._shareNewRoomKey(r.roomKeyMessage,s,o))),{type:wi,content:r.content}}needsToShareKeys(e){for(const t of e.values())if(t.hasJoined)return!0;return!1}async _shareNewRoomKey(e,t,s){this._historyVisibility=await this._loadHistoryVisibilityIfNeeded(this._historyVisibility),await this._deviceTracker.trackRoom(this._room,this._historyVisibility,s);const i=await this._deviceTracker.devicesForTrackedRoom(this._room.id,t,s),r=Array.from(i.reduce((c,d)=>c.add(d.userId),new Set));let o=await this._storage.readWriteTxn([this._storage.storeNames.operations]),a;try{a=this._writeRoomKeyShareOperation(e,r,o)}catch(c){throw o.abort(),c}await this._processShareRoomKeyOperation(a,t,s)}async _addShareRoomKeyOperationForMembers(e,t,s){const i=await this._megolmEncryption.createRoomKeyMessage(this._room.id,t);return i?(s.log({l:"share key for new members",userIds:e,id:i.session_id,chain_index:i.chain_index}),this._writeRoomKeyShareOperation(i,e,t),!0):!1}async flushPendingRoomKeyShares(e,t,s){if(!this._isFlushingRoomKeyShares){this._isFlushingRoomKeyShares=!0;try{t||(t=await(await this._storage.readTxn([this._storage.storeNames.operations])).operations.getAllByTypeAndScope("share_room_key",this._room.id));for(const i of t)i.type==="share_room_key"&&await s.wrap("operation",r=>this._processShareRoomKeyOperation(i,e,r))}finally{this._isFlushingRoomKeyShares=!1}}}_writeRoomKeyShareOperation(e,t,s){const r={id:Math.floor(Math.random()*Number.MAX_SAFE_INTEGER).toString(),type:"share_room_key",scope:this._room.id,userIds:t,roomKeyMessage:e};return s.operations.add(r),r}async _processShareRoomKeyOperation(e,t,s){s.set("id",e.id),this._historyVisibility=await this._loadHistoryVisibilityIfNeeded(this._historyVisibility),await this._deviceTracker.trackRoom(this._room,this._historyVisibility,s);const i=await this._deviceTracker.devicesForRoomMembers(this._room.id,e.userIds,t,s),r=await s.wrap("olm encrypt",a=>this._olmEncryption.encrypt("m.room_key",e.roomKeyMessage,i,t,a)),o=i.filter(a=>!r.some(c=>c.device===a));await s.wrap("send",a=>this._sendMessagesToDevices(wi,r,t,a)),o.length&&await s.wrap("missingDevices",async a=>{a.set("devices",o.map(h=>h.deviceId));const c=e.userIds.filter(h=>o.some(l=>l.userId===h));a.set("unsentUserIds",c),e.userIds=c,await this._updateOperationsStore(h=>h.update(e));const d=this._megolmEncryption.createWithheldMessage(e.roomKeyMessage,"m.no_olm","OTKs exhausted");await this._sendSharedMessageToDevices("org.matrix.room_key.withheld",d,o,t,a)}),await this._updateOperationsStore(a=>a.remove(e.id))}async _updateOperationsStore(e){const t=await this._storage.readWriteTxn([this._storage.storeNames.operations]);try{e(t.operations)}catch(s){throw t.abort(),s}await t.complete()}async _sendSharedMessageToDevices(e,t,s,i,r){const o=be(s,d=>d.userId),a={messages:Array.from(o.entries()).reduce((d,[h,l])=>(d[h]=l.reduce((u,p)=>(u[p.deviceId]=t,u),{}),d),{})},c=ot();await i.sendToDevice(e,a,c,{log:r}).response()}async _sendMessagesToDevices(e,t,s,i){i.set("messages",t.length);const r=qt(t),o=ot();await s.sendToDevice(e,r,o,{log:i}).response()}filterUndecryptedEventEntriesForKeys(e,t){return e.filter(s=>{if(s.isEncrypted&&!s.isDecrypted){const{event:i}=s;if(i){const r=i.content?.sender_key,o=i.content?.session_id;return t.some(a=>r===a.senderKey&&o===a.sessionId)}}return!1})}dispose(){this._disposed=!0}}class Ua{constructor(e,t,s,i,r){this._megolmDecryptionPreparation=e,this._extraErrors=t,this._source=s,this._roomEncryption=i,this._events=r}async decrypt(){return new Fa(await this._megolmDecryptionPreparation.decrypt(),this._extraErrors,this._source,this._roomEncryption,this._events)}dispose(){this._megolmDecryptionPreparation.dispose()}}class Fa{constructor(e,t,s,i,r){this._megolmDecryptionChanges=e,this._extraErrors=t,this._source=s,this._roomEncryption=i,this._events=r}async write(e,t){const{results:s,errors:i}=await this._megolmDecryptionChanges.write(e);return Wt(this._extraErrors,i),await this._roomEncryption._processDecryptionResults(this._events,s,i,this._source,e,t),new Yt(s,i,this._roomEncryption)}}class Yt{constructor(e,t,s){this.results=e,this.errors=t,this._roomEncryption=s}applyToEntries(e,t=void 0){for(const s of e){const i=this.results.get(s.id);if(i)s.setDecryptionResult(i),t?.(s);else{const r=this.errors.get(s.id);r&&(s.setDecryptionError(r),t?.(s))}}}verifyKnownSenders(e){return this._roomEncryption._verifyDecryptionResults(Array.from(this.results.values()),e)}get hasUnverifiedSenders(){for(const e of this.results.values())if(e.isVerificationUnknown)return!0;return!1}fetchAndVerifyRemainingSenders(e,t){return this._roomEncryption._fetchKeyAndVerifyDecryptionResults(Array.from(this.results.values()),e,t)}}const Pe=0,Xt=1;function Ii(n,e=void 0){return{userId:n,roomIds:e?[e]:[],crossSigningKeys:void 0,deviceTrackingStatus:Pe}}function Pa(n,e,t){if(n){if(!n.roomIds.includes(t))return n.roomIds.push(t),n}else return n=Ii(e,t),n}function Si(n){const e=n.device_id;return{userId:n.user_id,deviceId:e,ed25519Key:n.keys[`ed25519:${e}`],curve25519Key:n.keys[`curve25519:${e}`],algorithms:n.algorithms,displayName:n.unsigned?.device_display_name}}class Oa{constructor({storage:e,getSyncToken:t,olmUtil:s,ownUserId:i,ownDeviceId:r}){this._storage=e,this._getSyncToken=t,this._identityChangedForRoom=null,this._olmUtil=s,this._ownUserId=i,this._ownDeviceId=r}async writeDeviceChanges(e,t,s){const{userIdentities:i}=t;s.set("changed",e.length),await Promise.all(e.map(async r=>{const o=await i.get(r);o&&(s.log({l:"outdated",id:r}),o.deviceTrackingStatus=Pe,i.set(o))}))}async writeMemberChanges(e,t,s,i){const r=[],o=[];return await Promise.all(Array.from(t.values()).map(async a=>{if(ze(a.membership,s))await this._addRoomToUserIdentity(a.roomId,a.userId,i)&&r.push(a.userId);else if(ze(a.previousMembership,s)){const{roomId:c}=a;if(a.userId===this._ownUserId){const d=await i.roomMembers.getAllUserIds(c);await Promise.all(d.map(h=>this._removeRoomFromUserIdentity(c,h,i)))}else await this._removeRoomFromUserIdentity(c,a.userId,i);o.push(a.userId)}})),{added:r,removed:o}}async trackRoom(e,t,s){if(e.isTrackingMembers||!e.isEncrypted)return;const i=await e.loadMemberList(void 0,s),r=await this._storage.readWriteTxn([this._storage.storeNames.roomSummary,this._storage.storeNames.userIdentities,this._storage.storeNames.deviceIdentities]);try{let o;try{o=e.writeIsTrackingMembers(!0,r);const a=Array.from(i.members.values());s.set("members",a.length),await Promise.all(a.map(async c=>{ze(c.membership,t)?await this._addRoomToUserIdentity(c.roomId,c.userId,r):await this._removeRoomFromUserIdentity(c.roomId,c.userId,r)}))}catch(a){throw r.abort(),a}await r.complete(),e.applyIsTrackingMembersChanges(o)}finally{i.release()}}async getCrossSigningKeysForUser(e,t,s){return await s.wrap("DeviceTracker.getMasterKeyForUser",async i=>{let r=await this._storage.readTxn([this._storage.storeNames.userIdentities]),o=await r.userIdentities.get(e);return o&&o.deviceTrackingStatus!==Pe?o.crossSigningKeys:(await this._queryKeys([e],t,i),r=await this._storage.readTxn([this._storage.storeNames.userIdentities]),o=await r.userIdentities.get(e),o?.crossSigningKeys)})}async writeHistoryVisibility(e,t,s,i){const r=[],o=[];return e.isTrackingMembers&&e.isEncrypted&&await i.wrap("rewriting userIdentities",async a=>{const c=await e.loadMemberList(s,a);try{const d=Array.from(c.members.values());a.set("members",d.length),await Promise.all(d.map(async h=>{ze(h.membership,t)?await this._addRoomToUserIdentity(h.roomId,h.userId,s)&&r.push(h.userId):await this._removeRoomFromUserIdentity(h.roomId,h.userId,s)&&o.push(h.userId)}))}finally{c.release()}}),{added:r,removed:o}}async _addRoomToUserIdentity(e,t,s){const{userIdentities:i}=s,r=await i.get(t),o=Pa(r,t,e);return o?(i.set(o),!0):!1}async _removeRoomFromUserIdentity(e,t,s){const{userIdentities:i,deviceIdentities:r}=s,o=await i.get(t);return o?(o.roomIds=o.roomIds.filter(a=>a!==e),o.roomIds.length===0?(i.remove(t),r.removeAllForUser(t)):i.set(o),!0):!1}async _queryKeys(e,t,s){const i=await t.queryKeys({timeout:1e4,device_keys:e.reduce((h,l)=>(h[l]=[],h),{}),token:this._getSyncToken()},{log:s}).response(),r=s.wrap("master keys",h=>this._filterValidMasterKeys(i,h)),o=s.wrap("self-signing keys",h=>this._filterVerifiedCrossSigningKeys(i.self_signing_keys,"self_signing",r,h)),a=s.wrap("verify",h=>this._filterVerifiedDeviceKeys(i.device_keys,h)),c=await this._storage.readWriteTxn([this._storage.storeNames.userIdentities,this._storage.storeNames.deviceIdentities]);let d;try{d=(await Promise.all(a.map(async({userId:l,verifiedKeys:u})=>{const p=u.map(Si),m={masterKey:r.get(l),selfSigningKey:o.get(l)};return await this._storeQueriedDevicesForUserId(l,m,p,c)}))).reduce((l,u)=>l.concat(u),[]),s.set("devices",d.length)}catch(h){throw c.abort(),h}return await c.complete(),d}async _storeQueriedDevicesForUserId(e,t,s,i){const r=await i.deviceIdentities.getAllDeviceIds(e);for(const d of r)s.every(h=>h.deviceId!==d)&&i.deviceIdentities.remove(e,d);const o=[],a=[];await Promise.all(s.map(async d=>{if(r.includes(d.deviceId)){const h=await i.deviceIdentities.get(d.userId,d.deviceId);if(h.ed25519Key!==d.ed25519Key){o.push(h);return}}o.push(d),a.push(d)}));for(const d of a)i.deviceIdentities.set(d);let c=await i.userIdentities.get(e);return c||(c=Ii(e)),c.deviceTrackingStatus=Xt,c.crossSigningKeys=t,i.userIdentities.set(c),o}_filterValidMasterKeys(e,t){const s=new Map,i=e.master_keys;return i&&Object.entries(i).filter(([o,a])=>!(a.user_id!==o||!Array.isArray(a.usage)||!a.usage.includes("master"))).reduce((o,[a,c])=>{const d=Object.keys(c.keys);if(d.length!==1)return!1;const h=c.keys[d[0]];return o.set(a,h),o},s),s}_filterVerifiedCrossSigningKeys(e,t,s,i){const r=new Map;return e&&Object.entries(e).filter(([a,c])=>{if(c.user_id!==a||!Array.isArray(c.usage)||!c.usage.includes(t))return!1;const d=s.get(a);return St(this._olmUtil,a,d,d,c,i)}).reduce((a,[c,d])=>{const h=Object.keys(d.keys);if(h.length!==1)return!1;const l=d.keys[h[0]];return a.set(c,l),a},r),r}_filterVerifiedDeviceKeys(e,t){const s=new Set;return Object.entries(e).map(([r,o])=>{const c=Object.entries(o).filter(([d,h])=>{const l=h.device_id;if(h.user_id!==r||l!==d)return!1;const p=h.keys?.[`ed25519:${d}`],m=h.keys?.[`curve25519:${d}`];if(typeof p!="string"||typeof m!="string")return!1;if(s.has(m))return t.log({l:"ignore device with duplicate curve25519 key",keys:h},t.level.Warn),!1;s.add(m);const _=this._hasValidSignature(h,t);return _||t.log({l:"ignore device with invalid signature",keys:h},t.level.Warn),_}).map(([,d])=>d);return{userId:r,verifiedKeys:c}})}_hasValidSignature(e,t){const s=e.device_id,i=e.user_id,r=e?.keys?.[`${vs}:${s}`];return St(this._olmUtil,i,s,r,e,t)}async devicesForTrackedRoom(e,t,s){const i=await this._storage.readTxn([this._storage.storeNames.roomMembers,this._storage.storeNames.userIdentities]),r=await i.roomMembers.getAllUserIds(e);return await this._devicesForUserIdsInTrackedRoom(e,r,i,t,s)}async devicesForRoomMembers(e,t,s,i){const r=await this._storage.readTxn([this._storage.storeNames.userIdentities]);return await this._devicesForUserIdsInTrackedRoom(e,t,r,s,i)}async devicesForUsers(e,t,s){const i=await this._storage.readTxn([this._storage.storeNames.userIdentities]),r=[],o=[];return await Promise.all(e.map(async a=>{const c=await i.userIdentities.get(a);c&&c.deviceTrackingStatus===Xt?r.push(c):(!c||c.deviceTrackingStatus===Pe)&&o.push(a)})),this._devicesForUserIdentities(r,o,t,s)}async deviceForId(e,t,s,i){let o=await(await this._storage.readTxn([this._storage.storeNames.deviceIdentities])).deviceIdentities.get(e,t);if(o)i.set("existingDevice",!0);else{const a=await s.queryKeys({timeout:1e4,device_keys:{[e]:[t]},token:this._getSyncToken()},{log:i}).response(),d=i.wrap("verify",u=>this._filterVerifiedDeviceKeys(a.device_keys,u)).find(u=>u.userId===e).verifiedKeys.find(u=>u.device_id===t);if(!d)return;o=Si(d);const h=await this._storage.readWriteTxn([this._storage.storeNames.deviceIdentities]),l=await h.deviceIdentities.get(e,t);if(l)o=l,i.set("existingDeviceAfterFetch",!0);else{try{h.deviceIdentities.set(o),i.set("newDevice",!0)}catch(u){throw h.abort(),u}await h.complete()}}return o}async _devicesForUserIdsInTrackedRoom(e,t,s,i,r){const a=(await Promise.all(t.map(l=>s.userIdentities.get(l)))).filter(l=>l&&l.roomIds.includes(e)),c=a.filter(l=>l.deviceTrackingStatus===Xt),d=a.filter(l=>l.deviceTrackingStatus===Pe).map(l=>l.userId);let h=await this._devicesForUserIdentities(c,d,i,r);return h=h.filter(l=>!(l.userId===this._ownUserId&&l.deviceId===this._ownDeviceId)),h}async _devicesForUserIdentities(e,t,s,i){i.set("uptodate",e.length),i.set("outdated",t.length);let r;t.length&&(r=await this._queryKeys(t,s,i));const o=await this._storage.readTxn([this._storage.storeNames.deviceIdentities]);let c=(await Promise.all(e.map(d=>o.deviceIdentities.getAllForUserId(d.userId)))).reduce((d,h)=>d.concat(h),[]);return r&&r.length&&(c=c.concat(r)),c}async getDeviceByCurve25519Key(e,t){return await t.deviceIdentities.getByCurve25519Key(e)}}class Na{constructor(){this._map=new Map}async takeLock(e){let t=this._map.get(e);return t?await t.take():(t=new ai,t.tryTake(),this._map.set(e,t)),t.released().then(()=>{Promise.resolve().then(()=>{t.isTaken||this._map.delete(e)})}),t}}class Ba{constructor({key:e,platform:t}){this._key=e,this._platform=t}async readSecret(e,t){const s=await t.accountData.get(e);if(!s)return;const i=s?.content?.encrypted?.[this._key.id];if(!i)throw new Error(`Secret ${s.type} is not encrypted for key ${this._key.id}`);if(this._key.algorithm==="m.secret_storage.v1.aes-hmac-sha2")return await this._decryptAESSecret(s.type,i);throw new Error(`Unsupported algorithm for key ${this._key.id}: ${this._key.algorithm}`)}async _decryptAESSecret(e,t){const{base64:s,utf8:i}=this._platform.encoding,r=await this._platform.crypto.derive.hkdf(this._key.binaryKey,new Uint8Array(8).buffer,i.encode(e),"SHA-256",512),o=r.slice(0,32),a=r.slice(32),c=s.decode(t.ciphertext);if(!await this._platform.crypto.hmac.verify(a,s.decode(t.mac),c,"SHA-256"))throw new Error("Bad MAC");const h=await this._platform.crypto.aes.decryptCTR({key:o,iv:s.decode(t.iv),data:c});return i.decode(h)}}function Ei(n,e,t=!1){for(const[s,i]of Object.entries(e)){if(n[s]instanceof Object&&i){Ei(n[s],i);continue}if(i!=null||!t){n[s]=i;continue}}return n}/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */var Zt=(n=>(n.Video="video",n.Audio="audio",n))(Zt||{});function Oe(n){return n?.getAudioTracks()[0]}function Ie(n){return n?.getVideoTracks()[0]}function es(n,e,t){return t.wrap("mute",s=>{s.set("cameraMuted",e.camera),s.set("microphoneMuted",e.microphone);const i=Oe(n.userMedia);if(i){const o=!e.microphone;s.set("microphone enabled",o),i.enabled=o}const r=Ie(n.userMedia);if(r){const o=!e.camera;s.set("camera enabled",o),r.enabled=o}})}class Se{constructor(e=!1,t=!1,s=!1,i=!1){this.isMicrophoneMuted=e,this.isCameraMuted=t,this.hasMicrophoneTrack=s,this.hasCameraTrack=i}updateTrackInfo(e){this.hasMicrophoneTrack=!!Oe(e),this.hasCameraTrack=!!Ie(e)}get microphone(){return!this.hasMicrophoneTrack||this.isMicrophoneMuted}get camera(){return!this.hasCameraTrack||this.isCameraMuted}toggleCamera(){return new Se(this.microphone,!this.camera,this.hasMicrophoneTrack,this.hasCameraTrack)}toggleMicrophone(){return new Se(!this.microphone,this.camera,this.hasMicrophoneTrack,this.hasCameraTrack)}equals(e){return this.microphone===e.microphone&&this.camera===e.camera}}const ue="call",ts=3600*1e3;var y=(n=>(n.GroupCall="org.matrix.msc3401.call",n.GroupCallMember="org.matrix.msc3401.call.member",n.Invite="m.call.invite",n.Candidates="m.call.candidates",n.Answer="m.call.answer",n.Hangup="m.call.hangup",n.Reject="m.call.reject",n.SelectAnswer="m.call.select_answer",n.Negotiate="m.call.negotiate",n.SDPStreamMetadataChanged="m.call.sdp_stream_metadata_changed",n.SDPStreamMetadataChangedPrefix="org.matrix.call.sdp_stream_metadata_changed",n.Replaces="m.call.replaces",n.AssertedIdentity="m.call.asserted_identity",n.AssertedIdentityPrefix="org.matrix.call.asserted_identity",n))(y||{});const W="org.matrix.msc3077.sdp_stream_metadata";var me=(n=>(n.Usermedia="m.usermedia",n.Screenshare="m.screenshare",n))(me||{}),w=(n=>(n.UserHangup="user_hangup",n.LocalOfferFailed="local_offer_failed",n.NoUserMedia="no_user_media",n.UnknownDevices="unknown_devices",n.SendInvite="send_invite",n.CreateAnswer="create_answer",n.SendAnswer="send_answer",n.SetRemoteDescription="set_remote_description",n.SetLocalDescription="set_local_description",n.AnsweredElsewhere="answered_elsewhere",n.IceFailed="ice_failed",n.InviteTimeout="invite_timeout",n.Replaced="replaced",n.SignallingFailed="signalling_timeout",n.UserBusy="user_busy",n.Transfered="transferred",n.NewSession="new_session",n))(w||{}),Ne=(n=>(n.Ring="m.ring",n.Prompt="m.prompt",n.Room="m.room",n))(Ne||{}),ss=(n=>(n[n.InviteGlare=0]="InviteGlare",n[n.Handle=1]="Handle",n[n.Ignore=2]="Ignore",n))(ss||{});class La{constructor(e,t){this.userMedia=e,this.screenShare=t}}class qa{constructor(e,t,s){this.callId=e,this.options=t,this.logItem=s,this._state=f.Fledgling,this.candidateSendQueue=[],this.remoteCandidateBuffer=new Map,this.disposables=new Qs,this.statePromiseMap=new Map,this._remoteTrackToStreamId=new Map,this._remoteStreams=new Map,this.makingOffer=!1,this.ignoreOffer=!1,this.sentEndOfCandidates=!1,this._remoteMuteSettings=new Se,this.onIceConnectionStateChange=async(r,o)=>{if(this._state===f.Ended)return;let a=!1;if(r=="connected")this.iceDisconnectedTimeout?.abort(),this.iceDisconnectedTimeout=void 0,this.setState(f.Connected,o);else if(r=="failed")a=!0,this.iceDisconnectedTimeout?.abort(),this.iceDisconnectedTimeout=void 0,await this._hangup(w.IceFailed,o);else if(r=="disconnected"){a=!0,this.iceDisconnectedTimeout=this.options.createTimeout(30*1e3);try{await this.iceDisconnectedTimeout.elapsed(),await this._hangup(w.IceFailed,o)}catch(c){if(!(c instanceof L))throw c}}if(a){const c=await this.peerConnection.getStats(),d={};c.forEach((h,l)=>{d[l]=h}),o.set("peerConnectionStats",d)}},s.log({l:"create PeerCall",id:e}),this._remoteMedia=new La,this.peerConnection=t.webRTC.createPeerConnection(this.options.forceTURN,[this.options.turnServer.get()],0),this.disposables.track(this.options.turnServer.subscribe(r=>{this.logItem.log({l:"updating turn server",turnServer:r}),this.peerConnection.setConfiguration({iceServers:[r]})}));const i=(r,o,a)=>{const c=h=>{this.options.errorBoundary.try(()=>o(h))};this.peerConnection.addEventListener(r,c);const d=()=>{this.peerConnection.removeEventListener(r,c)};this.disposables.track(d)};i("iceconnectionstatechange",async()=>{const r=this.peerConnection.iceConnectionState;await s.wrap({l:"onIceConnectionStateChange",status:r},async o=>{await this.onIceConnectionStateChange(r,o)})}),i("icecandidate",async r=>{await s.wrap("onLocalIceCandidate",async o=>{r.candidate&&await this.handleLocalIceCandidate(r.candidate,o)})}),i("icegatheringstatechange",async()=>{const r=this.peerConnection.iceGatheringState;await s.wrap({l:"onIceGatheringStateChange",status:r},async o=>{await this.handleIceGatheringState(r,o)})}),i("track",r=>{s.wrap("onRemoteTrack",o=>{this.onRemoteTrack(r.track,r.streams,o)})}),i("datachannel",r=>{s.wrap("onRemoteDataChannel",o=>{this._dataChannel=r.channel,this.options.emitUpdate(this,void 0,o)})}),i("negotiationneeded",()=>{const r=this.peerConnection.signalingState,o=()=>s.wrap({l:"onNegotiationNeeded",signalingState:r},a=>this.handleNegotiation(a));this.responsePromiseChain=this.responsePromiseChain?.then(o)??o(),this.responsePromiseChain.catch(a=>this.options.errorBoundary.reportError(a))})}get dataChannel(){return this._dataChannel}get state(){return this._state}get hangupReason(){return this._hangupReason}get remoteMedia(){return this._remoteMedia}get remoteMuteSettings(){return this._remoteMuteSettings}call(e,t,s){return s.wrap("call",async i=>{this._state===f.Fledgling&&(i.set("signalingState",this.peerConnection.signalingState),this.direction=Be.Outbound,this.setState(f.CreateOffer,i),this.localMuteSettings=t,await this.updateLocalMedia(e,i),this.localMedia?.dataChannelOptions&&(this._dataChannel=this.peerConnection.createDataChannel("channel",this.localMedia.dataChannelOptions)),await this.waitForState([f.InviteSent,f.CreateAnswer]))})}answer(e,t,s){return s.wrap("answer",async i=>{if(this._state!==f.Ringing)return;this.setState(f.CreateAnswer,i),this.localMuteSettings=t,await this.updateLocalMedia(e,i);let r;try{r=await this.peerConnection.createAnswer()}catch(o){await i.wrap("Failed to create answer",a=>{a.catch(o),this.terminate(x.Local,w.CreateAnswer,a)});return}try{await this.peerConnection.setLocalDescription(r),this.setState(f.Connecting,i)}catch(o){await i.wrap("Error setting local description!",a=>{a.catch(o),this.terminate(x.Local,w.SetLocalDescription,a)});return}try{await this.delay(200)}catch{return}await this.sendAnswer(i)})}setMedia(e,t){return t.wrap("setMedia",async s=>{s.set("userMedia_audio",!!Oe(e.userMedia)),s.set("userMedia_video",!!Ie(e.userMedia)),s.set("screenShare_video",!!Ie(e.screenShare)),s.set("datachannel",!!e.dataChannelOptions),await this.updateLocalMedia(e,s);const i={call_id:this.callId,version:1,[W]:this.getSDPMetadata()};await this.sendSignallingMessage({type:y.SDPStreamMetadataChangedPrefix,content:i},s)})}setMuted(e,t){return t.wrap("setMuted",async s=>{if(this.localMuteSettings=e,s.set("cameraMuted",e.camera),s.set("microphoneMuted",e.microphone),this.localMedia){es(this.localMedia,e,s);const i={call_id:this.callId,version:1,[W]:this.getSDPMetadata()};await this.sendSignallingMessage({type:y.SDPStreamMetadataChangedPrefix,content:i},s)}})}hangup(e,t){return t.wrap("hangup",s=>this._hangup(e,s))}async _hangup(e,t){this._state===f.Ended||this._state===f.Ending||(this.setState(f.Ending,t),await this.sendHangupWithCallId(this.callId,e,t),this.terminate(x.Local,e,t))}getMessageAction(e){const t=this.callId===e.content.call_id;return e.type===y.Invite&&!t?0:t?1:2}handleIncomingSignallingMessage(e,t,s){let i;return s.wrap({l:"receive signalling message",type:e.type,callId:e.content.call_id,payload:e.content},async r=>{if(i=r,this.getMessageAction(e)!==1){r.set("wrongCallId",!0);return}switch(e.type){case y.Invite:await this.handleFirstInvite(e.content,t,r);break;case y.Answer:await this.handleAnswer(e.content,t,r);break;case y.Negotiate:await this.onNegotiateReceived(e.content,r);break;case y.Candidates:await this.handleRemoteIceCandidates(e.content,t,r);break;case y.SDPStreamMetadataChanged:case y.SDPStreamMetadataChangedPrefix:this.updateRemoteSDPStreamMetadata(e.content[W],r);break;case y.Hangup:r.set("reason",e.content.reason),this.terminate(x.Remote,e.content.reason??w.UserHangup,r);break;default:r.log(`Unknown event type for call: ${e.type}`);break}}),i}sendHangupWithCallId(e,t,s){const i={call_id:e,version:1};return t&&(i.reason=t),this.sendSignallingMessage({type:y.Hangup,content:i},s)}async handleNegotiation(e){this.makingOffer=!0;try{try{await this.peerConnection.setLocalDescription()}catch(s){e.log("Error setting local description!").catch(s),this.terminate(x.Local,w.SetLocalDescription,e);return}if(this.peerConnection.iceGatheringState==="gathering")try{await this.delay(200)}catch{return}if(this._state===f.Ended)return;const t=this.peerConnection.localDescription;if(e.set("includedCandidates",this.candidateSendQueue.length),this.candidateSendQueue=[],this._state===f.CreateOffer){const s={call_id:this.callId,offer:t,[W]:this.getSDPMetadata(),version:1,lifetime:Le};await this.sendSignallingMessage({type:y.Invite,content:s},e),this.setState(f.InviteSent,e)}else if(this._state===f.Connected||this._state===f.Connecting){const s={call_id:this.callId,description:t,[W]:this.getSDPMetadata(),version:1,lifetime:Le};await this.sendSignallingMessage({type:y.Negotiate,content:s},e)}}finally{this.makingOffer=!1}if(this.sendCandidateQueue(e),this._state===f.InviteSent){const t=this.logItem.child("invite timeout");e.refDetached(t),await t.run(async s=>{try{await this.delay(Le)}catch{return}this._state===f.InviteSent&&await this._hangup(w.InviteTimeout,s)})}}handleInviteGlare(e,t,s){if(e.type!==y.Invite)return{shouldReplace:!1};const{content:i}=e,r=i.call_id,o=this.callId>r;let a;return s.wrap("handling call glare",async c=>{a=c,o?(c.log("Glare detected: answering incoming call "+r+" and canceling outgoing call "),this._state!==f.Fledgling&&this._state!==f.CreateOffer&&await this.sendHangupWithCallId(this.callId,w.Replaced,c),this.close(w.Replaced,c),this.dispose()):(c.log("Glare detected: rejecting incoming call "+r+" and keeping outgoing call "),await this.sendHangupWithCallId(r,w.Replaced,c))}),{shouldReplace:o,log:a}}handleHangupReceived(e,t){this.terminate(x.Remote,e.reason||w.UserHangup,t)}async handleFirstInvite(e,t,s){this._state!==f.Fledgling||this.opponentPartyId!==void 0||await this.handleInvite(e,t,s)}async handleInvite(e,t,s){this.opponentPartyId=t,this.direction=Be.Inbound;const i=e[W];i?this.updateRemoteSDPStreamMetadata(i,s):s.log("Call did not get any SDPStreamMetadata! Can not send/receive multiple streams");try{await this.peerConnection.setRemoteDescription(e.offer),await this.addBufferedIceCandidates(s)}catch(r){await s.wrap("Call failed to set remote description",async o=>(o.catch(r),this.terminate(x.Local,w.SetRemoteDescription,o)));return}if(this.peerConnection.getReceivers().length===0){await s.wrap("Call no remote stream or no tracks after setting remote description!",async r=>this.terminate(x.Local,w.SetRemoteDescription,r));return}this.setState(f.Ringing,s);try{await this.delay(e.lifetime??Le)}catch{return}this._state===f.Ringing&&(s.log("Invite has expired. Hanging up."),this.hangupParty=x.Remote,this.setState(f.Ended,s),this.peerConnection.signalingState!="closed"&&this.peerConnection.close())}async handleAnswer(e,t,s){if(this._state===f.Ended){s.log("Ignoring answer because call has ended");return}if(this.opponentPartyId!==void 0){s.log(`Ignoring answer: we already have an answer/reject from ${this.opponentPartyId}`);return}this.opponentPartyId=t,await this.addBufferedIceCandidates(s),this.setState(f.Connecting,s);const i=e[W];i?this.updateRemoteSDPStreamMetadata(i,s):s.log("Did not get any SDPStreamMetadata! Can not send/receive multiple streams");try{await this.peerConnection.setRemoteDescription(e.answer)}catch(r){await s.wrap("Failed to set remote description",o=>{o.catch(r),this.terminate(x.Local,w.SetRemoteDescription,o)});return}}async handleIceGatheringState(e,t){if(e==="complete"&&!this.sentEndOfCandidates){const s={candidate:""};await this.queueCandidate(s,t),this.sentEndOfCandidates=!0}}async handleLocalIceCandidate(e,t){t.set("sdpMid",e.sdpMid),t.set("candidate",e.candidate),this._state!==f.Ended&&(e.candidate!==""||!this.sentEndOfCandidates)&&(await this.queueCandidate(e,t),e.candidate===""&&(this.sentEndOfCandidates=!0))}async handleRemoteIceCandidates(e,t,s){if(this.state===f.Ended){s.log("Ignoring remote ICE candidate because call has ended");return}const i=e.candidates;if(!i){s.log("Ignoring candidates event with no candidates!");return}const r=e.version===0?null:t||null;if(this.opponentPartyId===void 0){s.log(`Buffering ${i.length} candidates until we pick an opponent`);const o=this.remoteCandidateBuffer.get(r)||[];o.push(...i),this.remoteCandidateBuffer.set(r,o);return}if(this.opponentPartyId!==t){s.log(`Ignoring candidates from party ID ${t}: we have chosen party ID ${this.opponentPartyId}`);return}await this.addIceCandidates(i,s)}async onNegotiateReceived(e,t){const s=e.description;if(!s||!s.sdp||!s.type){t.log("Ignoring invalid m.call.negotiate event");return}const i=this.direction===Be.Inbound,r=s.type==="offer"&&(this.makingOffer||this.peerConnection.signalingState!=="stable");if(this.ignoreOffer=!i&&r,this.ignoreOffer){t.log("Ignoring colliding negotiate event because we're impolite");return}const o=e[W];o?this.updateRemoteSDPStreamMetadata(o,t):t.log("Received negotiation event without SDPStreamMetadata!");try{if(await this.peerConnection.setRemoteDescription(s),s.type==="offer"){await this.peerConnection.setLocalDescription();const a={call_id:this.callId,description:this.peerConnection.localDescription,[W]:this.getSDPMetadata(),version:1,lifetime:Le};await this.sendSignallingMessage({type:y.Negotiate,content:a},t)}}catch(a){t.log("Failed to complete negotiation").catch(a)}}async sendAnswer(e){const t=this.peerConnection.localDescription,s={call_id:this.callId,version:1,answer:{sdp:t.sdp,type:t.type},[W]:this.getSDPMetadata()};e.log(`Discarding ${this.candidateSendQueue.length} candidates that will be sent in answer`),this.candidateSendQueue=[];try{await this.sendSignallingMessage({type:y.Answer,content:s},e)}catch(i){throw this.terminate(x.Local,w.SendAnswer,e),i}this.sendCandidateQueue(e)}async queueCandidate(e,t){if(this.candidateSendQueue.push(e),this._state===f.Ringing)return;this.flushCandidatesLog=this.flushCandidatesLog??this.logItem.child("flush candidate queue"),t.refDetached(this.flushCandidatesLog);const{flushCandidatesLog:s}=this;try{await this.delay(this.direction===Be.Inbound?500:2e3)}catch{return}this.sendCandidateQueue(s),this.flushCandidatesLog=void 0}async sendCandidateQueue(e){if(this.candidateSendQueue.length===0||this._state===f.Ended)return;const t=this.candidateSendQueue;return this.candidateSendQueue=[],e.wrap({l:"send candidates",size:t.length},async s=>{try{await this.sendSignallingMessage({type:y.Candidates,content:{call_id:this.callId,version:1,candidates:t}},s),await this.sendCandidateQueue(s)}catch(i){s.catch(i),this.terminate(x.Local,w.SignallingFailed,s)}})}updateRemoteSDPStreamMetadata(e,t){this.remoteSDPStreamMetadata=Ei(this.remoteSDPStreamMetadata||{},e,!0),this.updateRemoteMedia(t)}async addBufferedIceCandidates(e){if(this.remoteCandidateBuffer&&this.opponentPartyId){const t=this.remoteCandidateBuffer.get(this.opponentPartyId);t&&(e.log(`Adding ${t.length} buffered candidates for opponent ${this.opponentPartyId}`),await this.addIceCandidates(t,e)),this.remoteCandidateBuffer=void 0}}async addIceCandidates(e,t){for(const s of e){let i;(s.sdpMid===null||s.sdpMid===void 0)&&(s.sdpMLineIndex===null||s.sdpMLineIndex===void 0)?i=t.log("Got remote end-of-ICE candidates"):i=t.log(`Adding remote ICE ${s.sdpMid} candidate: ${s.candidate}`);try{await this.peerConnection.addIceCandidate(s)}catch(r){this.ignoreOffer||i.catch(r)}}}setState(e,t){if(e!==this._state){t.log({l:"change state",status:e,oldState:this._state}),this._state,this._state=e;let s=this.statePromiseMap.get(e);s&&(s.resolve(),this.statePromiseMap.delete(e)),this.options.emitUpdate(this,void 0,t)}}waitForState(e){return Promise.race(e.map(t=>{let s=this.statePromiseMap.get(t);if(!s){let i;const r=new Promise(o=>{i=o});s={resolve:i,promise:r},this.statePromiseMap.set(t,s)}return s.promise}))}terminate(e,t,s){this._state!==f.Ended&&(this.hangupParty=e,this._hangupReason=t,this.setState(f.Ended,s),this.localMedia=void 0,this.peerConnection&&this.peerConnection.signalingState!=="closed"&&this.peerConnection.close())}getSDPMetadata(){const e={};if(this.localMedia?.userMedia){const t=this.localMedia.userMedia.id;e[t]={purpose:me.Usermedia,audio_muted:this.localMuteSettings?.microphone??!1,video_muted:this.localMuteSettings?.camera??!1}}if(this.localMedia?.screenShare){const t=this.localMedia.screenShare.id;e[t]={purpose:me.Screenshare}}return e}findReceiverForStream(e,t){return this.peerConnection.getReceivers().find(s=>s.track.kind===e&&this._remoteTrackToStreamId.get(s.track.id)===t)}findTransceiverForTrack(e){return this.peerConnection.getTransceivers().find(t=>t.sender.track?.id===e.id)}onRemoteTrack(e,t,s){if(s.set("kind",e.kind),s.set("id",e.id),s.set("streams",t.map(r=>r.id)),t.length===0){s.log({l:`ignoring ${e.kind} streamless track`,id:e.id});return}const i=t[0];if(this._remoteTrackToStreamId.set(e.id,i.id),!this._remoteStreams.has(i.id)){const r=a=>{this.logItem.wrap({l:"removetrack",id:a.track.id},c=>{const d=this._remoteTrackToStreamId.get(a.track.id);if(d){this._remoteTrackToStreamId.delete(a.track.id);const h=this._remoteStreams.get(d);h&&h.stream.getTracks().length===0&&(this.disposables.disposeTracked(o),this._remoteStreams.delete(i.id),this.updateRemoteMedia(c))}})};i.addEventListener("removetrack",r);const o=()=>{i.removeEventListener("removetrack",r)};this.disposables.track(o),this._remoteStreams.set(i.id,{disposeListener:o,stream:i})}this.updateRemoteMedia(s)}updateRemoteMedia(e){e.wrap("reevaluating remote media",t=>{if(this._remoteMedia.userMedia=void 0,this._remoteMedia.screenShare=void 0,this.remoteSDPStreamMetadata)for(const s of this._remoteStreams.values()){const{stream:i}=s,r=this.remoteSDPStreamMetadata[i.id];if(r)if(r.purpose===me.Usermedia){this._remoteMedia.userMedia=i;const o=this.findReceiverForStream(Zt.Audio,i.id);o&&(o.track.enabled=!r.audio_muted);const a=this.findReceiverForStream(Zt.Video,i.id);a&&(a.track.enabled=!r.video_muted),this._remoteMuteSettings=new Se(r.audio_muted??!1,r.video_muted??!1,!!o?.track,!!a?.track),t.log({l:"setting userMedia",micMuted:this._remoteMuteSettings.microphone,cameraMuted:this._remoteMuteSettings.camera})}else r.purpose===me.Screenshare&&(this._remoteMedia.screenShare=i,t.log("setting screenShare"));else t.log({l:"no metadata yet for stream, ignoring for now",id:i.id})}this.options.emitUpdate(this,void 0,t)})}updateLocalMedia(e,t){return t.wrap("updateLocalMedia",async s=>{const i=this.peerConnection.getSenders(),r=async(o,a,c)=>{const d=async(h,l)=>{const u=i.find(m=>m.track===h),p=o??a;if(p!==a&&(h&&(p.removeTrack(h),h.stop()),l&&p.addTrack(l)),l&&u)try{await s.wrap(`attempting to replace ${c} ${l.kind} track`,m=>u.replaceTrack(l));return}catch{}u&&s.wrap(`removing ${c} ${u.track.kind} track`,m=>{this.peerConnection.removeTrack(u)}),l&&s.wrap(`adding ${c} ${l.kind} track`,m=>{const _=this.peerConnection.addTrack(l,p);this.options.webRTC.prepareSenderForPurpose(this.peerConnection,_,c)})};!o&&!a||(await d(Oe(o),Oe(a)),await d(Ie(o),Ie(a)))};await r(this.localMedia?.userMedia,e?.userMedia,me.Usermedia),await r(this.localMedia?.screenShare,e?.screenShare,me.Screenshare),this.localMedia||(this.localMedia=e)})}async delay(e){const t=this.disposables.track(this.options.createTimeout(e));try{await t.elapsed()}finally{this.disposables.untrack(t)}}sendSignallingMessage(e,t){return t.wrap({l:"send",id:e.type},async s=>this.options.sendSignallingMessage(e,s))}dispose(){this.disposables.dispose(),this.iceDisconnectedTimeout?.abort(),this.peerConnection.close(),this.options.emitUpdate=(e,t,s)=>{s.log("emitting update from PeerCall after disposal",this.logItem.level.Error),console.trace("emitting update from PeerCall after disposal")}}close(e,t){e===void 0&&(e=w.UserHangup),this.terminate(x.Local,e,t)}}var x=(n=>(n.Local="local",n.Remote="remote",n))(x||{}),f=(n=>(n.Fledgling="fledgling",n.CreateOffer="create_offer",n.InviteSent="invite_sent",n.CreateAnswer="create_answer",n.Connecting="connecting",n.Connected="connected",n.Ringing="ringing",n.Ending="ending",n.Ended="ended",n))(f||{}),Be=(n=>(n.Inbound="inbound",n.Outbound="outbound",n))(Be||{});const Le=6e4;function ja(n){return n===y.Invite||n===y.Candidates||n===y.Answer||n===y.Hangup||n===y.SDPStreamMetadataChanged||n===y.SDPStreamMetadataChangedPrefix||n===y.Negotiate}class Ri{constructor(e){this.errorCallback=e}try(e,t){try{let s=e();return s instanceof Promise&&(s=s.catch(i=>(this._error=i,this.reportError(i),t))),s}catch(s){return this._error=s,this.reportError(s),t}}reportError(e){try{this.errorCallback(e)}catch(t){console.error("error in ErrorBoundary callback",t)}}get error(){return this._error}}const $a=[w.UserHangup,w.AnsweredElsewhere,w.Replaced,w.UserBusy,w.Transfered,w.NewSession];class Wa{constructor(e,t,s,i){this.localMedia=e,this.localMuteSettings=t,this.turnServer=s,this.logItem=i,this.retryCount=0,this.queuedSignallingMessages=[],this.outboundSeqCounter=0}get canDequeueNextSignallingMessage(){if(this.queuedSignallingMessages.length===0)return!1;const t=this.queuedSignallingMessages[0].content.seq;return this.lastIgnoredSeqNr!==void 0&&t===this.lastIgnoredSeqNr+1?!0:this.lastProcessedSeqNr===void 0?t===0:t<=this.lastProcessedSeqNr+1}dispose(){this.peerCall?.dispose(),this.localMedia.dispose(),this.logItem.finish()}}class Ga{constructor(e,t,s,i){this.member=e,this.callDeviceMembership=t,this.options=s,this.errorBoundary=new Ri(r=>{this.options.emitUpdate(this,"error"),this.connection&&this.connection.logItem.log("error at boundary").catch(r)}),this.emitUpdateFromPeerCall=async(r,o,a)=>{const c=this.connection;if(r.state===f.Ringing)c.logItem.wrap("ringing, answer peercall",d=>(a.refDetached(d),r.answer(c.localMedia,c.localMuteSettings,d)));else if(r.state===f.Ended){const d=r.hangupReason;if(r.dispose(),c.peerCall=void 0,d&&!$a.includes(d)){c.retryCount+=1;const{retryCount:h}=c;await c.logItem.wrap({l:"retry connection",retryCount:h},async l=>{if(a.refDetached(l),h<=3)await this.callIfNeeded(l);else{const u=await this.disconnect(!1);u&&l.refDetached(u)}})}}this.options.emitUpdate(this,o)},this.sendSignallingMessage=async(r,o)=>{const a=r;a.content.seq=this.connection.outboundSeqCounter++,a.content.conf_id=this.options.confId,a.content.device_id=this.options.ownDeviceId,a.content.party_id=this.options.ownDeviceId,a.content.sender_session_id=this.options.sessionId,a.content.dest_session_id=this.sessionId;let c,d=r.type;const h=await this.options.encryptDeviceMessage(this.member.userId,this.deviceId,a,o);h?(c=qt(h),d="m.room.encrypted"):c=qt([{content:a.content,device:this}]),o.set("payload",a.content),await this.options.hsApi.sendToDevice(d,c,ot(),{log:o}).response()},this._renewExpireTimeout(i)}get error(){return this.errorBoundary.error}get usesFoci(){const e=this.callDeviceMembership["m.foci.active"];return Array.isArray(e)&&e.length>0}_renewExpireTimeout(e){this.expireTimeout?.dispose(),this.expireTimeout=void 0;const t=mt(this.callDeviceMembership);if(typeof t!="number")return;const s=Math.max(0,t-this.options.clock.now());e?.set("expiresIn",s),this.expireTimeout=this.options.clock.createTimeout(s+10),this.expireTimeout.elapsed().then(()=>{this.options.emitUpdate(this,"isExpired")},i=>{})}get logItem(){return this.connection?.logItem}get remoteMedia(){return this.connection?.peerCall?.remoteMedia}get isExpired(){return!this.isConnected&&is(this.callDeviceMembership,this.options.clock.now())}get remoteMuteSettings(){return this.connection?.peerCall?.remoteMuteSettings}get isConnected(){return this.connection?.peerCall?.state===f.Connected}get userId(){return this.member.userId}get deviceId(){return this.callDeviceMembership.device_id}get sessionId(){return this.callDeviceMembership.session_id}get dataChannel(){return this.connection?.peerCall?.dataChannel}connect(e,t,s,i){return this.errorBoundary.try(async()=>{if(this.connection)return;const r=new Wa(e.clone(),t,s,i);this.connection=r;let o;return await r.logItem.wrap("connect",async a=>{o=a,await this.callIfNeeded(a)}),o})}callIfNeeded(e){return e.wrap("callIfNeeded",async t=>{let s;if(this.member.userId===this.options.ownUserId?s=this.deviceId>this.options.ownDeviceId:s=this.member.userId>this.options.ownUserId,s){const i=this.connection;i.peerCall=this._createPeerCall(at("c")),await i.peerCall.call(i.localMedia,i.localMuteSettings,t)}else t.set("wait_for_invite",!0)})}disconnect(e){return this.errorBoundary.try(async()=>{const{connection:t}=this;if(!t)return;let s;return await t.logItem.wrap("disconnect",async i=>{s=i,e&&t.peerCall&&await t.peerCall.hangup(w.UserHangup,i)}),t.dispose(),this.connection=void 0,s})}updateCallInfo(e,t){this.errorBoundary.try(()=>{this.callDeviceMembership=e,this._renewExpireTimeout(t),this.connection&&this.connection.logItem.refDetached(t)})}updateRoomMember(e){this.member=e,this.options.emitUpdate(this)}handleDeviceMessage(e,t){this.errorBoundary.try(()=>{t.wrap({l:"Member.handleDeviceMessage",type:e.type,seq:e.content?.seq},s=>{const{connection:i}=this;if(i){const r=e.content.dest_session_id;if(r!==this.options.sessionId){const c=i.logItem.log({l:"ignoring to_device event with wrong session_id",destSessionId:r,type:e.type});s.refDetached(c);return}if(i.peerCall&&i.peerCall.getMessageAction(e)===ss.InviteGlare){const{shouldReplace:d,log:h}=i.peerCall.handleInviteGlare(e,this.deviceId,i.logItem);h&&h.refDetached(h),d&&(i.peerCall.dispose(),i.peerCall=void 0)}e.type===y.Invite&&!i.peerCall&&(i.peerCall=this._createPeerCall(e.content.call_id));const o=ne(i.queuedSignallingMessages,e,(c,d)=>c.content.seq-d.content.seq);i.queuedSignallingMessages.splice(o,0,e);let a=!1;i.peerCall&&(a=this.dequeueSignallingMessages(i,i.peerCall,e,s)),a||s.refDetached(i.logItem.log({l:"queued message",type:e.type,seq:e.content.seq,idx:o}))}else t.log({l:"member not connected",userId:this.userId,deviceId:this.deviceId})})})}dequeueSignallingMessages(e,t,s,i){let r=!1;for(;e.canDequeueNextSignallingMessage;){const o=e.queuedSignallingMessages.shift(),a=o===s;r=r||a,i.wrap(a?"process message":"dequeue message",c=>{const d=o.content?.seq;if(c.set("seq",d),c.set("type",o.type),t.getMessageAction(o)===ss.Handle){const l=t.handleIncomingSignallingMessage(o,this.deviceId,e.logItem);c.refDetached(l),e.lastProcessedSeqNr=d}else c.set("ignored",!0),e.lastIgnoredSeqNr=d})}return r}async setMedia(e,t){return this.errorBoundary.try(async()=>{const{connection:s}=this;s&&(s.localMedia=e.replaceClone(s.localMedia,t),await s.peerCall?.setMedia(s.localMedia,s.logItem))})}async setMuted(e){return this.errorBoundary.try(async()=>{const{connection:t}=this;t&&(t.localMuteSettings=e,await t.peerCall?.setMuted(e,t.logItem))})}_createPeerCall(e){const t=this.connection;return new qa(e,Object.assign({},this.options,{errorBoundary:this.errorBoundary,emitUpdate:this.emitUpdateFromPeerCall,sendSignallingMessage:this.sendSignallingMessage,turnServer:t.turnServer}),t.logItem)}dispose(){this.connection?.dispose(),this.connection=void 0,this.expireTimeout?.dispose(),this.expireTimeout=void 0,this.options.emitUpdate=()=>{}}}function mt(n){const e=n.expires_ts;if(Number.isSafeInteger(e))return e}function is(n,e,t=0){const s=mt(n);return typeof s=="number"?s+t<=e:!0}function Ee(n,e){return JSON.stringify(n)+","+JSON.stringify(e)}function ki(n,e){return n.startsWith(JSON.stringify(e)+",")}function Va(n){return JSON.parse(`[${n}]`)[1]}class Ha{constructor(e,t,s,i,r,o){this.logItem=e,this.membersLogItem=t,this.localMedia=s,this.localPreviewMedia=i,this.localMuteSettings=r,this.turnServer=o}dispose(){this.localMedia.dispose(),this.localPreviewMedia.dispose(),this.logItem.finish(),this.renewMembershipTimeout?.dispose()}}class rs extends ye{constructor(e,t,s,i,r,o,a){super(),this.id=e,this.isLoadedFromStorage=t,this.startTime=i,this.callContent=r,this.roomId=o,this.options=a,this._members=new oe,this.bufferedDeviceMessages=new Map,this.errorBoundary=new Ri(c=>{this.emitChange(),this.joinedData&&(this.joinedData.logItem.log("error at boundary").catch(c),console.error(c))}),this._state=s?"fledgling":"created",this._memberOptions=Object.assign({},a,{confId:this.id,emitUpdate:c=>{const d=Ee(c.userId,c.deviceId);if(c.isExpired&&!c.isConnected){const h=this.options.logger.log({l:"removing expired member from call",memberKey:d,callId:this.id});c.logItem?.refDetached(h),c.dispose(),this._members.remove(d)}else this._members.update(d)},encryptDeviceMessage:(c,d,h,l)=>this.options.encryptDeviceMessage(this.roomId,c,d,h,l)})}get localMedia(){return this.joinedData?.localMedia}get localPreviewMedia(){return this.joinedData?.localPreviewMedia}get members(){return this._members}get isTerminated(){return!!this.callContent?.["m.terminated"]}get usesFoci(){for(const e of this._members.values())if(e.usesFoci)return!0;return!1}get duration(){if(typeof this.startTime=="number")return this.options.clock.now()-this.startTime}get isRinging(){return this._state==="created"&&this.intent==="m.ring"&&!this.isMember(this.options.ownUserId)}get name(){return this.callContent?.["m.name"]}get intent(){return this.callContent?.["m.intent"]}get type(){return this.callContent?.["m.type"]}get logItem(){return this.joinedData?.logItem}get error(){return this.errorBoundary.error}join(e,t){return this.options.logger.wrapOrRun(t,"Call.join",async s=>{if(this._state!=="created"||this.joinedData||this.usesFoci){e.dispose();return}const i=this.options.logger.child({l:"Call.connection",t:ue,id:this.id,ownSessionId:this.options.sessionId}),r=await this.options.turnServerSource.getSettings(i),o=i.child("member connections"),a=new Se;a.updateTrackInfo(e.userMedia);const c=e.asPreview(),d=new Ha(i,o,e,c,a,r);this.joinedData=d,await d.logItem.wrap("join",async h=>{s.refDetached(h),this._state="joining",this.emitChange(),await h.wrap("update member state",async l=>{const u=await this._createMemberPayload(!0);l.set("payload",u),await this.options.hsApi.sendState(this.roomId,y.GroupCallMember,this.options.ownUserId,u,{log:l}).response(),this.emitChange()});for(const l of this._members.values())this.connectToMember(l,d,h)})})}async setMedia(e){if((this._state==="joining"||this._state==="joined")&&this.joinedData){const t=this.joinedData.localMedia;this.joinedData.localMedia=e,this.joinedData.localPreviewMedia?.dispose(),this.joinedData.localPreviewMedia=e.asPreview(),this.joinedData.localMuteSettings.updateTrackInfo(e.userMedia),this.emitChange(),await Promise.all(Array.from(this._members.values()).map(s=>s.setMedia(e,t))),t?.dispose()}}async setMuted(e){const{joinedData:t}=this;if(!t)return;const s=t.localMuteSettings;e.updateTrackInfo(t.localMedia.userMedia),t.localMuteSettings=e,s.equals(e)||(this.localPreviewMedia&&es(this.localPreviewMedia,e,this.joinedData.logItem),this.localMedia&&es(this.localMedia,e,this.joinedData.logItem),await Promise.all(Array.from(this._members.values()).map(i=>i.setMuted(t.localMuteSettings))),this.emitChange())}get muteSettings(){return this.joinedData?.localMuteSettings}get hasJoined(){return this._state==="joining"||this._state==="joined"}async leave(e){await this.options.logger.wrapOrRun(e,"Call.leave",async t=>{const{joinedData:s}=this;if(!!s)try{s.renewMembershipTimeout?.dispose(),s.renewMembershipTimeout=void 0;const i=await this._createMemberPayload(!1);i?(await this.options.hsApi.sendState(this.roomId,y.GroupCallMember,this.options.ownUserId,i,{log:t}).response(),(this.intent===Ne.Ring||this.intent===Ne.Prompt)&&this._members.size===0&&await this.terminate(t)):t.set("already_left",!0)}finally{if(!this.disconnect(t))throw this.errorBoundary.error}})}terminate(e){return this.options.logger.wrapOrRun(e,{l:"terminate call",t:ue},async t=>{if(this._state==="fledgling")return;await this.options.hsApi.sendState(this.roomId,y.GroupCall,this.id,Object.assign({},this.callContent,{"m.terminated":!0}),{log:t}).response()})}create(e,t){return t.wrap({l:"create call",t:ue},async s=>{if(this._state!=="fledgling")return;this._state="creating",this.emitChange(),this.callContent=Object.assign({"m.type":e},this.callContent),await this.options.hsApi.sendState(this.roomId,y.GroupCall,this.id,this.callContent,{log:s}).response(),this._state="created",this.emitChange()})}updateCallEvent(e,t){this.errorBoundary.try(()=>{t.wrap({l:"update call",t:ue,id:this.id},s=>{typeof this.startTime!="number"&&(this.startTime=e.origin_server_ts),this.callContent=e.content,this._state==="creating"&&(this._state="created"),s.set("status",this._state),this.emitChange()})})}updateRoomMembers(e){this.errorBoundary.try(()=>{for(const t of e.values()){const{member:s}=t;for(const i of this._members.values())i.userId===s.userId&&i.updateRoomMember(s)}})}updateMembership(e,t,s,i){this.errorBoundary.try(async()=>{await i.wrap({l:"update call membership",t:ue,id:this.id,userId:e},async r=>{const o=this.options.clock.now(),a=s["m.devices"],c=this.getDeviceIdsForUserId(e);for(const h of a){const l=h.device_id,u=Ee(e,l);e===this.options.ownUserId&&l===this.options.ownDeviceId?r.wrap("update own membership",p=>{this.hasJoined&&(this.joinedData&&this.joinedData.logItem.refDetached(p),this._setupRenewMembershipTimeout(h,p)),this._state==="joining"&&(p.set("joined",!0),this._state="joined",this.emitChange())}):await r.wrap({l:"update device membership",id:u,sessionId:h.session_id},async p=>{if(is(h,o)){p.set("expired",!0);const g=this._members.get(u);g&&(g.dispose(),this._members.remove(u),p.set("removed",!0));return}let m=this._members.get(u);const _=m&&m.sessionId!==h.session_id;if(m&&!_)p.set("update",!0),m.updateCallInfo(h,p);else{if(m&&_){p.set("removedSessionId",m.sessionId);const g=await m.disconnect(!1);g&&p.refDetached(g),m.dispose(),this._members.remove(u),m=void 0}p.set("add",!0),m=new Ga(t,h,this._memberOptions,p),this._members.add(u,m),this.joinedData&&this.connectToMember(m,this.joinedData,p)}this.flushPendingIncomingDeviceMessages(m,p)})}const d=new Set(a.map(h=>h.device_id));for(const h of c)d.has(h)||this.removeMemberDevice(e,h,r);e===this.options.ownUserId&&!d.has(this.options.ownDeviceId)&&this.removeOwnDevice(r)})})}removeMembership(e,t){this.errorBoundary.try(()=>{const s=this.getDeviceIdsForUserId(e);t.wrap({l:"remove call member",t:ue,id:this.id,userId:e},i=>{for(const r of s)this.removeMemberDevice(e,r,i);e===this.options.ownUserId&&this.removeOwnDevice(i)})})}flushPendingIncomingDeviceMessages(e,t){const s=Ee(e.userId,e.deviceId),i=this.bufferedDeviceMessages.get(s);if(i){for(const r of i)r.content.sender_session_id===e.sessionId&&(e.handleDeviceMessage(r,t),i.delete(r));i.size===0&&this.bufferedDeviceMessages.delete(s)}}getDeviceIdsForUserId(e){return Array.from(this._members.keys()).filter(t=>ki(t,e)).map(t=>Va(t))}isMember(e){return Array.from(this._members.keys()).some(t=>ki(t,e))}removeOwnDevice(e){e.wrap("remove own membership",t=>{this.disconnect(t)})}disconnect(e){return this.errorBoundary.try(async()=>{if(this.hasJoined){for(const t of this._members.values()){const s=await t.disconnect(!0);s&&e.refDetached(s)}this._state="created"}this.joinedData?.dispose(),this.joinedData=void 0,this.emitChange()},!1)||!0}async removeMemberDevice(e,t,s){const i=Ee(e,t);await s.wrap({l:"remove device member",id:i},async r=>{const o=this._members.get(i);if(o){r.set("leave",!0);const a=await o.disconnect(!1);a&&r.refDetached(a),o.dispose(),this._members.remove(i)}})}handleDeviceMessage(e,t,s,i){this.errorBoundary.try(()=>{const r=Ee(t,s);let o=this._members.get(r);if(o&&e.content.sender_session_id===o.sessionId)o.handleDeviceMessage(e,i);else{i.log({l:"call: buffering to_device message, member not found",t:ue,id:this.id,userId:t,deviceId:s,sessionId:e.content.sender_session_id,type:e.type});let a=this.bufferedDeviceMessages.get(r);a||(a=new Set,this.bufferedDeviceMessages.set(r,a)),a.add(e)}})}async _createMemberPayload(e){const{storage:t}=this.options,r=(await(await t.readTxn([t.storeNames.roomState])).roomState.get(this.roomId,y.GroupCallMember,this.options.ownUserId))?.event?.content??{["m.calls"]:[]};let o=r["m.calls"],a=o.find(d=>d["m.call_id"]===this.id);a||(a={["m.call_id"]:this.id,["m.devices"]:[]},o.push(a));const c=this.options.clock.now();return a["m.devices"]=a["m.devices"].filter(d=>!(d.device_id===this.options.ownDeviceId||mt(d)===void 0||is(d,c,ts))),e&&a["m.devices"].push({device_id:this.options.ownDeviceId,session_id:this.options.sessionId,expires_ts:c+ts,feeds:[{purpose:"m.usermedia"}]}),r["m.calls"]=o.filter(d=>d["m.devices"].length!==0),r}async connectToMember(e,t,s){const i=Ee(e.userId,e.deviceId),r=t.membersLogItem.child({l:"member",id:i,sessionId:e.sessionId});await s.wrap({l:"connect",id:i},async o=>{const a=await e.connect(t.localMedia,t.localMuteSettings,t.turnServer,r);a&&o.refDetached(a)})}emitChange(){this.emit("change"),this.options.emitUpdate(this)}_setupRenewMembershipTimeout(e,t){const{joinedData:s}=this;if(!s)return;s.renewMembershipTimeout?.dispose(),s.renewMembershipTimeout=void 0;const i=mt(e);if(typeof i!="number")return;const r=i-this.options.clock.now(),o=Math.max(1e4,Math.ceil((.2+this.options.random()*.8)*(.08333*ts))),a=Math.max(0,r-o);t.set("expiresIn",r),t.set("renewIn",a),s.renewMembershipTimeout=this.options.clock.createTimeout(a),s.renewMembershipTimeout.elapsed().then(()=>{s.logItem.wrap("renew membership",async c=>{const d=await this._createMemberPayload(!0);c.set("payload",d),await this.options.hsApi.sendState(this.roomId,y.GroupCallMember,this.options.ownUserId,d,{log:c}).response()})},()=>{})}dispose(){this.joinedData?.dispose();for(const e of this._members.values())e.dispose()}}const Mi=5*60,za={urls:["stun:turn.matrix.org"],username:"",credential:""};class Qa{constructor(e,t,s=za){this.hsApi=e,this.clock=t,this.defaultSettings=s,this.isPolling=!1}getSettings(e){return e.wrap("get turn server",async t=>{if(!this.isPolling){const s=await this.doRequest(t),i=s?Ci(s):this.defaultSettings;t.set("iceServer",i),this.currentObservable?this.currentObservable.set(i):this.currentObservable=new We(i,()=>{this.stopPollLoop()},()=>{this.runLoop(s?.ttl??Mi)})}return this.currentObservable})}async runLoop(e){let t=e;for(this.isPolling=!0;this.isPolling;)try{this.pollTimeout=this.clock.createTimeout(t*1e3),await this.pollTimeout.elapsed(),this.pollTimeout=void 0;const s=await this.doRequest(void 0);if(s){const i=Ci(s);Ja(this.currentObservable,i)&&this.currentObservable.set(i),s.ttl>0?t=s.ttl:this.stopPollLoop()}else t=Mi}catch(s){s.name}}async doRequest(e){try{return this.pollRequest=this.hsApi.getTurnServer({log:e}),await this.pollRequest.response()}catch(t){if(t.name==="HomeServerError")return;throw t}finally{this.pollRequest=void 0}}stopPollLoop(){this.isPolling=!1,this.currentObservable=void 0,this.pollTimeout?.dispose(),this.pollTimeout=void 0,this.pollRequest?.abort(),this.pollRequest=void 0}dispose(){this.stopPollLoop()}}function Ja(n,e){const t=n.get();if(!t)return!0;const s=Array.isArray(t.urls)?t.urls:[t.urls],i=Array.isArray(e.urls)?e.urls:[e.urls];return!(s.length===i.length&&!i.some(o=>!s.includes(o)))||e.username!==t.username||e.credential!==t.credential}function Ci(n){return{urls:n.uris,username:n.username,credential:n.password,credentialType:"password"}}function Ya(n,e){return JSON.stringify(n)+","+JSON.stringify(e)}class Xa{constructor(e){this.options=e,this._calls=new oe,this.roomMemberToCallIds=new Map,this.sessionId=at("s"),this.groupCallOptions=Object.assign({},this.options,{turnServerSource:new Qa(this.options.hsApi,this.options.clock),emitUpdate:(t,s)=>this._calls.update(t.id,s),createTimeout:this.options.clock.createTimeout,sessionId:this.sessionId})}loadCalls(e,t){return this.options.logger.wrapOrRun(t,"CallHandler.loadCalls",async s=>{e||(e=Ne.Ring),s.set("intent",e);const i=await this._getLoadTxn(),r=await i.calls.getByIntent(e);await this._loadCallEntries(r,i,s)})}loadCallsForRoom(e,t,s){return this.options.logger.wrapOrRun(s,"CallHandler.loadCallsForRoom",async i=>{i.set("intent",e),i.set("roomId",t);const r=await this._getLoadTxn(),o=await r.calls.getByIntentAndRoom(e,t);await this._loadCallEntries(o,r,i)})}async _getLoadTxn(){const e=this.options.storage.storeNames;return await this.options.storage.readTxn([e.calls,e.roomState])}async _loadCallEntries(e,t,s){s.set("entries",e.length),await Promise.all(e.map(async r=>{if(this._calls.get(r.callId))return;const o=await t.roomState.get(r.roomId,y.GroupCall,r.callId);if(o){const a=new rs(o.event.state_key,!0,!1,r.timestamp,o.event.content,o.roomId,this.groupCallOptions);this._calls.set(a.id,a)}}));const i=Array.from(new Set(e.map(r=>r.roomId)));await Promise.all(i.map(async r=>{const o=await t.roomState.getAllForType(r,y.GroupCallMember);await Promise.all(o.map(async a=>{const c=a.event.sender,d=await t.roomState.get(r,D,c);let h;d&&(h=v.fromMemberEvent(d.event)),h||(h=v.fromUserId(r,c,"join")),this.handleCallMemberEvent(a.event,h,r,s)}))})),s.set("newSize",this._calls.size)}createCall(e,t,s,i,r){return this.options.logger.wrapOrRun(r,"CallHandler.createCall",async o=>{i||(i=Ne.Ring);const a=new rs(at("conf-"),!1,!0,void 0,{"m.name":s,"m.intent":i},e,this.groupCallOptions);this._calls.set(a.id,a);try{await a.create(t,o);const c=await this.options.storage.readWriteTxn([this.options.storage.storeNames.calls]);c.calls.add({intent:a.intent,callId:a.id,timestamp:this.options.clock.now(),roomId:e}),await c.complete()}catch(c){throw this._calls.remove(a.id),c}return a})}get calls(){return this._calls}async handleRoomState(e,t,s,i,r){if(t.type===y.GroupCall&&this.handleCallEvent(t,e.id,i,r),t.type===y.GroupCallMember){let o=await s.lookupMemberAtEvent(t.sender,t,i);o||(o=v.fromUserId(e.id,t.sender,"join")),this.handleCallMemberEvent(t,o,e.id,r)}}updateRoomMembers(e,t){for(const s of this._calls.values())s.roomId===e.id&&s.updateRoomMembers(t)}handlesDeviceMessageEventType(e){return ja(e)}handleDeviceMessage(e,t,s,i){this._calls.get(e.content.conf_id)?.handleDeviceMessage(e,t,s,i)}handleCallEvent(e,t,s,i){const r=e.state_key;let o=this._calls.get(r);o?(o.updateCallEvent(e,i),o.isTerminated&&(o.disconnect(i),this._calls.remove(o.id),s.calls.remove(o.intent,t,o.id))):e.content["m.terminated"]||(o=new rs(e.state_key,!1,!1,e.origin_server_ts,e.content,t,this.groupCallOptions),this._calls.set(o.id,o),s.calls.add({intent:o.intent,callId:o.id,timestamp:e.origin_server_ts,roomId:t}))}handleCallMemberEvent(e,t,s,i){const r=e.state_key,o=Ya(s,r),a=e.content["m.calls"]??[];for(const h of a){const l=h["m.call_id"];this._calls.get(l)?.updateMembership(r,t,h,i)}const c=new Set(a.map(h=>h["m.call_id"]));let d=this.roomMemberToCallIds.get(o);if(d)for(const h of d)c.has(h)||this._calls.get(h)?.removeMembership(r,i);c.size===0?this.roomMemberToCallIds.delete(o):this.roomMemberToCallIds.set(o,c)}dispose(){this.groupCallOptions.turnServerSource.dispose();for(const e of this._calls.values())e.dispose()}}class Za extends $e{async handleRoomState(e,t,s,i,r){const o=[];for(let a of this._handlers)o.push(a.handleRoomState(e,t,s,i,r));await Promise.all(o)}updateRoomMembers(e,t){for(let s of this._handlers)s.updateRoomMembers(e,t)}}class qe{constructor(e=0){this.flags=e}withFeature(e){return new qe(this.flags|e)}withoutFeature(e){return new qe(this.flags^e)}isFeatureEnabled(e){return(this.flags&e)!==0}get calls(){return this.isFeatureEnabled(1)}get crossSigning(){return this.isFeatureEnabled(2)}get sameSessionInMultipleTabs(){return this.isFeatureEnabled(4)}static async load(e){const t=await e.getInt("enabled_features")||0;return new qe(t)}async store(e){await e.setInt("enabled_features",this.flags)}}const pe="DEFAULT_KEY",je="pusher";class ec{constructor({storage:e,hsApi:t,sessionInfo:s,olm:i,olmWorker:r,platform:o,mediaRepository:a,features:c,sendQueuePool:d}){this._platform=o,this._storage=e,this._hsApi=t,this._mediaRepository=a,this._features=c,this._syncInfo=null,this._sessionInfo=s,this._rooms=new oe,this._roomUpdateCallback=(h,l)=>this._rooms.update(h.id,l),this._activeArchivedRooms=new Map,this._invites=new oe,this._inviteUpdateCallback=(h,l)=>this._invites.update(h.id,l),this._roomsBeingCreatedUpdateCallback=(h,l)=>{h.isCancelled?this._roomsBeingCreated.remove(h.id):this._roomsBeingCreated.update(h.id,l)},this._roomsBeingCreated=new oe,this._user=new po(s.userId),this._roomStateHandler=new Za,this._deviceMessageHandler=new Wo({storage:e,callHandler:this._callHandler}),this._olm=i,this._olmUtil=null,this._e2eeAccount=null,this._deviceTracker=null,this._olmEncryption=null,this._keyLoader=null,this._megolmEncryption=null,this._megolmDecryption=null,this._getSyncToken=()=>this.syncToken,this._olmWorker=r,this._keyBackup=new re(void 0),this._crossSigning=void 0,this._observedRoomStatus=new Map,this.sendQueuePool=d,i&&(this._olmUtil=new i.Utility,this._deviceTracker=new Oa({storage:e,getSyncToken:this._getSyncToken,olmUtil:this._olmUtil,ownUserId:s.userId,ownDeviceId:s.deviceId})),this._createRoomEncryption=this._createRoomEncryption.bind(this),this._forgetArchivedRoom=this._forgetArchivedRoom.bind(this),this.needsKeyBackup=new re(!1),c.calls&&this._setupCallHandler()}get fingerprintKey(){return this._e2eeAccount?.identityKeys.ed25519}get hasSecretStorageKey(){return this._hasSecretStorageKey}get sessionId(){return this._sessionInfo.id}get deviceId(){return this._sessionInfo.deviceId}get userId(){return this._sessionInfo.userId}get homeserver(){return this._sessionInfo.homeServer}get accessToken(){return this._sessionInfo.accessToken}get callHandler(){return this._callHandler}async isGuest(){if(typeof this._guestUser<"u")return this._guestUser;const e=await this._hsApi.whoami().response();return this._guestUser=e.is_guest,Boolean(e.is_guest)}_setupCallHandler(){this._callHandler=new Xa({clock:this._platform.clock,random:this._platform.random,hsApi:this._hsApi,encryptDeviceMessage:async(e,t,s,i,r)=>{if(!this._deviceTracker||!this._olmEncryption){r.set("encryption_disabled",!0);return}const o=await r.wrap("get device key",async a=>{const c=this._deviceTracker.deviceForId(t,s,this._hsApi,a);return c||a.set("not_found",!0),c});if(o)return await this._olmEncryption.encrypt(i.type,i.content,[o],this._hsApi,r)},storage:this._storage,webRTC:this._platform.webRTC,ownDeviceId:this._sessionInfo.deviceId,ownUserId:this._sessionInfo.userId,logger:this._platform.logger,forceTURN:!1}),this.observeRoomState(this._callHandler)}_setupEncryption(){const e=new Na,t=new na(this._e2eeAccount,pe,this._platform.clock.now,this._user.id,this._olm,e);this._olmEncryption=new da(this._e2eeAccount,pe,this._olm,this._storage,this._platform.clock.now,this._user.id,this._olmUtil,e),this._keyLoader=new Sa(this._olm,pe,20),this._megolmEncryption=new Aa({account:this._e2eeAccount,pickleKey:pe,olm:this._olm,storage:this._storage,keyLoader:this._keyLoader,now:this._platform.clock.now,ownDeviceId:this._sessionInfo.deviceId}),this._megolmDecryption=new Ia(this._keyLoader,this._olmWorker),this._deviceMessageHandler.enableEncryption({olmDecryption:t,megolmDecryption:this._megolmDecryption})}_createRoomEncryption(e,t){if(!this._olmEncryption)throw new Error("creating room encryption before encryption got globally enabled");return t.algorithm!==q?null:new Da({room:e,deviceTracker:this._deviceTracker,olmEncryption:this._olmEncryption,megolmEncryption:this._megolmEncryption,megolmDecryption:this._megolmDecryption,storage:this._storage,keyBackup:this._keyBackup?.get(),encryptionParams:t,notifyMissingMegolmSession:()=>{this._keyBackup.get()||this.needsKeyBackup.set(!0)},clock:this._platform.clock})}enableSecretStorage(e,t,s=void 0){return this._platform.logger.wrapOrRun(s,"enable secret storage",async i=>{if(!this._olm)throw new Error("olm required");this._keyBackup.get()&&(this._keyBackup.get().dispose(),this._keyBackup.set(null));const r=await ea(e,t,this._storage,this._platform,this._olm),o=await this._storage.readTxn([this._storage.storeNames.accountData]);if(await this._createKeyBackup(r,o,i))return await this._writeSSSSKey(r,i),this._keyBackup.get().flush(i),r;throw new Error("Could not read key backup with the given key")})}async _writeSSSSKey(e,t){const s=this._keyBackup.get();if(!s)return;const i=s.version,r=await this._storage.readWriteTxn([this._storage.storeNames.session,this._storage.storeNames.inboundGroupSessions]);try{const o=await Yo(e,i,r);if(t.set("previousBackupVersion",o),t.set("backupVersion",i),!!o&&o!==i){const a=await s.markAllForBackup(r);t.set("amountMarkedForBackup",a)}}catch(o){throw r.abort(),o}await r.complete()}async disableSecretStorage(){const e=await this._storage.readWriteTxn([this._storage.storeNames.session]);try{Zo(e)}catch(t){throw e.abort(),t}if(await e.complete(),this._keyBackup.get()){for(const t of this._rooms.values())t.isEncrypted&&t.enableKeyBackup(void 0);this._keyBackup.get().dispose(),this._keyBackup.set(null)}}_createKeyBackup(e,t,s){return s.wrap("enable key backup",async i=>{try{const r=new Ba({key:e,platform:this._platform}),o=await Jt.fromSecretStorage(this._platform,this._olm,r,this._hsApi,this._keyLoader,this._storage,t);if(o){this._features.crossSigning&&(this._crossSigning=new Ta({storage:this._storage,secretStorage:r,platform:this._platform,olm:this._olm,deviceTracker:this._deviceTracker,hsApi:this._hsApi,ownUserId:this.userId,e2eeAccount:this._e2eeAccount}),await i.wrap("enable cross-signing",a=>this._crossSigning.init(a)));for(const a of this._rooms.values())a.isEncrypted&&a.enableKeyBackup(o);return this._keyBackup.set(o),!0}else i.set("no_backup",!0)}catch(r){i.catch(r)}return!1})}get keyBackup(){return this._keyBackup}get crossSigning(){return this._crossSigning}get hasIdentity(){return!!this._e2eeAccount}async createIdentity(e){this._olm&&(this._e2eeAccount||(this._e2eeAccount=await this._createNewAccount(this._sessionInfo.deviceId,this._storage),e.set("keys",this._e2eeAccount.identityKeys),this._setupEncryption()),await this._e2eeAccount.generateOTKsIfNeeded(this._storage,e),await e.wrap("uploadKeys",t=>this._e2eeAccount.uploadKeys(this._storage,!1,t)))}async dehydrateIdentity(e,t){return t.set("deviceId",e.deviceId),this._olm?e.deviceId!==this.deviceId?(t.set("wrong_device",!0),!1):this._e2eeAccount?(t.set("account_already_setup",!0),!1):await e.claim(this._hsApi,t)?(this._e2eeAccount=await le.adoptDehydratedDevice({dehydratedDevice:e,hsApi:this._hsApi,olm:this._olm,pickleKey:pe,userId:this._sessionInfo.userId,olmWorker:this._olmWorker,deviceId:this.deviceId,storage:this._storage}),t.set("keys",this._e2eeAccount.identityKeys),this._setupEncryption(),!0):(t.set("already_claimed",!0),!1):(t.set("no_olm",!0),!1)}_createNewAccount(e,t=void 0){return le.create({hsApi:this._hsApi,olm:this._olm,pickleKey:pe,userId:this._sessionInfo.userId,olmWorker:this._olmWorker,deviceId:e,storage:t})}setupDehydratedDevice(e,t=null){return this._platform.logger.wrapOrRun(t,"setupDehydratedDevice",async s=>{const i=await this._createNewAccount("temp-device-id");try{const r=await ra(i,this._hsApi,e,"Dehydrated device",s);return s.set("deviceId",r),r}finally{i.dispose()}})}async load(e){const t=await this._storage.readTxn([this._storage.storeNames.session,this._storage.storeNames.roomSummary,this._storage.storeNames.invites,this._storage.storeNames.roomMembers,this._storage.storeNames.timelineEvents,this._storage.storeNames.timelineFragments,this._storage.storeNames.pendingEvents]);this._syncInfo=await t.session.get("sync"),this._olm&&(this._e2eeAccount=await le.load({hsApi:this._hsApi,olm:this._olm,pickleKey:pe,userId:this._sessionInfo.userId,deviceId:this._sessionInfo.deviceId,olmWorker:this._olmWorker,txn:t}),this._e2eeAccount&&(e.set("keys",this._e2eeAccount.identityKeys),this._setupEncryption()));const s=await this._getPendingEventsByRoom(t),i=await t.invites.getAll(),r=Promise.all(i.map(async c=>{const d=this.createInvite(c.roomId);e.wrap("invite",h=>d.load(c,h)),this._invites.add(d.id,d)})),o=await t.roomSummary.getAll(),a=Promise.all(o.map(async c=>{const d=this.createJoinedRoom(c.roomId,s.get(c.roomId));await e.wrap("room",h=>d.load(c,t,h)),this._rooms.add(d.id,d)}));await Promise.all([r,a]);for(const[c,d]of this.invites){const h=this.rooms.get(c);h&&h.setInvite(d)}}dispose(){this._olmWorker?.dispose(),this._olmWorker=void 0,this._keyBackup.get()?.dispose(),this._keyBackup.set(void 0),this._megolmDecryption?.dispose(),this._megolmDecryption=void 0,this._e2eeAccount?.dispose(),this._e2eeAccount=void 0,this._callHandler?.dispose(),this._callHandler=void 0;for(const e of this._rooms.values())e.dispose();this._rooms=void 0}async start(e,t,s){if(e){const a=await this._storage.readWriteTxn([this._storage.storeNames.session]);a.session.set("serverVersions",e),await a.complete()}if(!this._keyBackup.get()){t&&await s.wrap("SSSSKeyFromDehydratedDeviceKey",async d=>{const h=await sa(t.key,this._storage,this._platform);h&&(d.set("success",!0),await this._writeSSSSKey(h))});const a=await this._storage.readTxn([this._storage.storeNames.session,this._storage.storeNames.accountData]),c=await Xo(a);c&&await this._createKeyBackup(c,a,s)&&this._keyBackup.get()?.flush(s),this._keyBackup.get()||this._keyBackup.set(null)}const r=await(await this._storage.readWriteTxn([this._storage.storeNames.operations])).operations.getAll(),o=be(r,a=>a.scope);for(const a of this._rooms.values()){let c;const d=o.get(a.id);d&&(c=be(d,h=>h.type)),a.start(c,s)}}async _getPendingEventsByRoom(e){return(await e.pendingEvents.getAll()).reduce((s,i)=>{const r=s.get(i.roomId);return r?r.push(i):s.set(i.roomId,[i]),s},new Map)}get rooms(){return this._rooms}findDirectMessageForUserId(e){for(const[,t]of this._rooms)if(t.isDirectMessageForUserId(e))return t;for(const[,t]of this._invites)if(t.isDirectMessageForUserId(e))return t}createJoinedRoom(e,t){const s=this.sendQueuePool.createQueue(e,t);return new si({roomId:e,getSyncToken:this._getSyncToken,storage:this._storage,emitCollectionChange:this._roomUpdateCallback,hsApi:this._hsApi,mediaRepository:this._mediaRepository,pendingEvents:t,user:this._user,createRoomEncryption:this._createRoomEncryption,platform:this._platform,roomStateHandler:this._roomStateHandler,sendQueue:s})}_createArchivedRoom(e){const t=new Fo({roomId:e,getSyncToken:this._getSyncToken,storage:this._storage,emitCollectionChange:()=>{},releaseCallback:()=>this._activeArchivedRooms.delete(e),forgetCallback:this._forgetArchivedRoom,hsApi:this._hsApi,mediaRepository:this._mediaRepository,user:this._user,createRoomEncryption:this._createRoomEncryption,platform:this._platform});return this._activeArchivedRooms.set(e,t),t}_createWorldReadableRoom(e){return new si({roomId:e,getSyncToken:this._getSyncToken,storage:this._storage,emitCollectionChange:this._roomUpdateCallback,hsApi:this._hsApi,mediaRepository:this._mediaRepository,pendingEvents:[],user:this._user,platform:this._platform,roomStateHandler:this._roomStateHandler})}get invites(){return this._invites}createInvite(e){return new $o({roomId:e,hsApi:this._hsApi,emitCollectionUpdate:this._inviteUpdateCallback,mediaRepository:this._mediaRepository,user:this._user,platform:this._platform})}get roomsBeingCreated(){return this._roomsBeingCreated}createRoom(e){let t;return this._platform.logger.runDetached("create room",async s=>{const i=`local-${Math.floor(this._platform.random()*Number.MAX_SAFE_INTEGER)}`;t=new jo(i,e,this._roomsBeingCreatedUpdateCallback,this._mediaRepository,this._platform,s),this._roomsBeingCreated.set(i,t);const r=[t.create(this._hsApi,s)];e.loadProfiles!==!1&&r.push(t.loadProfiles(this._hsApi,s)),await Promise.all(r),t.roomId&&(this.rooms.get(t.roomId)&&this._tryReplaceRoomBeingCreated(t.roomId,s),await t.adjustDirectMessageMapIfNeeded(this._user,this._storage,this._hsApi,s))}),t}async obtainSyncLock(e){const t=e.to_device?.events;if(Array.isArray(t)&&t.length)return await this._deviceMessageHandler.obtainSyncLock(t)}async prepareSync(e,t,s,i){const r=e.to_device?.events;if(Array.isArray(r)&&r.length)return await i.wrap("deviceMsgs",o=>this._deviceMessageHandler.prepareSync(r,t,s,o))}async writeSync(e,t,s,i,r){const o={syncInfo:null,e2eeAccountChanges:null,hasNewRoomKeys:!1,deviceMessageDecryptionResults:null},a=e.next_batch;if(a!==this.syncToken){const l={token:a,filterId:t};i.session.set("sync",l),o.syncInfo=l}const c=e.device_one_time_keys_count;this._e2eeAccount&&c&&(o.e2eeAccountChanges=this._e2eeAccount.writeSync(c,i,r));const d=e.device_lists;if(this._deviceTracker&&Array.isArray(d?.changed)&&d.changed.length&&await r.wrap("deviceLists",l=>this._deviceTracker.writeDeviceChanges(d.changed,i,l)),s){const{hasNewRoomKeys:l,decryptionResults:u}=await r.wrap("deviceMsgs",p=>this._deviceMessageHandler.writeSync(s,i,p));o.hasNewRoomKeys=l,o.deviceMessageDecryptionResults=u}const h=e.account_data;if(Array.isArray(h?.events))for(const l of h.events)typeof l.type=="string"&&i.accountData.set(l);return o}afterSync({syncInfo:e,e2eeAccountChanges:t}){e&&(this._syncInfo=e),this._e2eeAccount&&this._e2eeAccount.afterSync(t)}async afterSyncCompleted(e,t,s){t||await this._e2eeAccount.generateOTKsIfNeeded(this._storage,s)&&await s.wrap("uploadKeys",r=>this._e2eeAccount.uploadKeys(this._storage,!1,r)),e.hasNewRoomKeys&&this._keyBackup.get()?.flush(s),e.deviceMessageDecryptionResults&&await this._deviceMessageHandler.afterSyncCompleted(e.deviceMessageDecryptionResults,this._deviceTracker,this._hsApi,s)}_tryReplaceRoomBeingCreated(e,t){for(const[,s]of this._roomsBeingCreated)if(s.roomId===e){const i=this._observedRoomStatus.get(s.id);i&&(t.log("replacing room being created").set("localId",s.id).set("roomId",s.roomId),i.set(i.get()|A.Replaced)),s.dispose(),this._roomsBeingCreated.remove(s.id);return}}async applyRoomCollectionChangesAfterSync(e,t,s,i){for(const r of t)r.shouldAdd?(this._rooms.add(r.id,r.room),this._tryReplaceRoomBeingCreated(r.id,i)):r.shouldRemove&&this._rooms.remove(r.id);for(const r of e)r.shouldAdd?this._invites.add(r.id,r.invite):r.shouldRemove&&this._invites.remove(r.id);if(this._observedRoomStatus.size!==0){for(const r of s)r.shouldAdd&&this._observedRoomStatus.get(r.id)?.set(A.Archived);for(const r of t)r.shouldAdd&&this._observedRoomStatus.get(r.id)?.set(A.Joined);for(const r of e){const o=this._observedRoomStatus.get(r.id);if(o){const a=o.get()|A.Invited;if(r.shouldAdd)o.set(a);else if(r.shouldRemove){const c=a^A.Invited;o.set(c)}}}}}_forgetArchivedRoom(e){const t=this._observedRoomStatus.get(e);t&&t.set((t.get()|A.Archived)^A.Archived)}get syncToken(){return this._syncInfo?.token}get syncFilterId(){return this._syncInfo?.filterId}get user(){return this._user}get mediaRepository(){return this._mediaRepository}enablePushNotifications(e){return e?this._enablePush():this._disablePush()}async _enablePush(){return this._platform.logger.run("enablePush",async e=>{const t=he.createDefaultPayload(this._sessionInfo.id),s=await this._platform.notificationService.enablePush(he,t);if(!s)return e.set("no_pusher",!0),!1;await s.enable(this._hsApi,e);const i=await this._storage.readWriteTxn([this._storage.storeNames.session]);return i.session.set(je,s.serialize()),await i.complete(),!0})}async _disablePush(){return this._platform.logger.run("disablePush",async e=>{await this._platform.notificationService.disablePush();const s=await(await this._storage.readTxn([this._storage.storeNames.session])).session.get(je);if(!s)return!0;await new he(s).disable(this._hsApi,e);const r=await this._storage.readWriteTxn([this._storage.storeNames.session]);return r.session.remove(je),await r.complete(),!0})}async arePushNotificationsEnabled(){return await this._platform.notificationService.isPushEnabled()?!!await(await this._storage.readTxn([this._storage.storeNames.session])).session.get(je):!1}async checkPusherEnabledOnHomeserver(){const t=await(await this._storage.readTxn([this._storage.storeNames.session])).session.get(je);if(!t)return!1;const s=new he(t);return((await this._hsApi.getPushers().response())?.pushers||[]).map(o=>new he(o)).some(o=>o.equals(s))}async getRoomStatus(e){if(!!this._roomsBeingCreated.get(e))return A.BeingCreated;if(!!this._rooms.get(e))return A.Joined;{const i=!!this._invites.get(e),o=await(await this._storage.readTxn([this._storage.storeNames.archivedRoomSummary])).archivedRoomSummary.has(e);return i&&o?A.Invited|A.Archived:i?A.Invited:o?A.Archived:A.None}}async observeRoomStatus(e){let t=this._observedRoomStatus.get(e);if(!t){let s;t=new We(s,()=>{this._observedRoomStatus.delete(e)}),this._observedRoomStatus.set(e,t),s=await this.getRoomStatus(e),t.get()===void 0&&t.set(s)}return t}observeRoomState(e){return this._roomStateHandler.subscribe(e)}createOrGetArchivedRoomForSync(e){let t=this._activeArchivedRooms.get(e);return t?t.retain():t=this._createArchivedRoom(e),t}loadArchivedRoom(e,t=null){return this._platform.logger.wrapOrRun(t,"loadArchivedRoom",async s=>{s.set("id",e);const i=this._activeArchivedRooms.get(e);if(i)return i.retain(),i;const r=await this._storage.readTxn([this._storage.storeNames.archivedRoomSummary,this._storage.storeNames.roomMembers]),o=await r.archivedRoomSummary.get(e);if(o){const a=this._createArchivedRoom(e);return await a.load(o,r,s),a}})}loadWorldReadableRoom(e,t=null){return this._platform.logger.wrapOrRun(t,"loadWorldReadableRoom",async s=>{s.set("id",e);const i=this._createWorldReadableRoom(e);await this._fetchWorldReadableRoomEvents(e,100,"b",null,s);let r=await this._prepareWorldReadableRoomSummary(e,s);const o=await this._storage.readTxn([this._storage.storeNames.timelineFragments,this._storage.storeNames.timelineEvents,this._storage.storeNames.roomMembers]);return await i.load(r,o,s),i})}async _prepareWorldReadableRoomSummary(e,t=null){return this._platform.logger.wrapOrRun(t,"prepareWorldReadableRoomSummary",async s=>{s.set("id",e);let i={};const r=await this._hsApi.currentState(e).response();for(let o=0;o<r.length;o++)r[o].type==="m.room.name"?i.name=r[o].content.name:r[o].type==="m.room.canonical_alias"?i.canonicalAlias=r[o].content.alias:r[o].type==="m.room.avatar"&&(i.avatarUrl=r[o].content.url);return i})}async _fetchWorldReadableRoomEvents(e,t=30,s="b",i=null,r=null){return this._platform.logger.wrapOrRun(r,"fetchWorldReadableRoomEvents",async o=>{o.set("id",e);let a={limit:t,dir:"b",filter:{lazy_load_members:!0,include_redundant_members:!0}};i!==null&&(a.from=i);const c=await this._hsApi.messages(e,a,{log:o}).response();o.set("/messages endpoint response",c),await this.deleteWorldReadableRoomData(e,o);const d=await this._storage.readWriteTxn([this._storage.storeNames.timelineFragments,this._storage.storeNames.timelineEvents]),h={roomId:e,id:0,previousId:null,nextId:null,previousToken:c.start,nextToken:null};d.timelineFragments.add(h);let l=S.defaultLiveKey;for(let u=0;u<c.chunk.length;u++){u&&(l=l.previousKey());let p=await this._storage.readWriteTxn([this._storage.storeNames.timelineEvents]),m=Ct(l,e,c.chunk[u]);await p.timelineEvents.tryInsert(m,o)}return c})}async deleteWorldReadableRoomData(e,t=null){return this._platform.logger.wrapOrRun(t,"deleteWorldReadableRoomData",async s=>{s.set("id",e);const i=await this._storage.readWriteTxn([this._storage.storeNames.timelineFragments,this._storage.storeNames.timelineEvents]);i.timelineFragments.removeAllForRoom(e),i.timelineEvents.removeAllForRoom(e)})}joinRoom(e,t=null){return this._platform.logger.wrapOrRun(t,"joinRoom",async s=>(await this._hsApi.joinIdOrAlias(e,{log:s}).response()).room_id)}async isWorldReadableRoom(e,t=null){return this._platform.logger.wrapOrRun(t,"isWorldReadableRoom",async s=>{try{let i;return e.startsWith("!")?i=e:i=(await this._hsApi.resolveRoomAlias(e).response()).room_id,(await this._hsApi.state(i,"m.room.history_visibility","",{log:s}).response()).history_visibility==="world_readable"}catch{return!1}})}}const tc={"image/jpeg":!0,"image/gif":!0,"image/png":!0,"video/mp4":!0,"video/webm":!0,"video/ogg":!0,"video/quicktime":!0,"video/VP8":!0,"audio/mp4":!0,"audio/webm":!0,"audio/aac":!0,"audio/mpeg":!0,"audio/ogg":!0,"audio/wave":!0,"audio/wav":!0,"audio/x-wav":!0,"audio/x-pn-wav":!0,"audio/flac":!0,"audio/x-flac":!0},Ti="application/octet-stream";class pt{constructor(e,t=null){this._blob=e,this._buffer=t,this._url=null}static fromBuffer(e,t){return t=t?t.split(";")[0].trim():"",tc[t]||(t=Ti),new pt(new Blob([e],{type:t}),e)}static fromBlob(e){return new pt(e)}get nativeBlob(){return this._blob}async readAsBuffer(){if(this._buffer)return this._buffer;{const e=new FileReader,t=new Promise((s,i)=>{e.addEventListener("load",r=>s(r.target.result)),e.addEventListener("error",r=>i(r.target.error))});return e.readAsArrayBuffer(this._blob),t}}get url(){return this._url||(this._url=URL.createObjectURL(this._blob)),this._url}get size(){return this._blob.size}get mimeType(){return this._blob.type||Ti}dispose(){this._url&&(URL.revokeObjectURL(this._url),this._url=null)}}function Ai(n){return Object.entries(n||{}).filter(([,e])=>e!==void 0).map(([e,t])=>(typeof t=="object"&&(t=JSON.stringify(t)),`${encodeURIComponent(e)}=${encodeURIComponent(t)}`)).join("&")}function sc(n){if(n instanceof pt){const e=n;return{mimeType:e.mimeType,body:e}}else{if(n instanceof Map)return{mimeType:"multipart/form-data",body:n};if(typeof n=="object"){const e=JSON.stringify(n);return{mimeType:"application/json",body:e}}else throw new Error("Unknown body type: "+n)}}class ic{constructor(e,t,s,i){let r;if(i?.log){const o=i?.log;r=o.child({t:"network",url:t,method:e},o.level.Info)}this._log=r,this._sourceRequest=s,this._promise=s.response().then(o=>{if(r?.set("status",o.status),o.status>=200&&o.status<300||i?.allowedStatusCodes?.includes(o.status))return r?.finish(),o.body;if(o.status>=500){const a=new Y("Internal Server Error");throw r?.catch(a),a}else if(o.status>=400&&!o.body?.errcode){const a=new Y(`HTTP error status ${o.status} without errcode in body, assume this is a load balancer complaining the server is offline.`);throw r?.catch(a),a}else{const a=new ds(e,t,o.body,o.status);throw r?.set("errcode",a.errcode),r?.catch(a),a}},o=>{if(o.name==="AbortError"&&this._sourceRequest){const a=new Y("Service worker aborted, either updating or hit #187.");throw r?.catch(a),a}else throw o.name==="ConnectionError"&&r?.set("timeout",o.isTimeout),r?.catch(o),o})}abort(){this._sourceRequest&&(this._log?.set("aborted",!0),this._sourceRequest.abort(),this._sourceRequest=void 0)}response(){return this._promise}async responseCode(){return(await this._sourceRequest.response()).status}}const _t="/_matrix/client/r0",ft="/_matrix/client/v3",ns="/_matrix/client/unstable/org.matrix.msc2697.v2";class Ki{constructor({homeserver:e,accessToken:t,request:s,reconnector:i}){this._homeserver=e,this._accessToken=t,this._requestFn=s,this._reconnector=i}_url(e,t=_t){return this._homeserver+t+e}_baseRequest(e,t,s,i,r,o){const a=Ai(s);t=`${t}?${a}`;let c;const d=new Map;if(o&&d.set("Authorization",`Bearer ${o}`),d.set("Accept","application/json"),i){const u=sc(i);d.set("Content-Type",u.mimeType),c=u.body}const h=this._requestFn(t,{method:e,headers:d,body:c,timeout:r?.timeout,uploadProgress:r?.uploadProgress,format:"json",cache:e!=="GET"}),l=new ic(e,t,h,r);return this._reconnector&&l.response().catch(u=>{u.name==="ConnectionError"&&this._reconnector.onRequestFailed(this)}),l}_unauthedRequest(e,t,s,i,r){return this._baseRequest(e,t,s,i,r)}_authedRequest(e,t,s,i,r){return this._baseRequest(e,t,s,i,r,this._accessToken)}_post(e,t,s,i){return this._authedRequest("POST",this._url(e,i?.prefix||_t),t,s,i)}_put(e,t,s,i){return this._authedRequest("PUT",this._url(e,i?.prefix||_t),t,s,i)}_get(e,t,s,i){return this._authedRequest("GET",this._url(e,i?.prefix||_t),t,s,i)}sync(e,t,s,i){return this._get("/sync",{since:e,timeout:s,filter:t},void 0,i)}resolveRoomAlias(e){return this._unauthedRequest("GET",this._url(`/directory/room/${encodeURIComponent(e)}`,ft))}context(e,t,s,i){return this._get(`/rooms/${encodeURIComponent(e)}/context/${encodeURIComponent(t)}`,{filter:i,limit:s})}messages(e,t,s){return this._get(`/rooms/${encodeURIComponent(e)}/messages`,t,void 0,s)}members(e,t,s){return this._get(`/rooms/${encodeURIComponent(e)}/members`,t,void 0,s)}send(e,t,s,i,r){return this._put(`/rooms/${encodeURIComponent(e)}/send/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{},i,r)}redact(e,t,s,i,r){return this._put(`/rooms/${encodeURIComponent(e)}/redact/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{},i,r)}receipt(e,t,s,i){return this._post(`/rooms/${encodeURIComponent(e)}/receipt/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{},{},i)}state(e,t,s,i){return this._get(`/rooms/${encodeURIComponent(e)}/state/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{},void 0,i)}sendState(e,t,s,i,r){return this._put(`/rooms/${encodeURIComponent(e)}/state/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{},i,r)}currentState(e){return this._get(`/rooms/${encodeURIComponent(e)}/state`,{},void 0)}getLoginFlows(){return this._unauthedRequest("GET",this._url("/login"))}register(e,t,s,i,r=!1,o={}){o.allowedStatusCodes=[401];const a={auth:i,password:t,initial_device_displayname:s,inhibit_login:r};return e&&(a.username=e),this._unauthedRequest("POST",this._url("/register",ft),void 0,a,o)}passwordLogin(e,t,s,i){return this._unauthedRequest("POST",this._url("/login"),void 0,{type:"m.login.password",identifier:{type:"m.id.user",user:e},password:t,initial_device_display_name:s},i)}tokenLogin(e,t,s,i){return this._unauthedRequest("POST",this._url("/login"),void 0,{type:"m.login.token",identifier:{type:"m.id.user"},token:e,txn_id:t,initial_device_display_name:s},i)}guestLogin(e,t){return this._unauthedRequest("POST",this._url("/register",ft),{kind:"guest"},{initial_device_displayname:e||"Guest account on "+this._homeserver})}whoami(){return this._get("/account/whoami",void 0,void 0,{prefix:ft})}createFilter(e,t,s){return this._post(`/user/${encodeURIComponent(e)}/filter`,{},t,s)}versions(e){return this._unauthedRequest("GET",`${this._homeserver}/_matrix/client/versions`,void 0,void 0,e)}uploadKeys(e,t,s){let i="/keys/upload";return e&&(i=i+`/${encodeURIComponent(e)}`),this._post(i,{},t,s)}uploadSignatures(e,t){return this._post("/keys/signatures/upload",{},e,t)}queryKeys(e,t){return this._post("/keys/query",{},e,t)}claimKeys(e,t){return this._post("/keys/claim",{},e,t)}sendToDevice(e,t,s,i){return this._put(`/sendToDevice/${encodeURIComponent(e)}/${encodeURIComponent(s)}`,{},t,i)}roomKeysVersion(e,t){let s="";return e&&(s=`/${encodeURIComponent(e)}`),this._get(`/room_keys/version${s}`,void 0,void 0,t)}roomKeyForRoomAndSession(e,t,s,i){return this._get(`/room_keys/keys/${encodeURIComponent(t)}/${encodeURIComponent(s)}`,{version:e},void 0,i)}uploadRoomKeysToBackup(e,t,s){return this._put("/room_keys/keys",{version:e},t,s)}uploadAttachment(e,t,s){return this._authedRequest("POST",`${this._homeserver}/_matrix/media/r0/upload`,{filename:t},e,s)}setPusher(e,t){return this._post("/pushers/set",{},e,t)}getPushers(e){return this._get("/pushers",void 0,void 0,e)}join(e,t){return this._post(`/rooms/${encodeURIComponent(e)}/join`,{},{},t)}joinIdOrAlias(e,t){return this._post(`/join/${encodeURIComponent(e)}`,{},{},t)}leave(e,t){return this._post(`/rooms/${encodeURIComponent(e)}/leave`,{},{},t)}forget(e,t){return this._post(`/rooms/${encodeURIComponent(e)}/forget`,{},{},t)}logout(e){return this._post("/logout",{},{},e)}getDehydratedDevice(e={}){return e.prefix=ns,this._get("/dehydrated_device",void 0,void 0,e)}createDehydratedDevice(e,t={}){return t.prefix=ns,this._put("/dehydrated_device",{},e,t)}claimDehydratedDevice(e,t={}){return t.prefix=ns,this._post("/dehydrated_device/claim",{},{device_id:e},t)}profile(e,t){return this._get(`/profile/${encodeURIComponent(e)}`)}createRoom(e,t){return this._post("/createRoom",{},e,t)}setAccountData(e,t,s,i){return this._put(`/user/${encodeURIComponent(e)}/account_data/${encodeURIComponent(t)}`,{},s,i)}getTurnServer(e){return this._get("/voip/turnServer",void 0,void 0,e)}}class rc{constructor(e,t){this.methodName=e,this.args=t,this._responsePromise=new Promise((s,i)=>{this.responseResolve=s,this.responseReject=i})}abort(){this._requestResult?this._requestResult.abort():(this.responseReject(new L),this.responseCodeReject?.(new L))}response(){return this._responsePromise}responseCode(){return this.requestResult?this.requestResult.responseCode():(this._responseCodePromise||(this._responseCodePromise=new Promise((e,t)=>{this.responseCodeResolve=e,this.responseCodeReject=t})),this._responseCodePromise)}async setRequestResult(e){this._requestResult=e;const t=await this._requestResult?.response();this.responseResolve(t);const s=await this._requestResult?.responseCode();this.responseCodeResolve?.(s)}get requestResult(){return this._requestResult}}class xi{constructor(e){this._scheduler=e}}for(const n of Object.getOwnPropertyNames(Ki.prototype))n!=="constructor"&&!n.startsWith("_")&&(xi.prototype[n]=function(...e){return this._scheduler._hsApiRequest(n,e)});class nc{constructor({hsApi:e,clock:t}){this._requests=new Set,this._stopped=!1,this._wrapper=new xi(this),this._hsApi=e,this._clock=t}get hsApi(){return this._wrapper}stop(){this._stopped=!0;for(const e of this._requests)e.abort();this._requests.clear()}start(){this._stopped=!1}_hsApiRequest(e,t){const s=new rc(e,t);return this._doSend(s),s}async _doSend(e){this._requests.add(e);try{let t;for(;!this._stopped;)try{const s=this._hsApi[e.methodName].apply(this._hsApi,e.args);await e.setRequestResult(s);return}catch(s){if(s instanceof ds&&s.errcode==="M_LIMIT_EXCEEDED")Number.isSafeInteger(s.retry_after_ms)?await this._clock.createTimeout(s.retry_after_ms).elapsed():(t||(t=new fs(this._clock.createTimeout)),await t.waitForRetry());else{e.responseReject(s);return}}this._stopped&&e.abort()}finally{this._requests.delete(e)}}}class oc{constructor({homeserver:e,platform:t}){this._homeserver=e,this._platform=t}mxcUrlThumbnail(e,t,s,i){const r=this._parseMxcUrl(e);if(r){const[o,a]=r;return`${this._homeserver}/_matrix/media/r0/thumbnail/${encodeURIComponent(o)}/${encodeURIComponent(a)}`+"?"+Ai({width:Math.round(t),height:Math.round(s),method:i})}}mxcUrl(e){const t=this._parseMxcUrl(e);if(t){const[s,i]=t;return`${this._homeserver}/_matrix/media/r0/download/${encodeURIComponent(s)}/${encodeURIComponent(i)}`}}_parseMxcUrl(e){const t="mxc://";if(e.startsWith(t))return e.substr(t.length).split("/",2)}async downloadEncryptedFile(e,t=!1){const s=this.mxcUrl(e.url),{body:i}=await this._platform.request(s,{method:"GET",format:"buffer",cache:t}).response(),r=await xo(this._platform,i,e);return this._platform.createBlob(r,e.mimetype)}async downloadPlaintextFile(e,t,s=!1){const i=this.mxcUrl(e),{body:r}=await this._platform.request(i,{method:"GET",format:"buffer",cache:s}).response();return this._platform.createBlob(r,t)}async downloadAttachment(e,t=!1){return e.file?this.downloadEncryptedFile(e.file,t):this.downloadPlaintextFile(e.url,e.info?.mimetype,t)}}class ac extends ye{constructor(e){super(),this._queues=new Map;const{storage:t,hsApi:s}=e;this._storage=t,this._hsApi=s}createQueue(e,t){const s=new Ko({roomId:e,storage:this._storage,hsApi:this._hsApi,pendingEvents:t});return s.on("pendingEvent",i=>this.emit("pendingEvent",i)),this._queues.set(e,s),s}getQueue(e){return this._queues.get(e)}}class cc{constructor(e){const{platform:t,features:s,reconnector:i}=e;this._platform=t,this._features=s,this._reconnector=i}make(e){const{sessionInfo:t,storage:s,olm:i,olmWorker:r}=e,o=new Ki({homeserver:t.homeServer,accessToken:t.accessToken,request:this._platform.request,reconnector:this._reconnector}),a=new nc({hsApi:o,clock:this._platform.clock}),c=new oc({homeserver:t.homeServer,platform:this._platform}),d=new ac({storage:s,hsApi:o});return{session:new ec({platform:this._platform,features:this._features,storage:s,sessionInfo:t,hsApi:a.hsApi,olm:i,olmWorker:r,mediaRepository:c,sendQueuePool:d}),scheduler:a}}}class Re{constructor(e,t,s,i){this._logger=s,this.start=s._now(),this._values=typeof e=="string"?{l:e}:e,this.logLevel=t,this._filterCreator=i}runDetached(e,t,s,i){return this._logger.runDetached(e,t,s,i)}wrapDetached(e,t,s,i){this.refDetached(this.runDetached(e,t,s,i))}refDetached(e,t){e.ensureRefId(),this.log({ref:e.values.refId},t)}ensureRefId(){this._values.refId||this.set("refId",this._logger._createRefId())}wrap(e,t,s,i){return this.child(e,s,i).run(t)}get duration(){if(this.end)return this.end-this.start}durationWithoutType(e){const t=this.durationOfType(e);if(this.duration&&t)return this.duration-t}durationOfType(e){return this._values.t===e?this.duration:this._children?this._children.reduce((t,s)=>{const i=s.durationOfType(e);return t+(i??0)},0):0}log(e,t){const s=this.child(e,t);return s.end=s.start,s}set(e,t){if(typeof e=="object"){const s=e;Object.assign(this._values,s)}else this._values[e]=t;return this}serialize(e,t,s){if(this._filterCreator)try{e=this._filterCreator(new Ft(e),this)}catch(o){console.error("Error creating log filter",o)}let i=null;if(this._children&&(i=this._children.reduce((o,a)=>{const c=a.serialize(e,this.start,!1);return c&&(o===null&&(o=[]),o.push(c)),o},null)),e&&!e.filter(this,i))return;const r={s:typeof t=="number"?this.start-t:this.start,d:this.duration,v:this._values,l:this.logLevel};return this.error&&(r.e={stack:this.error.stack,name:this.error.name,message:this.error.message.split(`
`)[0]}),s&&(r.f=!0),i&&(r.c=i),r}run(e){this.end!==void 0&&console.trace("log item is finished, additional logs will likely not be recorded");try{const t=e(this);return t instanceof Promise?t.then(s=>(this.finish(),s),s=>{throw this.catch(s)}):(this.finish(),t)}catch(t){throw this.catch(t)}}finish(){if(this.end===void 0){if(this._children)for(const e of this._children)e.finish();this.end=this._logger._now()}}forceFinish(){this.finish()}get level(){return O}catch(e){return this.error=e,this.logLevel=O.Error,this.finish(),e}child(e,t,s){this.end&&console.trace(`log item ${this.values.l} finished, additional log ${JSON.stringify(e)} will likely not be recorded`),t||(t=this.logLevel||O.Info);const i=new Re(e,t,this._logger,s);return this._children||(this._children=[]),this._children.push(i),i}get logger(){return this._logger}get values(){return this._values}get children(){return this._children}}class dc{constructor({platform:e}){this._openItems=new Set,this.reporters=[],this._platform=e}log(e,t=O.Info){const s=new Re(e,t,this);return s.end=s.start,this._persistItem(s,void 0,!1),s}child(e,t=O.Info,s){const i=new hc(e,t,this,s);return this._openItems.add(i),i}wrapOrRun(e,t,s,i,r){return e?e.wrap(t,s,i,r):this.run(t,s,i,r)}runDetached(e,t,s,i){s||(s=O.Info);const r=new Re(e,s,this);return this._run(r,t,s,!1,i),r}run(e,t,s,i){s===void 0&&(s=O.Info);const r=new Re(e,s,this);return this._run(r,t,s,!0,i)}_run(e,t,s,i,r){this._openItems.add(e);const o=()=>{let a=new Ft;if(r)try{a=r(a,e)}catch(c){console.error("Error while creating log filter",c)}else a=a.minLevel(s);try{this._persistItem(e,a,!1)}catch(c){console.error("Could not persist log item",c)}this._openItems.delete(e)};try{let a=e.run(t);if(a instanceof Promise){if(a=a.then(c=>(o(),c),c=>{if(o(),i)throw c}),i)return a}else if(o(),i)return a}catch(a){if(o(),i)throw a}}addReporter(e){e.setLogger(this),this.reporters.push(e)}getOpenRootItems(){return this._openItems}forceFinish(){for(const e of this._openItems){e.forceFinish();try{this._persistItem(e,new Ft,!0)}catch(t){console.error("Could not serialize log item",t)}}this._openItems.clear()}_removeItemFromOpenList(e){this._openItems.delete(e)}_persistItem(e,t,s){for(var i=0;i<this.reporters.length;i+=1)this.reporters[i].reportItem(e,t,s)}get level(){return O}_now(){return this._platform.clock.now()}_createRefId(){return Math.round(this._platform.random()*Number.MAX_SAFE_INTEGER)}}class hc extends Re{finish(){super.finish(),this._logger._persistItem(this,void 0,!1),this._logger._removeItemFromOpenList(this)}forceFinish(){super.finish()}}class lc{reportItem(e){Di(e)}setLogger(e){this.logger=e}printOpenItems(){if(!!this.logger)for(const e of this.logger.getOpenRootItems())this.reportItem(e)}}const uc=["l","id"];function mc(n){return Object.entries(n).filter(([e])=>!uc.includes(e)).reduce((e,[t,s])=>(e=e||{},e[t]=s,e),null)}function Di(n){const e=`${pc(n)} (@${n.start}ms, duration: ${n.duration}ms)`,t=mc(n.values),s=n.children||t;if(s?(n.error?console.group(e):console.groupCollapsed(e),n.error&&console.error(n.error)):n.error?console.error(n.error):console.log(e),t&&console.table(t),n.children)for(const i of n.children)Di(i);s&&console.groupEnd()}function pc(n){return n.values.t==="network"?`${n.values.method} ${n.values.url}`:n.values.l&&typeof n.values.id<"u"?`${n.values.l} ${n.values.id}`:n.values.l&&typeof n.values.status<"u"?`${n.values.l} (${n.values.status})`:n.values.l&&typeof n.values.type<"u"?`${n.values.l} (${n.values.type})`:n.values.l&&n.error?`${n.values.l} failed`:typeof n.values.ref<"u"?`ref ${n.values.ref}`:n.values.l||n.values.type}const _c=3e4,T=bt("InitialSync","CatchupSync","Syncing","Stopped");function fc(n){try{const e=n?.timeline?.events;return Array.isArray(e)&&e.length===0}catch{return!0}}class yc{constructor({hsApi:e,session:t,storage:s,logger:i}){this._hsApi=e,this._logger=i,this._session=t,this._storage=s,this._currentRequest=null,this._status=new re(T.Stopped),this._error=null}get status(){return this._status}get error(){return this._error}async start(){if(this._status.get()!==T.Stopped)return;this._error=null;let e=this._session.syncToken;e?this._status.set(T.CatchupSync):this._status.set(T.InitialSync),this._syncLoop(e)}async _syncLoop(e){for(;this._status.get()!==T.Stopped;){let t,s,i=this._status.get()===T.CatchupSync||this._status.get()===T.InitialSync;await this._logger.run("sync",async r=>{r.set("token",e),r.set("status",this._status.get());try{const o=this._status.get()===T.Syncing?_c:0,a=await this._syncRequest(e,o,r);e=a.syncToken,t=a.roomStates,s=a.sessionChanges,this._status.get()!==T.Syncing&&a.hadToDeviceMessages?this._status.set(T.CatchupSync):this._status.set(T.Syncing)}catch(o){if(o.name==="ConnectionError"&&o.isTimeout)return;this._error=o,o.name!=="AbortError"&&(r.error=o,r.logLevel=r.level.Fatal),r.set("stopping",!0),this._status.set(T.Stopped)}this._status.get()!==T.Stopped&&await r.wrap("afterSyncCompleted",o=>this._runAfterSyncCompleted(s,t,o))},this._logger.level.Info,(r,o)=>o.durationWithoutType("network")>=2e3||o.error||i?r.minLevel(o.level.Detail):r.minLevel(o.level.Info))}}async _runAfterSyncCompleted(e,t,s){const i=this._status.get()===T.CatchupSync,r=(async()=>{try{await s.wrap("session",a=>this._session.afterSyncCompleted(e,i,a))}catch{}})(),o=t.map(async a=>{try{await a.room.afterSyncCompleted(a.changes,s)}catch{}});await Promise.all(o.concat(r))}async _syncRequest(e,t,s){let{syncFilterId:i}=this._session;!await this._session.isGuest()&&typeof i!="string"&&(this._currentRequest=this._hsApi.createFilter(this._session.user.id,{room:{state:{lazy_load_members:!0}}},{log:s}),i=(await this._currentRequest.response()).filter_id);const o=t+80*1e3;this._currentRequest=this._hsApi.sync(e,i,t,{timeout:o,log:s});const a=await this._currentRequest.response(),c=!e,d=new gc,h=this._parseInvites(a.rooms),{roomStates:l,archivedRoomStates:u}=await this._parseRoomsResponse(a.rooms,h,c,s);try{d.lock=await s.wrap("obtainSyncLock",()=>this._session.obtainSyncLock(a)),await s.wrap("prepare",m=>this._prepareSync(d,l,a,m)),await s.wrap("afterPrepareSync",m=>Promise.all(l.map(_=>_.room.afterPrepareSync(_.preparation,m)))),await s.wrap("write",async m=>this._writeSync(d,h,l,u,a,i,c,m))}finally{d.dispose()}s.wrap("after",m=>this._afterSync(d,h,l,u,m));const p=a.to_device?.events;return{syncToken:a.next_batch,roomStates:l,sessionChanges:d.changes,hadToDeviceMessages:Array.isArray(p)&&p.length>0}}_openPrepareSyncTxn(){const e=this._storage.storeNames;return this._storage.readTxn([e.deviceIdentities,e.olmSessions,e.inboundGroupSessions,e.timelineFragments,e.timelineEvents])}async _prepareSync(e,t,s,i){const r=await this._openPrepareSyncTxn();e.preparation=await i.wrap("session",a=>this._session.prepareSync(s,e.lock,r,a));const o=e.preparation?.newKeysByRoom;if(o){const{hasOwnProperty:a}=Object.prototype;for(const c of o.keys())if(!(s.rooms?.join&&a.call(s.rooms.join,c))){let h=this._session.rooms.get(c);h&&t.push(new Ui(h,!1,{},h.membership))}}await Promise.all(t.map(async a=>{const c=o?.get(a.room.id);a.preparation=await i.wrap("room",async d=>(a.isNewRoom&&await a.room.load(null,r,d),a.room.prepareSync(a.roomResponse,a.membership,c,r,d)),i.level.Detail)})),await r.complete()}async _writeSync(e,t,s,i,r,o,a,c){const d=await this._openSyncTxn();try{e.changes=await c.wrap("session",h=>this._session.writeSync(r,o,e.preparation,d,h)),await Promise.all(t.map(async h=>{h.changes=await c.wrap("invite",l=>h.invite.writeSync(h.membership,h.roomResponse,d,l))})),await Promise.all(s.map(async h=>{h.changes=await c.wrap("room",l=>h.room.writeSync(h.roomResponse,a,h.preparation,d,l))})),await Promise.all(i.map(async h=>{const l=h.roomState?.summaryChanges;h.changes=await c.wrap("archivedRoom",u=>h.archivedRoom.writeSync(l,h.roomResponse,h.membership,d,u))}))}catch(h){throw d.abort(c),d.getCause(h)}await d.complete(c)}_afterSync(e,t,s,i,r){r.wrap("session",o=>this._session.afterSync(e.changes,o),r.level.Detail);for(let o of i)r.wrap("archivedRoom",a=>{o.archivedRoom.afterSync(o.changes,a),o.archivedRoom.release()},r.level.Detail);for(let o of s)r.wrap("room",a=>o.room.afterSync(o.changes,a),r.level.Detail);for(let o of t)r.wrap("invite",a=>o.invite.afterSync(o.changes,a),r.level.Detail);this._session.applyRoomCollectionChangesAfterSync(t,s,i,r)}_openSyncTxn(){const e=this._storage.storeNames;return this._storage.readWriteTxn([e.session,e.roomSummary,e.archivedRoomSummary,e.invites,e.roomState,e.roomMembers,e.timelineEvents,e.timelineRelations,e.timelineFragments,e.pendingEvents,e.userIdentities,e.groupSessionDecryptions,e.deviceIdentities,e.outboundGroupSessions,e.operations,e.accountData,e.olmSessions,e.inboundGroupSessions,e.calls])}async _parseRoomsResponse(e,t,s,i){const r=[],o=[];if(e){const a=["join","leave"];for(const c of a){const d=e[c];if(d)for(const[h,l]of Object.entries(d)){if(s&&fc(l))continue;const u=this._session.invites.get(h);u&&t.push(new Fi(u,!1,null,c));const p=this._createRoomSyncState(h,l,c,s);p&&r.push(p);const m=await this._createArchivedRoomSyncState(h,p,l,c,s,i);m&&o.push(m)}}}return{roomStates:r,archivedRoomStates:o}}_createRoomSyncState(e,t,s,i){let r=!1,o=this._session.rooms.get(e);if(!o&&(s==="join"||i&&s==="leave")&&(o=this._session.createJoinedRoom(e),r=!0),o)return new Ui(o,r,t,s)}async _createArchivedRoomSyncState(e,t,s,i,r,o){let a;if(t?.shouldAdd&&!r?a=this._session.createOrGetArchivedRoomForSync(e):i==="leave"&&(t?a=this._session.createOrGetArchivedRoomForSync(e):a=await this._session.loadArchivedRoom(e,o)),a)return new vc(a,t,s,i)}_parseInvites(e){const t=[];if(e?.invite)for(const[s,i]of Object.entries(e.invite)){let r=this._session.invites.get(s),o=!1;r||(r=this._session.createInvite(s),o=!0),t.push(new Fi(r,o,i,"invite"))}return t}stop(){this._status.get()!==T.Stopped&&(this._status.set(T.Stopped),this._currentRequest&&(this._currentRequest.abort(),this._currentRequest=null))}}class gc{constructor(){this.lock=null,this.preparation=null,this.changes=null}dispose(){this.lock?.release()}}class Ui{constructor(e,t,s,i){this.room=e,this.isNewRoom=t,this.roomResponse=s,this.membership=i,this.preparation=null,this.changes=null}get id(){return this.room.id}get shouldAdd(){return this.isNewRoom&&this.membership==="join"}get shouldRemove(){return!this.isNewRoom&&this.membership!=="join"}get summaryChanges(){return this.changes?.summaryChanges}}class vc{constructor(e,t,s,i,r){this.archivedRoom=e,this.roomState=t,this.roomResponse=s,this.membership=i,this.isInitialSync=r,this.changes=null}get id(){return this.archivedRoom.id}get shouldAdd(){return(this.roomState||this.isInitialSync)&&this.membership==="leave"}get shouldRemove(){return this.membership==="join"}}class Fi{constructor(e,t,s,i){this.invite=e,this.isNewInvite=t,this.membership=i,this.roomResponse=s,this.changes=null}get id(){return this.invite.id}get shouldAdd(){return this.isNewInvite}get shouldRemove(){return this.membership!=="invite"}}function wc(n){return n.changes}function bc(n){const{room:e,changes:t}=n,{roomResponse:s,summaryChanges:i,heroChanges:r,powerLevelsEvent:o}=t,a=t.newEntries.map(u=>u.data),c=t.updatedEntries.map(u=>u.data),d=t.removedPendingEvents.map(u=>u.data),h=new Map;for(let[u,p]of t.memberChanges){const{member:m,previousMembership:_}=p;h.set(u,{member:m.data,previousMembership:_})}const l={fragmentId:t.newLiveKey.fragmentId,eventIndex:t.newLiveKey.eventIndex};return{roomId:e.id,changes:{roomResponse:s,newEntries:a,updatedEntries:c,memberChanges:h,newLiveKey:l,summaryChanges:i,heroChanges:r,powerLevelsEvent:o,removedPendingEvents:d}}}class Ic extends yc{constructor(e){const{eventBus:t,...s}=e;super(s),this._eventBus=t}async start(){return super.start()}get status(){return super.status}_afterSync(e,t,s,i,r){super._afterSync(e,t,s,i,r);const o=wc(e),a=s.map(d=>bc(d)),c={type:gt.SyncChanges,id:as(),data:{syncStatus:this.status.get(),session:o,rooms:a}};this._eventBus.postMessage(c)}}class Sc extends Li{constructor(e){super();const{assets:t}=e;this._eventBus=new BroadcastChannel(this.name),this._platform=new Sr({assets:t}),this._features=new qe,this._logger=new dc({platform:this._platform}),this._logger.addReporter(new lc),this._storageFactory=new eo,this._onlineStatus=new Rr,this._reconnector=new Er({onlineStatus:this._onlineStatus,retryDelay:new fs(this._platform.clock.createTimeout),createMeasure:this._platform.clock.createMeasure}),this._sessionFactory=new cc({platform:this._platform,features:this._features,reconnector:this._reconnector}),this.setHandler(yt.StartSync,this.startSync.bind(this)),this.setHandler(yt.AddPendingEvent,this.addPendingEvent.bind(this))}async startSync(e){const t={request:e,data:{syncStatus:this._sync?.status.get()}};if(this._sync)return t;const{session:s,storage:i,scheduler:r}=await this.loadSession(e);return s.hasIdentity?(this._session=s,this._storage=i,this._scheduler=r,this._sync=new Ic({logger:this._logger,hsApi:this._scheduler.hsApi,session:this._session,storage:this._storage,eventBus:this._eventBus}),this._sync.status.subscribe(this.onSyncStatusChanged.bind(this)),await this._sync.start(),t.data.syncStatus=this._sync.status.get(),t):(t.error=new Error("Sync was started before the session was correctly initiated"),t)}async addPendingEvent(e){if(!this._session)throw"No sync is in progress";const t=e.data.pendingEvent,s=t.roomId,i=this._session.sendQueuePool.getQueue(s);if(!i)throw`Send queue for room with id ${s} was not found`;return i.addExistingPendingEvent(t),{request:e,data:{}}}onSyncStatusChanged(){const e={id:as(),type:gt.StatusChanged,data:{newValue:this._sync?.status.get()}};this.broadcastEvent(e)}broadcastEvent(e){this._eventBus.postMessage(e)}async loadSession(e){const t={id:e.data.sessionId,deviceId:e.data.deviceId,userId:e.data.userId,homeServer:e.data.homeserver,accessToken:e.data.accessToken};let s;await this._logger.run("sync worker: init storage",async c=>{s=await this._storageFactory.create(t.id,c)});const i=await this._platform.loadOlm(),r=await this._platform.loadOlmWorker(),{session:o,scheduler:a}=this._sessionFactory.make({storage:s,olm:i,olmWorker:r,sessionInfo:t});return await this._logger.run("sync worker: load session",async c=>{await o.load(c)}),{session:o,storage:s,scheduler:a}}}var Ec="assets/download-sandbox.48a866e9.html",Rc="assets/main.5b3f6f97.js",kc="assets/olm.b3e0f9b4.wasm",Mc="assets/olm.92f1ccd0.js",Cc="assets/olm_legacy.9dc48f49.js",Pi={downloadSandbox:Ec,worker:Rc,olm:{wasm:kc,legacyBundle:Cc,wasmBundle:Mc}};self.syncWorker=new Sc({assets:{olmWasmJsPath:Oi(Pi.olm.wasmBundle),olmWasmPath:Oi(Pi.olm.wasm)}});function Oi(n){return n.replace(/(\.\/)?assets\//,"./")}})();
